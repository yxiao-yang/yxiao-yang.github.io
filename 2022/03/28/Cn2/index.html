

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="写在前面 纸上得来终觉浅，绝知此事要躬行。  一、应用层协议原理研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。因此研发新应用时需要编写将在多台端系统上运行的软件。 1.1 网络应用程序体系结构应用程序体系结构（application architecture）明显不同于网络体系结构。网络体系结构是固定的，而应用程序体系结构由应用程序研发者设计。应用程序体系结构目前有两">
<meta property="og:type" content="article">
<meta property="og:title" content="02：应用层">
<meta property="og:url" content="http://example.com/2022/03/28/Cn2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="写在前面 纸上得来终觉浅，绝知此事要躬行。  一、应用层协议原理研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。因此研发新应用时需要编写将在多台端系统上运行的软件。 1.1 网络应用程序体系结构应用程序体系结构（application architecture）明显不同于网络体系结构。网络体系结构是固定的，而应用程序体系结构由应用程序研发者设计。应用程序体系结构目前有两">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-28T09:46:37.524Z">
<meta property="article:modified_time" content="2022-03-30T01:30:55.154Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>02：应用层 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>小羊</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="02：应用层">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-28 17:46" pubdate>
        2022年3月28日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.3k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      78 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">02：应用层</h1>
            
            <div class="markdown-body">
              <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p><em><strong>纸上得来终觉浅，绝知此事要躬行。</strong></em></p>
</blockquote>
<h1 id="一、应用层协议原理"><a href="#一、应用层协议原理" class="headerlink" title="一、应用层协议原理"></a>一、应用层协议原理</h1><p>研发网络应用程序的<strong>核心</strong>是写出能够运行在不同的端系统和通过网络彼此通信的程序。因此研发新应用时需要编写将在<strong>多台端系统</strong>上运行的软件。</p>
<h2 id="1-1-网络应用程序体系结构"><a href="#1-1-网络应用程序体系结构" class="headerlink" title="1.1 网络应用程序体系结构"></a>1.1 网络应用程序体系结构</h2><p><strong>应用程序体系结构</strong>（application architecture）明显不同于网络体系结构。网络体系结构是固定的，而应用程序体系结构由应用程序研发者设计。<br>应用程序体系结构目前有两种主流体系结构：<strong>客户-服务器体系结构</strong>或<strong>对等（P2P）体系结构</strong>。</p>
<h3 id="1-1-1-客户-服务器体系结构"><a href="#1-1-1-客户-服务器体系结构" class="headerlink" title="1.1.1 客户-服务器体系结构"></a>1.1.1 客户-服务器体系结构</h3><p>在客户-服务器体系结构中，有一个总是打开的主机称为<strong>服务器</strong>，它服务于来自许多其他称为<strong>客户</strong>的主机的请求。客户相互之间<strong>不直接通信</strong>。另一方面，该服务器具有固定的、周知的地址，该地址称为<strong>IP地址</strong>。</p>
<p><a href="/img/cn2.1.png">图为客户-服务器体系结构</a></p>
<p>在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。为此，配备大量主机的<strong>数据中心</strong>常被用于创建强大的虚拟服务器。如谷歌在全球拥有30~50个数据中心。一个数据中心能够有数十万台服务器，它们必须要供电和维护。</p>
<h3 id="1-1-2-P2P体系结构"><a href="#1-1-2-P2P体系结构" class="headerlink" title="1.1.2 P2P体系结构"></a>1.1.2 P2P体系结构</h3><p>在一个P2P体系结构中，对位于数据中心的专用服务器有最小的（或者没有）依赖。应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为<strong>对等方</strong>。因为这些对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的。<br><a href="/img/cn2.2.png">图为P2P体系结构</a></p>
<p>P2P最引人入胜的特性之一时自扩展性（self-scalability）。例如，在一个P2P共享文件中，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加服务能力。P2P体系结构也是成本有效的，因为它们通常不需要庞大的服务器基础设施和服务器带宽。</p>
<p>未来P2P应用面临三个主要挑战：<br>1 ISP友好。<br>2 安全性。<br>3 激励。</p>
<p>需要提及的是，某些应用具有<strong>混合</strong>的体系结构，它结合了客户-服务器和P2P的元素。例如，对于许多即时通信应用而言，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间（无需通过中间服务器）直接发送。</p>
<h2 id="1-2-进程通信"><a href="#1-2-进程通信" class="headerlink" title="1.2 进程通信"></a>1.2 进程通信</h2><p>在构建网络应用程序前，还需要对运行在多个端系统上的程序是如何互相通信有所了解。进行通信的实际上是<strong>进程</strong>（process）而不是程序。一个进程可以被认为是运行在端系统中的一个程序。</p>
<p>当进程运行在<strong>相同</strong>的端系统上时，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定。</p>
<p>在两个<strong>不同</strong>端系统上的进程，通过跨越计算机网络交换<strong>报文</strong>（message）而相互通信。<strong>发送进程</strong>生成并向网络中发送报文；<strong>接收进程</strong>接收这些报文并可能通过将报文发送回去进行响应。</p>
<h3 id="1-2-1-客户和服务器进程"><a href="#1-2-1-客户和服务器进程" class="headerlink" title="1.2.1 客户和服务器进程"></a>1.2.1 客户和服务器进程</h3><p>网络应用程序由成对的进程组成，这些进程通过网络相互发送报文。对每对通信进程，我i们通常将这两个进程之一标识为客户（client），而另一个进程标识为服务器（server）。</p>
<blockquote>
<p>在给定的一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程被标识为<strong>客户</strong>，在绘画开始时等待联系的进程是<strong>服务器</strong>。</p>
</blockquote>
<h3 id="1-2-2-进程与计算机网络之间的接口"><a href="#1-2-2-进程与计算机网络之间的接口" class="headerlink" title="1.2.2 进程与计算机网络之间的接口"></a>1.2.2 进程与计算机网络之间的接口</h3><p>从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为<strong>套接字</strong>（socket）的软件接口向网络发送报文和从网络接收报文。</p>
<p>类比说明，进程类比为房子，套接字类比为门。一个进程向另一个房子发送报文就要将报文从门送出去，到另一个房子时再从门进去。</p>
<p><strong>套接字</strong>是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的<strong>应用程序编程接口</strong>（API）。应用程序开发者可以控制套接字在应用端的一切，但是对套接字在运输层端几乎没有控制权（仅限于①选择运输层协议；②也许能设定几个参数，如最大缓存和最大报文长度等）。<br><a href="/img/cn2.3.png">图为应用程序、套接字和下面的运输层协议</a></p>
<h3 id="1-2-3-进程寻址"><a href="#1-2-3-进程寻址" class="headerlink" title="1.2.3 进程寻址"></a>1.2.3 进程寻址</h3><p>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个<strong>地址</strong>。为了标识该接收进程，需要定义两种信息：<br>——主机的地址；<br>——定义在目的主机中的接收进程的标识符。</p>
<p>在因特网中，主机由其IP地址标识。除此之外，发送进程还必须指定运行在接收主机上的接收进程（接收套接字）。目的地<strong>端口号</strong>（port number）用于这里，已经给流行的应用分配了特定的端口号。</p>
<h2 id="1-3-可供应用程序使用的运输服务"><a href="#1-3-可供应用程序使用的运输服务" class="headerlink" title="1.3 可供应用程序使用的运输服务"></a>1.3 可供应用程序使用的运输服务</h2><p>在发送端的应用程序将报文推进给该套接字，在该套接字的另一侧，<strong>运输层协议</strong>负责使该报文进入接收进程的套接字。</p>
<p>包括因特网在内的很多网络提供了<strong>不止一种</strong>运输层协议。当开发一个应用时，必须要<strong>选择一种</strong>最能为你的应用需求提供恰当服务的协议。一个运输层协议能够为应用程序提供的服务可大体由四个方面进行分类：<strong>可靠数据传输</strong>、<strong>吞吐量</strong>、<strong>定时</strong>和<strong>安全性</strong>。</p>
<h3 id="1-3-1-可靠数据传输"><a href="#1-3-1-可靠数据传输" class="headerlink" title="1.3.1 可靠数据传输"></a>1.3.1 可靠数据传输</h3><p>如果一个协议提供了确保数据交付的服务，就认为提供了<strong>可靠数据传输</strong>（reliable data transfer）。当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据能无差错地到达接收进程。</p>
<p>当一个运输层协议不提供可靠数据传输时，由发送进程发送地某些数据可能不能够到达接收进程。这可能被<strong>容忍丢失的应用</strong>（loss-tolerant application）所接受，如一些多媒体应用。</p>
<h3 id="1-3-2-吞吐量"><a href="#1-3-2-吞吐量" class="headerlink" title="1.3.2 吞吐量"></a>1.3.2 吞吐量</h3><p>在沿着一条网络路径上的两个进程之间的通信会话场景中，<strong>可用吞吐量</strong>就是发送进程能够向接收进程交付比特的速率。因为其他会话将共享沿着该网络路径的带宽，并且因为这些会话将会到达和离开，该可用吞吐量将随时间波动。由此衍生出一种服务，即运输层协议能够以某种特定的速率提供<strong>确保</strong>的可用吞吐量。使用这种服务，应用程序能够请求r比特/秒的确保吞吐量，并且该运输协议能够确保可用吞吐量总是为至少r比特/秒。</p>
<p>具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong>（bandwidth-sensitive application），例如许多多媒体应用。<strong>弹性应用</strong>（elastic application）能够根据情况或多或少地利用可供使用的吞吐量，例如电子邮件、文件传输等。</p>
<h3 id="1-3-3-定时"><a href="#1-3-3-定时" class="headerlink" title="1.3.3 定时"></a>1.3.3 定时</h3><p>运输层协议也能够提供<strong>定时保证</strong>。如同具有吞吐量保证那样，定时保证能够以多种形式实现，咯如，发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。</p>
<p>这种服务对<strong>交互式实时应用程序</strong>有很大吸引力。对于非实时的应用，较低的时延总比较高的时延好，但对端到端的时延没有严格的约束。</p>
<h3 id="1-3-4-安全性"><a href="#1-3-4-安全性" class="headerlink" title="1.3.4 安全性"></a>1.3.4 安全性</h3><p>运输层协议能够为应用程序提供一种或多种<strong>安全性服务</strong>。这种服务将在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。<br>例如，在<strong>发送主机</strong>中，运输协议能够<strong>加密</strong>由发送进程传输的所有数据；<br>在<strong>接受主机</strong>中，运输层协议能够在将数据交付给接收进程之前<strong>解密</strong>这些数据。</p>
<p>此外，运输协议还能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别。</p>
<h2 id="1-4-因特网提供的运输服务"><a href="#1-4-因特网提供的运输服务" class="headerlink" title="1.4 因特网提供的运输服务"></a>1.4 因特网提供的运输服务</h2><p>因特网（更一般的是TCP/IP网络）为应用程序提供两个运输层协议，即<strong>UDP</strong>和<strong>TCP</strong>。软件开发者为因特网创建新的应用时，首先要选择<strong>UDP</strong>或者<strong>TCP</strong>。每个协议为调用它们的应用程序提供了不同的服务集合。</p>
<h3 id="1-4-1-TCP服务"><a href="#1-4-1-TCP服务" class="headerlink" title="1.4.1 TCP服务"></a>1.4.1 TCP服务</h3><p>TCP服务模型包括面向连接服务和可靠数据传输服务。</p>
<p>1 <strong>面向连接的服务</strong><br>在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的<strong>握手</strong>过程提示客户和服务器，使它们为大量分组的到来做好准备。</p>
<p>在握手阶段后。一个<strong>TCP连接</strong>（TCP connection）就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。</p>
<p>当应用程序结束报文发送时，必须拆除该连接。</p>
<p>2 <strong>可靠的数据传送服务</strong><br>通信进程能够依靠TCP，<strong>无差错、按适当顺序</strong>交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而<strong>没有字节的冗余和丢失</strong>。</p>
<p>除此之外，TCP协议还具有<strong>拥塞控制机制</strong>。当发送方和接收方之间的网络出现拥塞时，它会抑制发送进程（客户或服务器）。这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。TCP拥塞控制也试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。</p>
<h3 id="1-4-2-UDP服务"><a href="#1-4-2-UDP服务" class="headerlink" title="1.4.2 UDP服务"></a>1.4.2 UDP服务</h3><p>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无线连接的，因此在两个进程通信前没有握手过程。UDP服务提供一种不可靠数据传送服务，并且没有拥塞控制机制。</p>
<h3 id="1-4-3-因特网运输协议所不提供的服务"><a href="#1-4-3-因特网运输协议所不提供的服务" class="headerlink" title="1.4.3 因特网运输协议所不提供的服务"></a>1.4.3 因特网运输协议所不提供的服务</h3><p>TCP提供了可靠的端到端数据传送，在应用层也可以很容易地用SSL来加强以提供安全服务。今天的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证。</p>
<h2 id="1-5-应用层协议"><a href="#1-5-应用层协议" class="headerlink" title="1.5 应用层协议"></a>1.5 应用层协议</h2><p><strong>应用层协议</strong>（application-layer protrol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p>
<blockquote>
<p>特别是应用层协议定义了：<br>1 交换的报文<strong>类型</strong>，例如请求报文和响应报文<br>2 各种报文类型的<strong>语法</strong>，如报文中的各个字段及这些字段是如何描述的。<br>3 字段的<strong>语义</strong>，即这些字段中包含的信息的含义。<br>4 一个进程何时以及如何发送报文，对报文进行相应的<strong>规则</strong>。</p>
</blockquote>
<p>有些应用层协议是由RFC文档定义的，因此它们位于<strong>公共域</strong>中，例如HTTP。还有很多应用层协议是<strong>专用</strong>的，有意不为公共域使用。</p>
<p>应用层协议是网络应用的<strong>一部分</strong>。</p>
<h1 id="二、Web和HTTP"><a href="#二、Web和HTTP" class="headerlink" title="二、Web和HTTP"></a>二、Web和HTTP</h1><p>在20世纪90年代初期，一个主要的新型应用即<strong>万维网</strong>（World Wide Web）登上舞台，它极大地改变了人们与工作环境内外交流的方式。对大多数用户而言，Web最具吸引力的是它的<strong>按需操作</strong>，即用户能看到想看的内容。</p>
<h2 id="2-1-HTTP概况"><a href="#2-1-HTTP概况" class="headerlink" title="2.1 HTTP概况"></a>2.1 HTTP概况</h2><p> Web的应用层协议是<strong>超文本运输协议</strong>（HTTP),它是Web的核心。HTTP由两个程序实现：一个客户和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p>
<p><strong>Web页面</strong>（也叫文档）是由<strong>对象</strong>组成的。一个<strong>对象</strong>（object）只是一个文件，诸如一个HTML文件、一个JPEG图形、一个Java小程序或一个视频片段这样的文件，且它们可通过一个URL地址寻址。每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。</p>
<blockquote>
<p>例如，URL地址<a target="_blank" rel="noopener" href="http://www.someschool.edu/someDepartment/picture.gif%E4%B8%ADwww.someSchool.edu%E5%B0%B1%E6%98%AF%E4%B8%BB%E6%9C%BA%E5%90%8D%EF%BC%8C/someDepartment/picture.gif%E5%B0%B1%E6%98%AF%E8%B7%AF%E5%BE%84%E5%90%8D%E3%80%82">http://www.someSchool.edu/someDepartment/picture.gif中www.someSchool.edu就是主机名，/someDepartment/picture.gif就是路径名。</a></p>
</blockquote>
<p>Web<strong>浏览器</strong>实现了HTTP的客户端，所以被称为浏览器或客户；<br>Web<strong>服务器</strong>实现了HTTP的服务器端，它用于存储Web对象，每个对象由URL寻址。</p>
<p>HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。当用户请求一个Web页面时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。<br><a href="/img/cn2.4.png">图为HTTP的请求-响应行为</a></p>
<p>HTTP使用<strong>TCP</strong>作为它的支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制。</p>
<p>HTTP是一个<strong>无状态协议</strong>（stateless protrol），即不保存关于客户的任何信息。Web是一个<strong>客户-服务器体系结构</strong>。</p>
<h2 id="2-2-非持续连接和持续连接"><a href="#2-2-非持续连接和持续连接" class="headerlink" title="2.2 非持续连接和持续连接"></a>2.2 非持续连接和持续连接</h2><p>在许多因特网应用程序中，客户发出一系列请求并且服务器对每个请求进行响应。<strong>非持续连接</strong>是指每个请求/响应经一个单独的TCP发送，<strong>持续连接</strong>指所有的请求/响应经相同的TCP发送。</p>
<p>以<strong>HTTP</strong>举例研究持续连接和非持续连接的<strong>优缺点</strong>。</p>
<h3 id="2-2-1-采用非持续连接的HTTP"><a href="#2-2-1-采用非持续连接的HTTP" class="headerlink" title="2.2.1 采用非持续连接的HTTP"></a>2.2.1 采用非持续连接的HTTP</h3><p>在<strong>非持续连接</strong>的情况下，从服务器向客户传送一个Web页面的<strong>步骤</strong>，假设该页面含有一个HTML基本页面和10个JPEG图形，并且这11个对象位于同一台服务器上。该HTML文件的URL为：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.someschool.edu/someDepartment/home.index">http://www.someSchool.edu/someDepartment/home.index</a></p>
</blockquote>
<ol>
<li>HTTP<strong>客户进程</strong>在端口号80发起一个到服务器<a target="_blank" rel="noopener" href="http://www.someschool.edu的tcp连接,该端口号是http的默认端口./">www.someSchool.edu的TCP连接，该端口号是HTTP的默认端口。</a></li>
<li>HTTP<strong>客户</strong>经它的<strong>套接字</strong>向该服务器发送一个HTTP请求报文。请求报文中包含了<strong>路径名</strong>/someDepartment/home.index</li>
<li>HTTP<strong>服务器进程</strong>经它的<strong>套接字</strong>向该服务器发送一个HTTP请求报文。从其<strong>存储器</strong>（RAM或磁盘）中检索出对象<a target="_blank" rel="noopener" href="http://www.someschool.edu/someDepartment/home.index%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AAHTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E4%B8%AD**%E5%B0%81%E8%A3%85**%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87%E5%85%B6%E5%A5%97%E6%8E%A5%E5%AD%97%E5%90%91%E5%AE%A2%E6%88%B7%E5%8F%91%E9%80%81**%E5%93%8D%E5%BA%94**%E6%8A%A5%E6%96%87%E3%80%82">www.someSchool.edu/someDepartment/home.index，在一个HTTP响应报文中**封装**对象，并通过其套接字向客户发送**响应**报文。</a></li>
<li>HTTP<strong>服务器进程</strong>通知TCP断开该TCP连接。</li>
<li>HTTP<strong>客户</strong>接收响应报文，TCP连接关闭。该报文指出封装的对象是一个HTML文件，客户从响应报文中提取出该文件，检查该HTML文件，得到对10个JPEG图形的<strong>引用</strong>。</li>
<li>对每个引用的JPEG图形对象<strong>重复</strong>前4个步骤。</li>
</ol>
<p>其中每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。每个TCP连接只传输一个请求报文和一个响应报文，因此在本例中要产生11个TCP连接。</p>
<p>其中这10个JPEG图形对象是使用10个串行的TCP连接，还是某些JPEG对象使用了一些并行的TCP连接，这可以由用户通过配置浏览器进行控制。</p>
<p><strong>往返时间</strong>（RTT）是指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p>
<p>当浏览器和Web服务器之间发起一个TCP连接时，会涉及一次”<strong>三次握手</strong>“过程：</p>
<ol>
<li>客户向服务器发送一个小TCP报文段</li>
<li>服务器用一个小TCP报文段做出确认和响应</li>
<li>客户向服务器返回确认</li>
</ol>
<p>三次握手中前两个部分占用了一个RTT。完成前两个部分后，客户结合三次握手的第三部分向该TCP连接发送一个HTTP请求报文，一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。该HTTP请求/响应占用了一个RTT。因此，总的响应时间就是<strong>两个RTT加上服务器传输HTML文件的时间</strong>。<br><a href="/img/cn2.5.png">图为三次握手过程</a></p>
<h3 id="2-2-2-采用持续连接的HTTP"><a href="#2-2-2-采用持续连接的HTTP" class="headerlink" title="2.2.2 采用持续连接的HTTP"></a>2.2.2 采用持续连接的HTTP</h3><p>非持续连接有两个缺点：</p>
<ol>
<li>必须为每一个请求的对象建立和维护一个全新的TCP连接。对于每个连接，客户和服务器都要分配TCP的缓冲区和保持TCP变量。</li>
<li>每一个对象要经受两倍RTT的交付时延。</li>
</ol>
<p> 在采用持续连接时，服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。一般来说，如果一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，HTTP服务器就关闭该连接。</p>
<h2 id="2-3-HTTP报文格式"><a href="#2-3-HTTP报文格式" class="headerlink" title="2.3 HTTP报文格式"></a>2.3 HTTP报文格式</h2><p>HTTP规范包含了对HTTP报文格式的定义。HTTP报文有两种：请求报文和响应报文。</p>
<h3 id="2-3-1-HTTP请求报文"><a href="#2-3-1-HTTP请求报文" class="headerlink" title="2.3.1 HTTP请求报文"></a>2.3.1 HTTP请求报文</h3><blockquote>
<p>下面提供一个<strong>典型</strong>的HTTP请求报文：<br>GET /somedir/page.html HTTP/1.1<br>Host: <a target="_blank" rel="noopener" href="http://www.someschool.edu/">www.someschool.edu</a><br>Connection: close<br>User-agent: Mozilla/5.0<br>Accept-language: fr</p>
</blockquote>
<p>HTTP请求报文的第一行叫做<strong>请求行</strong>（request line），其后继的行叫做<strong>首部行</strong>（header line）。</p>
<p>1 <strong>请求行</strong><br>有3个字段：<strong>方法字段</strong>、<strong>URL字段</strong>和<strong>HTTP版本字段</strong>。方法字段可以取几种不同的值，包括GET、POST、HEAD、PUT和DELETE，绝大部分采用GET方法。</p>
<p>2 <strong>首部行</strong><br><strong>Host: <a target="_blank" rel="noopener" href="http://www.someschool.edu/">www.someschool.edu</a></strong>，指明了对象所在的主机。<br><strong>Connection: close</strong>，浏览器告诉服务器不使用持续连接。<br><strong>User-agent</strong>，用来指明用户代理，即向服务器发送请求的浏览器的类型。<br><strong>Accept-language</strong>，表示用户想得到该对象的法语版本（如果服务器中有），否则发送默认版本。</p>
<p>在首部行后有一个“<strong>实体体</strong>”（entire body）。使用GET方法时实体体为空，在使用<strong>POST方法</strong>时使用。例如当用户在搜索引擎搜索关键词时，实体体包含的就是用户在表单字段的输入值。</p>
<p><a href="/img/cn2.6.png">图为一个HTTP请求报文的通用格式</a></p>
<p>用表单生成的请求报文不是必须使用<strong>POST方法</strong>，HTML表单经常使用GET方法，并在所请求的URL中包括输入的数据。例如<a target="_blank" rel="noopener" href="http://www.somesite.com/animalsearch?monkeys&amp;bananas%E3%80%82">www.somesite.com/animalsearch?monkeys&amp;bananas。</a></p>
<p><strong>HEAD方法</strong>类似于GET方法，当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但不返回对象。应用程序开发者经常使用HEAD方法进行调试跟踪。</p>
<p><strong>PUT方法</strong>常与Web发行工具联合使用，它允许用户上传对象到指定的Web服务器上指定的路径（目录）。同时，它也被那些需要向Web服务器上传对象的应用程序使用。</p>
<p><strong>DELETE方法</strong>允许用户或者应用程序删除Web服务器上的对象。</p>
<h3 id="2-3-2-HTTP响应报文"><a href="#2-3-2-HTTP响应报文" class="headerlink" title="2.3.2 HTTP响应报文"></a>2.3.2 HTTP响应报文</h3><blockquote>
<p>下面提供一条典型的HTTP响应报文，它是对上面请求报文的响应<br>HTTP:/1.1 200 OK<br>Connection: close<br>Data: Tue, 09 Aug 2011 15:44:04 GMT<br>Server: Apache/2.2.3 (CentOS)<br>Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT<br>Content-Length: 6821<br>Content-Type: text/html<br>(空行）<br>(data data data data…)</p>
</blockquote>
<p>1 <strong>状态行</strong>（第1行）<br>状态行有3个字段：<strong>协议版本字段</strong>、<strong>状态码</strong>和<strong>相应状态信息</strong>。这里指示服务器正在使用HTTP/1.1，并且一切正常。</p>
<p>2 <strong>首部行</strong>（2~7行）<br><strong>Connection: close</strong> 告诉客户发送完报文后将关闭该TCP连接；<br><strong>Date</strong> 指示服务器产生并发送该响应报文的日期和时间；<br><strong>Server</strong> 指示该报文是由一台Apache Web服务器产生的，类似于请求报文中的User-agent；<br><strong>Last-Modified</strong> 指示了对象创建或者最后修改的日期和时间，它对对象缓存（既可能在本地客户也可能在网络缓存服务器上）非常重要；<br><strong>Content-Length</strong> 指示了被发送对象中的字节数；<br><strong>Content-Type</strong> 指示了实体体中的对象是HTML文本。</p>
<p>3 <strong>实体体</strong>：报文的主要部分（data data data…）。</p>
<p><a href="/img/cn2.7.png">图为一个HTTP响应报文的通用格式</a></p>
<h2 id="2-4-用户与服务器的交互：cookie"><a href="#2-4-用户与服务器的交互：cookie" class="headerlink" title="2.4 用户与服务器的交互：cookie"></a>2.4 用户与服务器的交互：cookie</h2><p>cookie在[RFC 6265]中定义，它允许站点对用户进行跟踪。</p>
<p>cookie技术有4个组件：</p>
<ol>
<li>在HTTP响应报文中的一个cookie首部行；</li>
<li>在HTTP请求报文中的一个cookie首部行；</li>
<li>在用户端系统中保留有一个cookie文件，由用户的浏览器进行管理；</li>
<li>位于Web站点的一个后端数据库。</li>
</ol>
<p><a href="/img/cn2.8.png">图为cookie跟踪用户状态</a></p>
<p>cookie可以用于<strong>标识</strong>一个用户。用户首次访问一个站点时，可能需要提供一个用户标识。在后继会话中，浏览器向服务器传递一个cookie首部，从而向该服务器标识了用户。因此cookie可以在无状态的HTTP之上建立一个用户<strong>会话层</strong>。</p>
<h2 id="2-5-Web缓存"><a href="#2-5-Web缓存" class="headerlink" title="2.5 Web缓存"></a>2.5 Web缓存</h2><p><strong>Web缓存器</strong>（Web cache）也叫<strong>代理服务器</strong>（proxy server），它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘<strong>存储空间</strong>，并在存储空间中保存最近请求过的对象的<strong>副本</strong>。</p>
<p>假设浏览器正在请求一个对象，将会发生如下情况：</p>
<ol>
<li>浏览器<strong>建立</strong>一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。</li>
<li>Web缓存器进行<strong>检查</strong>，看看本地是否存储了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象。</li>
<li>如果Web缓存器中没有该对象，它就打开一个与该对象的<strong>初始服务器</strong>的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应。</li>
<li>当Web缓存器接收到该对象时，它在本地存储空间存储一份<strong>副本</strong>，并向客户的浏览器用HTTP<strong>响应报文</strong>发送该副本（通过已有的TCP连接）。</li>
</ol>
<p>所以Web缓存器是<strong>服务器</strong>同时又是<strong>客户</strong>。它通常由<strong>ISP</strong>购买并安装。</p>
<p>部署Web缓存器的<strong>原因</strong>：</p>
<ul>
<li>它可以大大减少对客户请求的响应时间。</li>
<li>它能够大大减少一个机构的接入链路到因特网的通信量。</li>
<li>它从整体上大大减低因特网上的Web流量，从而改善了所有应用的性能。</li>
</ul>
<p>通过使用<strong>内容分发网络</strong>（CDN），Web缓存器正在因特网中发挥着越来越重要的作用。CDN公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。</p>
<h2 id="2-6-条件GET方法"><a href="#2-6-条件GET方法" class="headerlink" title="2.6 条件GET方法"></a>2.6 条件GET方法</h2><p>为了解决存放在缓存器中的对象副本可能已经<strong>陈旧</strong>的问题，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。它就是<strong>条件GET方法</strong>。</p>
<p>如果</p>
<ul>
<li>请求报文使用GET方法</li>
<li>请求报文中包含一个”if-Modified-Since:”首部行</li>
</ul>
<p>那么，这个HTTP请求报文就是一个条件GET请求报文。</p>
<h1 id="三、文件传输协议：FTP"><a href="#三、文件传输协议：FTP" class="headerlink" title="三、文件传输协议：FTP"></a>三、文件传输协议：FTP</h1><h2 id="3-1-FTP传输的过程"><a href="#3-1-FTP传输的过程" class="headerlink" title="3.1 FTP传输的过程"></a>3.1 FTP传输的过程</h2><p>在一个典型的FTP会话中，用户坐在一台主机前面，向一台远程主机传输文件。为使用户能访问它的远程账户，用户必须提供一个<strong>用户标识和口令</strong>。用户通过一个<strong>FTP用户代理</strong>与<strong>FTP</strong>交互。</p>
<p>具体步骤如下：</p>
<ol>
<li>用户首先提供远程主机的<strong>主机名</strong>，使本地主机的FTP客户进程建立一个到远程主机FTP服务器进程的<strong>TCP连接</strong>。</li>
<li>用户接着提供<strong>用户标识和口令</strong>，作为FTP命令的一部分在该TCP连接上传送。</li>
<li>一旦该服务器向该用户<strong>授权</strong>，用户可以将存放在本地文件系统中的一个或多个文件复制到远程文件系统（反之亦然）。</li>
</ol>
<h2 id="3-2-HTTP和FTP的对比"><a href="#3-2-HTTP和FTP的对比" class="headerlink" title="3.2 HTTP和FTP的对比"></a>3.2 HTTP和FTP的对比</h2><h3 id="3-2-1-共同点"><a href="#3-2-1-共同点" class="headerlink" title="3.2.1 共同点"></a>3.2.1 共同点</h3><ul>
<li>都是文件传输协议</li>
<li>都运行在TCP上</li>
</ul>
<h3 id="3-2-2-不同点"><a href="#3-2-2-不同点" class="headerlink" title="3.2.2 不同点"></a>3.2.2 不同点</h3><ul>
<li>FTP使用了两个并行的TCP连接来传输文件，一个是<strong>控制连接</strong>（control connection），一个是<strong>数据连接</strong>（data connection）。<strong>控制连接</strong>用于在主机之间传输控制信息，如用户标识、口令、文件命令等。<strong>数据连接</strong>用于实际发送一个文件。我们称FTP是<strong>带外连接</strong>（独立的控制连接）的。HTTP是在传输文件的同一个TCP连接中发送请求和响应首部行的。因此，HTTP是<strong>带内连接</strong>的。</li>
<li>FTP服务器必须在整个会话期间保留用户的<strong>状态</strong>（state）。服务器必须把特定的用户账户与控制连接联系起来，大大限制了FTP同时维持的会话总数。HTTP是<strong>无状态</strong>的，它不必对任何用户状态进行跟踪。</li>
</ul>
<p>对FTP而言，<strong>控制连接</strong>贯穿了整个用户会话期间，但是对会话中的每一次文件传输都需要建立一个新的<strong>数据连接</strong>（即数据连接是非持续的）。</p>
<h2 id="3-3-FTP命令和回答"><a href="#3-3-FTP命令和回答" class="headerlink" title="3.3 FTP命令和回答"></a>3.3 FTP命令和回答</h2><p>详见 RFC959</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/">自顶向下方法</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/23/Cpp2/">
                        <span class="hidden-mobile">C++基础语法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
