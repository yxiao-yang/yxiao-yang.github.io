

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/app.png">
  <link rel="icon" href="/img/app.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="WebServer(5) Buffer类  写在前面-为什么要有缓冲区的设计 TcpConnection 类负责处理一个新连接的事件，包括从客户端读取数据和向客户端写数据。但是在这之前，需要先设计好缓冲区。  非阻塞网络编程中应用层buffer是必须的：非阻塞IO的核心思想是避免阻塞在read()或write()或其他I&#x2F;O系统调用上，这样可以最大限度复用thread-of-control，让一">
<meta property="og:type" content="article">
<meta property="og:title" content="WebServer(5) Buffer类">
<meta property="og:url" content="http://example.com/2023/02/06/WebServer(5)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="WebServer(5) Buffer类  写在前面-为什么要有缓冲区的设计 TcpConnection 类负责处理一个新连接的事件，包括从客户端读取数据和向客户端写数据。但是在这之前，需要先设计好缓冲区。  非阻塞网络编程中应用层buffer是必须的：非阻塞IO的核心思想是避免阻塞在read()或write()或其他I&#x2F;O系统调用上，这样可以最大限度复用thread-of-control，让一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/web-server/5.1.png">
<meta property="og:image" content="http://example.com/img/web-server/5.2.png">
<meta property="og:image" content="http://example.com/img/web-server/5.3.png">
<meta property="og:image" content="http://example.com/img/web-server/5.4.png">
<meta property="og:image" content="http://example.com/img/web-server/5.5.png">
<meta property="og:image" content="http://example.com/img/web-server/5.6.png">
<meta property="og:image" content="http://example.com/img/web-server/5.7.png">
<meta property="article:published_time" content="2023-02-06T05:41:01.202Z">
<meta property="article:modified_time" content="2023-02-08T05:32:25.958Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/web-server/5.1.png">
  
  
  <title>WebServer(5) Buffer类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>羊</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="WebServer(5) Buffer类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-02-06 13:41" pubdate>
        2023年2月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.1k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      68 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">WebServer(5) Buffer类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：3 天前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="webserver5-buffer类"><a class="markdownIt-Anchor" href="#webserver5-buffer类"></a> WebServer(5) Buffer类</h1>
<h2 id="写在前面-为什么要有缓冲区的设计"><a class="markdownIt-Anchor" href="#写在前面-为什么要有缓冲区的设计"></a> 写在前面-为什么要有缓冲区的设计</h2>
<p>TcpConnection 类负责处理一个新连接的事件，包括从客户端读取数据和向客户端写数据。但是在这之前，需要先设计好缓冲区。</p>
<ol>
<li>非阻塞网络编程中应用层buffer是必须的：非阻塞IO的核心思想是避免阻塞在<code>read()</code>或<code>write()</code>或其他<code>I/O</code>系统调用上，这样可以最大限度复用<code>thread-of-control</code>，让一个线程能服务于多个<code>socket</code>连接。<code>I/O</code>线程只能阻塞在<code>IO-multiplexing</code>函数上，如<code>select()/poll()/epoll_wait()</code>。这样一来，应用层的缓冲是必须的，每个<code>TCP socket</code>都要有<code>inputBuffer</code>和<code>outputBuffer</code>。</li>
<li>TcpConnection必须有output buffer：使程序在<code>write()</code>操作上不会产生阻塞，当<code>write()</code>操作后，操作系统一次性没有接受完时，网络库把剩余数据则放入<code>outputBuffer</code>中，然后注册<code>POLLOUT</code>事件，一旦<code>socket</code>变得可写，则立刻调用<code>write()</code>进行写入数据。——应用层<code>buffer</code>到操作系统<code>buffer</code></li>
<li>TcpConnection必须有input buffer：当发送方<code>send</code>数据后，接收方收到数据不一定是整个的数据，网络库在处理<code>socket</code>可读事件的时候，必须一次性把<code>socket</code>里的数据读完，否则会反复触发<code>POLLIN</code>事件，造成<code>busy-loop</code>。所以网路库为了应对数据不完整的情况，收到的数据先放到<code>inputBuffer</code>里。——操作系统<code>buffer</code>到应用层<code>buffer</code>。</li>
</ol>
<h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2>
<h3 id="1-buffer缓冲区设计"><a class="markdownIt-Anchor" href="#1-buffer缓冲区设计"></a> 1 Buffer缓冲区设计</h3>
<p>muduo 的 Buffer 类作为网络通信的缓冲区，像是 TcpConnection 就拥有 inputBuffer 和 outputBuffer 两个缓冲区成员。而缓冲区的设计特点：</p>
<ol>
<li>其内部使用<code>std::vector&lt;char&gt;</code>保存数据，并提供许多访问方法。并且<code>std::vector</code>拥有扩容空间的操作，可以适应数据的不断添加。</li>
<li><code>std::vector&lt;char&gt;</code>内部分为三块，头部预留空间，可读空间，可写空间。内部使用索引标注每个空间的起始位置。每次往里面写入数据，就移动<code>writeIndex</code>；从里面读取数据，就移动<code>readIndex</code>。</li>
</ol>
<h3 id="2-buffer基本成员"><a class="markdownIt-Anchor" href="#2-buffer基本成员"></a> 2 Buffer基本成员</h3>
<p><img src="/img/web-server/5.1.png" srcset="/img/loading.gif" lazyload alt="图为Buffer内部逻辑" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> : <span class="hljs-keyword">public</span> muduo::copyable &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kCheapPrepend = <span class="hljs-number">8</span>; <span class="hljs-comment">// 头部预留8个字节</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kInitialSize = <span class="hljs-number">1024</span>; <span class="hljs-comment">// 缓冲区初始化大小 1KB</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Buffer</span><span class="hljs-params">(<span class="hljs-type">size_t</span> initialSize = kInitialSize)</span></span><br><span class="hljs-function">      : buffer_(kCheapPrepend + initialSize), // buffer分配大小 <span class="hljs-number">8</span> + <span class="hljs-number">1</span>KB</span><br><span class="hljs-function">        readerIndex_(kCheapPrepend), // 可读索引和可写索引最开始位置都在预留字节后</span><br><span class="hljs-function">        writerIndex_(kCheapPrepend) &#123;</span><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">readableBytes</span>() == <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">writableBytes</span>() == initialSize);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">prependableBytes</span>() == kCheapPrepend);<br>  &#125;<br><br>  <span class="hljs-comment">/*......*/</span><br><br>  <span class="hljs-comment">// 可读空间大小</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">readableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> writerIndex_ - readerIndex_; &#125;<br>	<br>  <span class="hljs-comment">// 可写空间大小</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">writableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> buffer_.<span class="hljs-built_in">size</span>() - writerIndex_; &#125;<br>	<br>  <span class="hljs-comment">// 预留空间大小</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">prependableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> readerIndex_; &#125;<br>	<br>  <span class="hljs-comment">// 返回可读空间地址</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">peek</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">begin</span>() + readerIndex_; &#125;<br><br>  <span class="hljs-comment">/*......*/</span><br>	<br> <span class="hljs-keyword">private</span>:<br>  std::vector&lt;<span class="hljs-type">char</span>&gt; buffer_; <span class="hljs-comment">// 缓冲区其实就是vector&lt;char&gt;</span><br>  <span class="hljs-type">size_t</span> readerIndex_; <span class="hljs-comment">// 可读区域开始索引</span><br>  <span class="hljs-type">size_t</span> writerIndex_; <span class="hljs-comment">// 可写区域开始索引</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="3-读写数据时对buffer的操作"><a class="markdownIt-Anchor" href="#3-读写数据时对buffer的操作"></a> 3 读写数据时对Buffer的操作</h3>
<p><img src="/img/web-server/5.2.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<p><img src="/img/web-server/5.3.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<p><img src="/img/web-server/5.4.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<h4 id="31-向buffer写入数据readfd"><a class="markdownIt-Anchor" href="#31-向buffer写入数据readfd"></a> 3.1 向Buffer写入数据：ReadFd()</h4>
<p><code>ssize_t Buffer::ReadFd(int fd, int* savedErrno)</code>：表示从 fd 中读取数据到 buffer_ 中。对于 buffer 来说这是写入数据的操作，会改变<code>writeIndex</code>。</p>
<ol>
<li>考虑到 buffer_ 的 writableBytes 空间大小，不能够一次性读完数据，于是内部还在栈上创建了一个临时缓冲区 <code>char extrabuf[65536];</code>。如果有多余的数据，就将其读入到临时缓冲区中。</li>
<li>因为可能要写入两个缓冲区，所以使用了更加高效<code>readv</code>函数，可以向多个地址写入数据。刚开始会判断需要写入的大小。
<ol>
<li>如果一个缓冲区足够，就不必再往临时缓冲区<code>extrabuf</code>写入数据了。写入后需要更新<code>writeIndex</code>位置，<code>writerIndex_ += n;</code>。</li>
<li>如果一个缓冲区不够，则还需往临时缓冲区<code>extrabuf</code>写入数据。原缓冲区直接写满，<code>writeIndex_ = buffer_.size()</code>。然后往临时缓冲区写入数据，<code>Append(extrabuf, n - writable);</code>。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Buffer::ReadFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span> </span>&#123;<br>  <span class="hljs-comment">// 栈额外空间，用于从套接字往buffer_读时，当buffer_暂时不够用时暂存数据，待buffer_重新分配足够空间后，在把数据交换给buffer_。</span><br>  <span class="hljs-type">char</span> extrabuf[<span class="hljs-number">65536</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 栈上内存空间 65536/1024 = 64KB</span><br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  struct iovec &#123;</span><br><span class="hljs-comment">    ptr_t iov_base; // iov_base指向的缓冲区存放的是readv所接收的数据或是writev将要发送的数据</span><br><span class="hljs-comment">    size_t iov_len; // iov_len在各种情况下分别确定了接收的最大长度以及实际写入的长度</span><br><span class="hljs-comment">  &#125;;</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-comment">// 使用iovec分配两个连续的缓冲区</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> vec[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> writable = <span class="hljs-built_in">WritableBytes</span>(); <span class="hljs-comment">// 这是Buffer底层缓冲区剩余的可写空间大小 不一定能完全存储从fd读出的数据</span><br><br>  <span class="hljs-comment">// 第一块缓冲区，指向可写空间</span><br>  vec[<span class="hljs-number">0</span>].iov_base = <span class="hljs-built_in">Begin</span>() + writerIndex_;<br>  vec[<span class="hljs-number">0</span>].iov_len = writable;<br><br>  <span class="hljs-comment">// 第二块缓冲区，指向栈空间</span><br>  vec[<span class="hljs-number">1</span>].iov_base = extrabuf;<br>  vec[<span class="hljs-number">1</span>].iov_len = <span class="hljs-built_in">sizeof</span>(extrabuf);<br><br>  <span class="hljs-comment">// 这里之所以说最多128k-1字节，是因为若writable为64k-1，那么需要两个缓冲区 第一个64k-1 第二个64k 所以最多128k-1</span><br>  <span class="hljs-comment">// 如果第一个缓冲区&gt;=64k 那就只采用一个缓冲区 而不使用栈空间extrabuf[65536]的内容</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> iovcnt = (writable &lt; <span class="hljs-built_in">sizeof</span>(extrabuf)) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">ssize_t</span> n = ::<span class="hljs-built_in">readv</span>(fd, vec, iovcnt);<br><br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>    *saveErrno = errno;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= writable) &#123;<br>    <span class="hljs-comment">// Buffer的可写缓冲区已经够存储读出来的数据了</span><br>    writerIndex_ += n;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// extrabuf里面也写入了n-writable长度的数据</span><br>    writerIndex_ = buffer_.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">Append</span>(extrabuf, n - writable); <span class="hljs-comment">// 对buffer_扩容 并将extrabuf存储的另一部分数据追加至buffer_</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中的 Append 函数真正向 buffer_ 内部添加数据。调用方将数据的首地址和长度给出，其内部将数据拷贝到指定位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 把[data, data+len]内存上的数据添加到缓冲区中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-comment">// 确保可写空间足够</span><br>  <span class="hljs-built_in">EnsureWritableBytes</span>(len);<br>  <span class="hljs-comment">// 将这段数据拷贝到可写位置之后</span><br>  std::<span class="hljs-built_in">copy</span>(data, data+len, <span class="hljs-built_in">BeginWrite</span>());<br>  writerIndex_ += len;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="32-空间不够怎么办"><a class="markdownIt-Anchor" href="#32-空间不够怎么办"></a> 3.2 空间不够怎么办？</h4>
<p>如果写入空间不够，Buffer 内部会有两个方案来应付</p>
<ol>
<li>将数据往前移动：因为每次读取数据，<code>readIndex</code>索引都会往后移动，从而导致前面预留的空间逐渐增大。我们需要将后面的元素重新移动到前面。</li>
<li>如果第一种方案的空间仍然不够，那么我们就直接对 buffer_ 进行扩容（<code>buffer_.resize(len)</code>）操作。</li>
</ol>
<p><strong>如图所示：现在的写入空间不够，但是前面的预留空间加上现在的写空间是足够的。因此，我们需要将后面的数据拷贝到前面，腾出足够的写入空间。</strong></p>
<p><img src="/img/web-server/5.5.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<p><img src="/img/web-server/5.6.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EnsureWritableBytes</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WritableBytes</span>() &lt; len) &#123;<br>    <span class="hljs-comment">// 扩容函数</span><br>    <span class="hljs-built_in">MakeSpace</span>(len);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 扩容空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MakeSpace</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * kCheapPrepend | reader | writer |</span><br><span class="hljs-comment">   * kCheapPrepend |       len         |</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WritableBytes</span>() + <span class="hljs-built_in">PrependableBytes</span>() &lt; len + kCheapPrepend) &#123;<br>    <span class="hljs-comment">// 整个buffer都不够用</span><br>    buffer_.<span class="hljs-built_in">resize</span>(writerIndex_ + len);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 整个buffer够用，将后面移动到前面继续分配</span><br>    <span class="hljs-type">size_t</span> readable = <span class="hljs-built_in">ReadableBytes</span>();<br>    std::<span class="hljs-built_in">copy</span>(<span class="hljs-built_in">Begin</span>() + readerIndex_,<br>            <span class="hljs-built_in">Begin</span>() + writerIndex_,<br>            <span class="hljs-built_in">Begin</span>() + kCheapPrepend);<br>    readerIndex_ = kCheapPrepend;<br>    writerIndex_ = readerIndex_ + readable;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="33-从buffer中读取数据"><a class="markdownIt-Anchor" href="#33-从buffer中读取数据"></a> 3.3 从Buffer中读取数据</h4>
<p>就如回声服务器的例子一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 可读写事件回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp time)</span> </span>&#123;<br>  std::string msg = buf-&gt;<span class="hljs-built_in">RetrieveAllAsString</span>();<br>  LOG_INFO &lt;&lt; conn-&gt;<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; echo &quot;</span> &lt;&lt; msg.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; bytes, &quot;</span><br>           &lt;&lt; <span class="hljs-string">&quot;data received at &quot;</span> &lt;&lt; time.<span class="hljs-built_in">toFormattedString</span>();<br>  conn-&gt;<span class="hljs-built_in">send</span>(msg);<br>  <span class="hljs-comment">// conn-&gt;shutdown();   // 关闭写端 底层响应EPOLLHUP =&gt; 执行closeCallback_</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>读取数据会调用<code>void Retrieve(size_t len)</code>函数，在这之前会判断读取长度是否大于可读取空间</p>
<ol>
<li>如果小于，则直接后移<code>readIndex</code>即可，<code>readerIndex_ += len;</code>。</li>
<li>如果大于等于，说明全部数据都读取出来。此时会将buffer置为初始状态：
<ol>
<li><code>readerIndex_ = kCheapPrepend;</code></li>
<li><code>writerIndex_ = kCheapPrepend;</code></li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将onMessage函数上报的Buffer数据，转成string类型的数据返回</span><br><span class="hljs-function">std::string <span class="hljs-title">RetrieveAllAsString</span><span class="hljs-params">()</span> </span>&#123;   <br>  <span class="hljs-comment">// 应用可读取数据的长度</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">RetrieveAsString</span>(<span class="hljs-built_in">ReadableBytes</span>());<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">RetrieveAsString</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-comment">// peek()可读数据的起始地址</span><br>  <span class="hljs-function">std::string <span class="hljs-title">result</span><span class="hljs-params">(Peek(), len)</span></span>;<br>  <span class="hljs-comment">// 上面一句把缓冲区中可读取的数据读取出来，所以要将缓冲区复位</span><br>  <span class="hljs-built_in">Retrieve</span>(len); <br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// onMessage string &lt;- Buffer</span><br><span class="hljs-comment">// 需要进行复位操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Retrieve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>  <span class="hljs-comment">// 应用只读取可读缓冲区数据的一部分(读取了len的长度)</span><br>  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-built_in">ReadableBytes</span>()) &#123;<br>    <span class="hljs-comment">// 移动可读缓冲区指针</span><br>    readerIndex_ += len;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 全部读完 len == readableBytes()</span><br>    <span class="hljs-built_in">RetrieveAll</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 全部读完，则直接将可读缓冲区指针移动到写缓冲区指针那</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RetrieveAll</span><span class="hljs-params">()</span> </span>&#123;<br>  readerIndex_ = kCheapPrepend;<br>  writerIndex_ = kCheapPrepend;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-tcpconnection使用buffer"><a class="markdownIt-Anchor" href="#4-tcpconnection使用buffer"></a> 4 TcpConnection使用Buffer</h3>
<p>TcpConnection 拥有 inputBuffer 和 outputBuffer 两个缓冲区成员。</p>
<ol>
<li>当服务端接收客户端数据，EventLoop 返回活跃的 Channel，并调用对应的读事件处理函数，即 TcpConnection 调用 handleRead 方法从相应的 fd 中读取数据到 inputBuffer 中。在 Buffer 内部 inputBuffer 中的 writeIndex 向后移动。</li>
<li>当服务端向客户端发送数据，TcpConnection 调用 handleWrite 方法将 outputBuffer 的数据写入到 TCP 发送缓冲区。outputBuffer 内部调用 <code>Retrieve</code> 方法移动 readIndex 索引。</li>
</ol>
<p><img src="/img/web-server/5.7.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<h4 id="41-tcpconnection接收客户端数据从客户端sock读取数据到inputbuffer"><a class="markdownIt-Anchor" href="#41-tcpconnection接收客户端数据从客户端sock读取数据到inputbuffer"></a> 4.1 TcpConnection接收客户端数据（从客户端sock读取数据到inputBuffer）</h4>
<p>调用<code>inputBuffer_.ReadFd(channel_-&gt;fd(), &amp;savedErrno);</code>将对端<code>fd</code>数据读取到<code>inputBuffer</code>中。</p>
<ol>
<li>如果读取成功，调用「可读事件发生回调函数」</li>
<li>如果读取数据长度为<code>0</code>，说明对端关闭连接。调用<code>HandleCose()</code></li>
<li>出错，则保存<code>errno</code>，调用<code>HandleError()</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::HandleRead</span><span class="hljs-params">(Timestamp receiveTime)</span> </span>&#123;<br>  <span class="hljs-type">int</span> savedErrno = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// TcpConnection会从socket读取数据，然后写入inpuBuffer</span><br>  <span class="hljs-type">ssize_t</span> n = inputBuffer_.<span class="hljs-built_in">ReadFd</span>(channel_-&gt;<span class="hljs-built_in">fd</span>(), &amp;savedErrno);<br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 已建立连接的用户，有可读事件发生，调用用户传入的回调操作</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>shared_from_this</span><br>    <span class="hljs-built_in">messageCallback_</span>(<span class="hljs-built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 没有数据，说明客户端关闭连接</span><br>    <span class="hljs-built_in">HandleClose</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 出错情况</span><br>    errno = savedErrno;<br>    LOG_ERROR &lt;&lt; <span class="hljs-string">&quot;TcpConnection::handleRead() failed&quot;</span>;<br>    <span class="hljs-built_in">HandleError</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="42-tcpconnection向客户端发送数据将ouputbuffer数据输出到socket中"><a class="markdownIt-Anchor" href="#42-tcpconnection向客户端发送数据将ouputbuffer数据输出到socket中"></a> 4.2 TcpConnection向客户端发送数据（将ouputBuffer数据输出到socket中）</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 此行代码的用意何在</span><br><span class="hljs-keyword">if</span> (channel_-&gt;<span class="hljs-built_in">IsWriting</span>())<br></code></pre></td></tr></table></figure>
<ol>
<li>要在<code>channel_</code>确实关注写事件的前提下正常发送数据：因为一般有一个<code>send</code>函数发送数据，如果TCP接收缓冲区不够接收ouputBuffer的数据，就需要多次写入。需要重新注册写事件，因此是在注册了写事件的情况下调用的<code>HandleWrite</code>。</li>
<li>向<code>channel-&gt;fd()</code>发送outputBuffer中的可读取数据。成功发送数据则移动<code>readIndex</code>，并且如果一次性成功写完数据，就不再让此<code>channel</code>关注写事件了，并调用写事件完成回调函数没写完则继续关注！</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::HandleWrite</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (channel_-&gt;<span class="hljs-built_in">IsWriting</span>()) &#123;<br>    <span class="hljs-type">int</span> saveErrno = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">ssize_t</span> n = outputBuffer_.<span class="hljs-built_in">WriteFd</span>(channel_-&gt;<span class="hljs-built_in">fd</span>(), &amp;saveErrno);<br>    <span class="hljs-comment">// 正确读取数据</span><br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>      outputBuffer_.<span class="hljs-built_in">Retrieve</span>(n);<br>      <span class="hljs-comment">// 说明buffer可读数据都被TcpConnection读取完毕并写入给了客户端</span><br>      <span class="hljs-comment">// 此时就可以关闭连接，否则还需继续提醒写事件</span><br>      <span class="hljs-keyword">if</span> (outputBuffer_.<span class="hljs-built_in">ReadableBytes</span>() == <span class="hljs-number">0</span>) &#123;<br>        channel_-&gt;<span class="hljs-built_in">DisableWriting</span>();<br>        <span class="hljs-comment">// 调用用户自定义的写完数据处理函数</span><br>        <span class="hljs-keyword">if</span> (writeCompleteCallback_) &#123;<br>          <span class="hljs-comment">// 唤醒loop_对应的thread线程，执行写完成事件回调</span><br>          loop_-&gt;<span class="hljs-built_in">QueueInLoop</span>(std::<span class="hljs-built_in">bind</span>(writeCompleteCallback_, <span class="hljs-built_in">shared_from_this</span>()));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (state_ == kDisconnecting) &#123;<br>          <span class="hljs-built_in">ShutdownInLoop</span>();<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      LOG_ERROR &lt;&lt; <span class="hljs-string">&quot;TcpConnection::handleWrite() failed&quot;</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// state_不为写状态</span><br>    LOG_ERROR &lt;&lt; <span class="hljs-string">&quot;TcpConnection fd=&quot;</span> &lt;&lt; channel_-&gt;<span class="hljs-built_in">fd</span>() &lt;&lt; <span class="hljs-string">&quot; is down, no more writing&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">项目实战</a>
                    
                      <a class="hover-with-bg" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%93%E9%80%A0WebServer/">从零开始打造WebServer</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/08/WebServer(6)/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">WebServer(6) 定时器模块</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/31/WebServer(4)/">
                        <span class="hidden-mobile">WebServer(4) EventLoop类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
