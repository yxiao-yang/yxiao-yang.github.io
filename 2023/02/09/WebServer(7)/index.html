

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/app.png">
  <link rel="icon" href="/img/app.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="WebServer(7) 异步日志模块  写在前面  1 为什么要实现非阻塞的日志  如果是同步日志，那么每次产生日志信息时，就需要将这条日志信息完全写入磁盘后才会执行后续程序。而磁盘 IO 是比较耗时的操作，如果有大批量的日志信息需要写入就会阻塞网络库的工作。 如果是异步日志，那么写日志消息只需要将日志的信息先进行存储，当累计到一定量或者经过一定时间时再将这些日志信息批量写入磁盘。而这个写入过">
<meta property="og:type" content="article">
<meta property="og:title" content="WebServer(7) 异步日志模块">
<meta property="og:url" content="http://example.com/2023/02/09/WebServer(7)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="WebServer(7) 异步日志模块  写在前面  1 为什么要实现非阻塞的日志  如果是同步日志，那么每次产生日志信息时，就需要将这条日志信息完全写入磁盘后才会执行后续程序。而磁盘 IO 是比较耗时的操作，如果有大批量的日志信息需要写入就会阻塞网络库的工作。 如果是异步日志，那么写日志消息只需要将日志的信息先进行存储，当累计到一定量或者经过一定时间时再将这些日志信息批量写入磁盘。而这个写入过">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-09T06:48:18.245Z">
<meta property="article:modified_time" content="2023-02-09T12:44:42.716Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>WebServer(7) 异步日志模块 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>羊</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="WebServer(7) 异步日志模块">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-02-09 14:48" pubdate>
        2023年2月9日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      14k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      116 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">WebServer(7) 异步日志模块</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：40 分钟前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="webserver7-异步日志模块"><a class="markdownIt-Anchor" href="#webserver7-异步日志模块"></a> WebServer(7) 异步日志模块</h1>
<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1>
<h2 id="1-为什么要实现非阻塞的日志"><a class="markdownIt-Anchor" href="#1-为什么要实现非阻塞的日志"></a> 1 为什么要实现非阻塞的日志</h2>
<ol>
<li>如果是同步日志，那么每次产生日志信息时，就需要将这条日志信息完全写入磁盘后才会执行后续程序。而磁盘 IO 是比较耗时的操作，如果有大批量的日志信息需要写入就会阻塞网络库的工作。</li>
<li>如果是异步日志，那么写日志消息只需要将日志的信息先进行存储，当累计到一定量或者经过一定时间时再将这些日志信息批量写入磁盘。而这个写入过程靠后台线程去执行，不会影响处理事件的其他线程。</li>
</ol>
<p>经过对比可以得到，异步日志的方式对性能更加友好，而且可以减少磁盘 IO 函数的操作，一次写入更多的数据，提高效率。</p>
<h2 id="2-muduo日志库的设计"><a class="markdownIt-Anchor" href="#2-muduo日志库的设计"></a> 2 muduo日志库的设计</h2>
<p>muduo 日志消息的组成：时间戳、线程ID、日志级别、日志正文、源文件名、行号（下面的例子省略了线程 TID）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">2022/11/30 00:57:016530 INFO  EventLoop start looping - EventLoop.cc:70<br></code></pre></td></tr></table></figure>
<p>muduo 日志库由前端和后端组成。</p>
<ol>
<li>前端主要包括：Logger、LogStream、FixedBuffer、SourceFile。</li>
<li>后端主要包括：AsyncLogging、LogFile、AppendFile。</li>
</ol>
<h1 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h1>
<h2 id="1-logger类"><a class="markdownIt-Anchor" href="#1-logger类"></a> 1 Logger类</h2>
<p>Logger  类为用户提供使用日志库的接口，其内部有一个 Impl（实现类）具体实现功能。Logger 内部定义了日志的等级。muduo 的默认日志等级是 INFO。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">LogLevel</span> &#123;<br>  TRACE,<br>  DEBUG,<br>  INFO,<br>  WARN,<br>  ERROR,<br>  FATAL,<br>  NUM_LOG_LEVELS<br>&#125;;<br></code></pre></td></tr></table></figure>
<ol>
<li>TRACE：指出比 DEBUG 粒度更细的一些信息事件（开发过程中使用）。</li>
<li>DEBUG：指出细粒度信息事件对调试应用程序是非常有帮助的（开发过程中使用）。</li>
<li>INFO：表明消息在粗粒度级别上突出强调应用程序的运行过程。</li>
<li>WARN：系统能正常运行，但可能会出现潜在错误的情形。</li>
<li>ERROR：指出虽然发生错误事件，但仍然不影响系统的继续运行。</li>
<li>FATAL：指出每个严重的错误事件将会导致应用程序的退出。</li>
</ol>
<p><strong>调用日志库</strong><br />
针对不同的日志等级，本项目设置了一系列宏函数来调用。 其内部可以判断当前设置的日志等级来拦截日志输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_DEBUG <span class="hljs-keyword">if</span> (logLevel() &lt;= Logger::DEBUG) \</span><br><span class="hljs-meta">  Logger(__FILE__, __LINE__, Logger::DEBUG, __func__).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_INFO <span class="hljs-keyword">if</span> (logLevel() &lt;= Logger::INFO) \</span><br><span class="hljs-meta">  Logger(__FILE__, __LINE__).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_WARN Logger(__FILE__, __LINE__, Logger::WARN).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_ERROR Logger(__FILE__, __LINE__, Logger::ERROR).stream()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_FATAL Logger(__FILE__, __LINE__, Logger::FATAL).stream()</span><br></code></pre></td></tr></table></figure>
<p>观察宏函数，会发现每个宏定义都会构造出一个 Logger 的临时对象，然后输出相关信息。在 Logger::Impl 的构造函数中会初始化时间戳、线程ID、日志等级这类固定信息，而正文消息靠 LogStream 重载实现。在 Logger 临时对象销毁时，会调用 Logger 的析构函数，其内部会将日志信息输出到指定位置。<br />
而 Logger 的实现文件中定义了两个全局函数指针，其执行的函数会确定日志信息的输出位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 输出函数和刷新缓冲区函数</span><br><span class="hljs-keyword">using</span> OutputFunc = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> len)&gt;;<br><span class="hljs-keyword">using</span> FlushFunc = std::function&lt;<span class="hljs-built_in">void</span>()&gt;;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Logger::OutputFunc g_output = DefaultOutput; <span class="hljs-comment">// 默认输出到终端上</span><br>Logger::FlushFunc g_flush = DefaultFlush;    <span class="hljs-comment">// 默认刷新标准输出流</span><br></code></pre></td></tr></table></figure>
<p>以下是 DefaultOutput 和 DefaultFlush 的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DefaultOutput</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>  <span class="hljs-built_in">fwrite</span>(data, len, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), stdout);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DefaultFlush</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">fflush</span>(stdout);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>相应的，如果我们将该函数实现为输出到某个磁盘文件上，那么就可以实现后端日志写入磁盘，这也是 muduo 日志接口部分的巧妙设计。我们仿照 muduo 定义了 SetOutput 和 SetFlush 两个函数来设置全局函数指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Logger::SetOutput</span><span class="hljs-params">(OutputFunc out)</span> </span>&#123;<br>  g_output = out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Logger::SetFlush</span><span class="hljs-params">(FlushFunc flush)</span> </span>&#123;<br>  g_flush = flush;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-fixedbuffer类"><a class="markdownIt-Anchor" href="#2-fixedbuffer类"></a> 2 FixedBuffer类</h3>
<p>之前谈到了实现异步日志需要先将前端消息储存起来，然后到达一定数量或者一定时间再将这些信息写入磁盘。而 muduo 使用 FixedBuffer 类来实现这个存放日志信息的缓冲区。FixedBuffer 的实现在 LogStream.h 文件中。<br />
针对不同的缓冲区，muduo 设置了两个固定容量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kSmallBuffer = <span class="hljs-number">4000</span>; 		<span class="hljs-comment">// 4KB</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kLargeBuffer = <span class="hljs-number">4000</span>*<span class="hljs-number">1000</span>; <span class="hljs-comment">// 4MB</span><br></code></pre></td></tr></table></figure>
<p>LogStream 类用于重载正文信息，一次信息大小是有限的，其使用的缓冲区的大小就是 kSmallBuffer。而后端日志 AsyncLogging 需要存储大量日志信息，其会使用的缓冲区大小更大，所以是 kLargeBuffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> SIZE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedBuffer</span> : noncopyable<br>&#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">FixedBuffer</span>()<br>    : <span class="hljs-built_in">cur_</span>(data_)<br>  &#123;<br>    <span class="hljs-built_in">setCookie</span>(cookieStart);<br>  &#125;<br><br>  ~<span class="hljs-built_in">FixedBuffer</span>()<br>  &#123;<br>    <span class="hljs-built_in">setCookie</span>(cookieEnd);<br>  &#125;<br><br>  <span class="hljs-comment">// 向缓冲区添加数据</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-comment">/*restrict*/</span> buf, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> append partially</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">implicit_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-built_in">avail</span>()) &gt; len)<br>    &#123;<br>	  <span class="hljs-comment">// 将buf地址，长为len的数据拷贝到cur_地址处</span><br>      <span class="hljs-built_in">memcpy</span>(cur_, buf, len);<br>      cur_ += len;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(cur_ - data_); &#125;<br><br>  <span class="hljs-comment">// write to data_ directly</span><br>  <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">current</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> cur_; &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">avail</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">end</span>() - cur_); &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span> </span>&#123; cur_ += len; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; cur_ = data_; &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bzero</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memZero</span>(data_, <span class="hljs-keyword">sizeof</span> data_); &#125;<br><br>  <span class="hljs-comment">// for used by GDB</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">debugString</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCookie</span><span class="hljs-params">(<span class="hljs-type">void</span> (*cookie)())</span> </span>&#123; cookie_ = cookie; &#125;<br>  <span class="hljs-comment">// for used by unit test</span><br>  <span class="hljs-function">string <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(data_, <span class="hljs-built_in">length</span>()); &#125;<br>  <span class="hljs-function">StringPiece <span class="hljs-title">toStringPiece</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">StringPiece</span>(data_, <span class="hljs-built_in">length</span>()); &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_ + <span class="hljs-keyword">sizeof</span> data_; &#125;<br>  <span class="hljs-comment">// Must be outline function for cookies.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">cookieStart</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">cookieEnd</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-built_in">void</span> (*cookie_)();<br>  <span class="hljs-type">char</span> data_[SIZE];<br>  <span class="hljs-type">char</span>* cur_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="logstream"><a class="markdownIt-Anchor" href="#logstream"></a> LogStream</h1>
<p>LogStream 重载了一系列 operator&lt;&lt; 操作符，将不同格式数据转化为字符串，并存入 LogStream::buffer_。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    <span class="hljs-keyword">typedef</span> LogStream self;<br><span class="hljs-keyword">public</span>:<br>        ...<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">bool</span> v)<br><br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">short</span>);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">int</span>);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">long</span>);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">long</span> <span class="hljs-type">long</span>);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">float</span> v);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">double</span>);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">char</span> v);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* str);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> string&amp; v);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> StringPiece&amp; v);<br>    self&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> Buffer&amp; v);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="asynclogging"><a class="markdownIt-Anchor" href="#asynclogging"></a> AsyncLogging</h1>
<p>现在开始讲解 muduo 日志库的后端设计了。前端主要实现异步日志中的日志功能，为用户提供将日志内容转换为字符串，封装为一条完整的 log 消息存放到 FixedBuffer 中；而实现异步，核心是通过专门的后端线程，与前端线程并发运行，将 FixedBuffer 中的大量日志消息写到磁盘上。</p>
<ol>
<li>AsyncLogging 提供后端线程，定时将 log 缓冲写到磁盘，维护缓冲及缓冲队列。</li>
<li>LogFile 提供日志文件滚动功能，写文件功能。</li>
<li>AppendFile 封装了OS 提供的基础的写文件功能。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncLogging</span> : noncopyable<br>&#123;<br> <span class="hljs-keyword">public</span>:<br><br>  AsyncLogging;<br>  ~<span class="hljs-built_in">AsyncLogging</span>();<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* logline, <span class="hljs-type">int</span> len)</span></span>; <span class="hljs-comment">// 前端调用此函数加入日志信息</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// FixedBuffer缓冲区类型，而这个缓冲区大小由kLargeBuffer指定，大小为4M，因此，Buffer就是大小为4M的缓冲区类型。</span><br>  <span class="hljs-keyword">typedef</span> muduo::detail::FixedBuffer&lt;muduo::detail::kLargeBuffer&gt; Buffer;<br>  <span class="hljs-keyword">typedef</span> std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector;<br>  <span class="hljs-keyword">typedef</span> BufferVector::value_type BufferPtr;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> flushInterval_;   <span class="hljs-comment">//前端缓冲区定期向后端写入的时间（冲刷间隔）</span><br>  std::atomic&lt;<span class="hljs-type">bool</span>&gt; running_; <span class="hljs-comment">//标识线程函数是否正在运行</span><br>  <span class="hljs-type">const</span> string basename_;<br>  <span class="hljs-type">const</span> <span class="hljs-type">off_t</span> rollSize_;<br>  muduo::Thread thread_;<br>  muduo::CountDownLatch latch_; <span class="hljs-comment">// 条件变量，用于等待异步日志线程启动</span><br>  muduo::MutexLock mutex_;<br>  <span class="hljs-function">muduo::Condition cond_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;    <span class="hljs-comment">//条件变量，主要用于前端缓冲区队列中没有数据时的休眠和唤醒</span><br>  <span class="hljs-function">BufferPtr currentBuffer_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;  <span class="hljs-comment">//当前缓冲区4M大小</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 预备缓冲区，主要是在调用append向当前缓冲添加日志消息时，</span><br><span class="hljs-comment">   * 如果当前缓冲放不下，当前缓冲就会被移动到前端缓冲队列终端，</span><br><span class="hljs-comment">   * 此时预备缓冲区用来作为新的当前缓冲</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function">BufferPtr nextBuffer_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;     <br>  <span class="hljs-function">BufferVector buffers_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mutex_)</span></span>;     <span class="hljs-comment">//前端缓冲区队列</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ol>
<li>BufferPtr currentBuffer_：当前使用的缓冲区，用于储存前端日志信息，如果不够则会使用预备缓冲区。</li>
<li>BufferPtr nextBuffer_：预备缓冲区，用于储存前端日志信息，在第一个缓冲区不够时使用</li>
<li>BufferVector buffers_：缓冲区数组，用于储存前端日志信息，过一段时间或者缓冲区已满，就会将 Buffer 加入到 BufferVector 中。后端线程负责将 BufferVector 里的内容写入磁盘。</li>
</ol>
<p><strong>AsyncLogging::append</strong><br />
之前说过 FixedBuffer 有不同的大小，而 4MB 的就被 AsyncLogging 所用。前端在生成一条日志消息的时候会调用 AsyncLogging::append，将日志信息加入到 AsyncLogging::Buffer 中。而前端会有不同的线程调用日志库，因此 append 操作需要加锁保证互斥。<br />
muduo 采用双缓冲区实现异步日志，它设置了两个 <code>FixedBuffer&lt;kLargeBuffer&gt; Buffer</code> 来储存前端的日志信息。如果当前的缓冲区不够放下日志信息，它就会将此缓冲区加入到 Buffer 数组中（为后端使用）。然后将预备缓冲区 nextBuffer 作为新的缓冲区使用。<br />
如果后 nextBuffer 也不够使用了，那么就会新分配一个缓冲区记录日志信息，不过这种情况极少发生。如果日志写的速度很快，但是 IO 函数速度很慢，那么前端日志缓冲区就会积累，就会产生这种情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AsyncLogging::append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* logline, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">muduo::MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>; <span class="hljs-comment">//用锁来保持同步</span><br>  <span class="hljs-keyword">if</span> (currentBuffer_-&gt;<span class="hljs-built_in">avail</span>() &gt; len)  <span class="hljs-comment">//如果当前缓冲区还能放下当前日志消息</span><br>  &#123;<br>    currentBuffer_-&gt;<span class="hljs-built_in">append</span>(logline, len); <span class="hljs-comment">//就把日志消息添加到当前缓冲区中</span><br>  &#125;<br>  <span class="hljs-comment">// 如果放不下，就把当前缓冲区移动到前端缓冲区队列中，然后用预备缓冲区来填充当前缓冲区</span><br>  <span class="hljs-comment">// 将当前缓冲区放到前端缓冲区队列中后就要唤醒后端处理线程</span><br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-comment">// 当前缓冲区直接进入buffer数组了，之后不使用它，于是可以使用移动函数</span><br>    buffers_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(currentBuffer_));<br><br>    <span class="hljs-comment">//如果预备缓冲区还未使用，就用来填充当前缓冲区</span><br>    <span class="hljs-keyword">if</span> (nextBuffer_)<br>    &#123;<br>      currentBuffer_ = std::<span class="hljs-built_in">move</span>(nextBuffer_);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果预备缓冲区无法使用，就重新分配一个新的缓冲区</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      currentBuffer_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Buffer); <span class="hljs-comment">// Rarely happens</span><br>    &#125;<br>    <span class="hljs-comment">// 向新的当前缓冲区中写入日志消息</span><br>    currentBuffer_-&gt;<span class="hljs-built_in">append</span>(logline, len);<br>    cond_.<span class="hljs-built_in">notify</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>后端线程会如何处理前端数组</strong><br />
后端线程负责将 BufferVector 里的每个 Buffer 数据写到磁盘上。后端线程会生成一个 Buffer 数组 buffersToWrite，用于和前端 Buffer 数组进行交换。其每隔一段时间 flushInterval_ 就会将前端数组的内容交换到后端数组中（使用 swap）函数。这样可以快速归还前端数组，这样新的写满的 Buffer 就可以继续加入到前端数组中。<br />
除此之外，后端线程还会先预备两个 Buffer，用于跟前端的 currentBuffer 和 nextBuffer 进行交换。因为为了避免等待过久，currentBuffer 还没有被填满，后端线程会定时的打断这个过程。如果到达触发时间了，当前的 Buffer 还没有写完，那么仍然会将其加入到前端的 Buffer 数组中。因此，需要将 currentBuffer 与空的 Buffer 进行交换操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AsyncLogging::threadFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">assert</span>(running_ == <span class="hljs-literal">true</span>);<br>  latch_.<span class="hljs-built_in">countDown</span>();<br>  <span class="hljs-function">LogFile <span class="hljs-title">output</span><span class="hljs-params">(basename_, rollSize_, <span class="hljs-literal">false</span>)</span></span>;<br>  <span class="hljs-comment">// 分配缓冲区并置空</span><br>  <span class="hljs-function">BufferPtr <span class="hljs-title">newBuffer1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Buffer)</span></span>;<br>  <span class="hljs-function">BufferPtr <span class="hljs-title">newBuffer2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Buffer)</span></span>;<br>  newBuffer1-&gt;<span class="hljs-built_in">bzero</span>();<br>  newBuffer2-&gt;<span class="hljs-built_in">bzero</span>();<br>  <span class="hljs-comment">// 缓冲区数组置为16个</span><br>  BufferVector buffersToWrite;<br>  buffersToWrite.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">16</span>);<br>  <span class="hljs-keyword">while</span> (running_)<br>  &#123;<br>    &#123;<br>      <span class="hljs-comment">// 互斥锁保护</span><br>      <span class="hljs-function">muduo::MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>      <span class="hljs-comment">// unusual usage!  </span><br>      <span class="hljs-comment">// 如果前端缓冲区队列为空，就休眠 flushInterval_ 的时间</span><br>      <span class="hljs-comment">// 说明没有一个数组被写满</span><br>      <span class="hljs-keyword">if</span> (buffers_.<span class="hljs-built_in">empty</span>())  <span class="hljs-comment">// unusual usage!</span><br>      &#123;<br>        cond_.<span class="hljs-built_in">waitForSeconds</span>(flushInterval_);<br>      &#125;<br>      <span class="hljs-comment">// 将当前写满的buffer加入buffer数组</span><br>      buffers_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(currentBuffer_));<br>      currentBuffer_ = std::<span class="hljs-built_in">move</span>(newBuffer1);<br>      <span class="hljs-comment">// 前端缓冲区队列与后端缓冲区队列交换</span><br>      <span class="hljs-comment">// 使用交换的方式，更加高效</span><br>      buffersToWrite.<span class="hljs-built_in">swap</span>(buffers_);<br>      <span class="hljs-comment">// 如果预备缓冲区为空，那么就使用newBuffer2作为预备缓冲区，保证始终有一个空闲的缓冲区用于预备</span><br>      <span class="hljs-keyword">if</span> (!nextBuffer_)<br>      &#123;<br>        nextBuffer_ = std::<span class="hljs-built_in">move</span>(newBuffer2);<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><strong>后端线程如何处理 buffersToWrite</strong><br />
首先会先判断交换得到的 buffersToWrite 数组的大小，如果其超过了 25 个，那么我们只会保留前两个 Buffer。一个 Buffer 是 4MB，25 个说明前端已经堆积了 100 MB 大小的日志信息。<br />
假设磁盘的写速度 100MB/S，要堆积 100MB 有 2 种极端情况：</p>
<ol>
<li>1S内产生200MB数据；</li>
<li>25秒内，平均每秒产生104MB数据；</li>
</ol>
<p>不论哪种情况，都是要超过磁盘的处理速度。而实际应用中，只有产生数据速度不到磁盘写速度的 1/10，应用程序性能才不会受到明显影响。<br />
紧接着，后端线程会遍历各个 Buffer，然后调用 output 将数据输出到指定位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LogFile <span class="hljs-title">output</span><span class="hljs-params">(basename_, rollSize_, <span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; buffer : buffersToWrite)<br>&#123;<br>  <span class="hljs-comment">// 写入日志文件</span><br>  output.<span class="hljs-built_in">append</span>(buffer-&gt;<span class="hljs-built_in">data</span>(), buffer-&gt;<span class="hljs-built_in">length</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>写入完成后，将 buffersToWrite 的大小 resize 成两个，并归还 nextBuffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AsyncLogging::threadFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果最终后端缓冲区的缓冲区太多就只保留前两个</span><br>    <span class="hljs-keyword">if</span> (buffersToWrite.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">25</span>)<br>    &#123;<br>      <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>];<br>      <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span> buf, <span class="hljs-string">&quot;Dropped log messages at %s, %zd larger buffers\n&quot;</span>,<br>               Timestamp::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">toFormattedString</span>().<span class="hljs-built_in">c_str</span>(),<br>               buffersToWrite.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>);<br>      <span class="hljs-built_in">fputs</span>(buf, stderr);<br>      output.<span class="hljs-built_in">append</span>(buf, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">strlen</span>(buf)));<br>      <span class="hljs-comment">// 只保留两个</span><br>      buffersToWrite.<span class="hljs-built_in">erase</span>(buffersToWrite.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>, buffersToWrite.<span class="hljs-built_in">end</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历将要输出到磁盘上的缓冲区</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; buffer : buffersToWrite)<br>    &#123;<br>      <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> use unbuffered stdio FILE ? or use ::writev ?</span><br>      <span class="hljs-comment">// 写入日志文件</span><br>      output.<span class="hljs-built_in">append</span>(buffer-&gt;<span class="hljs-built_in">data</span>(), buffer-&gt;<span class="hljs-built_in">length</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 大于两个后端缓冲区，则置为空格</span><br>    <span class="hljs-keyword">if</span> (buffersToWrite.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>)<br>    &#123;<br>      <span class="hljs-comment">// drop non-bzero-ed buffers, avoid trashing</span><br>      buffersToWrite.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 newBuffer1 为空 （刚才用来替代当前缓冲了)</span><br>    <span class="hljs-keyword">if</span> (!newBuffer1)<br>    &#123;<br>      <span class="hljs-built_in">assert</span>(!buffersToWrite.<span class="hljs-built_in">empty</span>());<br>      <span class="hljs-comment">// 把后端缓冲区的最后一个作为newBuffer1</span><br>      newBuffer1 = std::<span class="hljs-built_in">move</span>(buffersToWrite.<span class="hljs-built_in">back</span>()); <br>      <span class="hljs-comment">// 最后一个元素的拥有权已经转移到了newBuffer1中，因此弹出最后一个</span><br>      buffersToWrite.<span class="hljs-built_in">pop_back</span>();<br>      <span class="hljs-comment">// 重置newBuffer1为空闲状态（注意，这里调用的是Buffer类的reset函数而不是unique_ptr的reset函数） </span><br>      newBuffer1-&gt;<span class="hljs-built_in">reset</span>(); <br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!newBuffer2)<br>    &#123;<br>      <span class="hljs-built_in">assert</span>(!buffersToWrite.<span class="hljs-built_in">empty</span>());<br>      newBuffer2 = std::<span class="hljs-built_in">move</span>(buffersToWrite.<span class="hljs-built_in">back</span>());<br>      buffersToWrite.<span class="hljs-built_in">pop_back</span>();<br>      newBuffer2-&gt;<span class="hljs-built_in">reset</span>();<br>    &#125;<br><br>    buffersToWrite.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 清空后端缓冲区队列</span><br>    output.<span class="hljs-built_in">flush</span>(); <span class="hljs-comment">//清空文件缓冲区</span><br>  &#125;<br>  output.<span class="hljs-built_in">flush</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="logfile"><a class="markdownIt-Anchor" href="#logfile"></a> LogFile</h1>
<p>LogFile 主要职责：提供对日志文件的操作，包括滚动日志文件、将 log 数据写到当前 log 文件、flush log数据到当前 log 文件。<br />
<strong>写日志文件操作</strong><br />
LogFile提供了2个接口，用于向当前日志文件file_写入数据。append本质上是通过append_unlocked完成对日志文件写操作，但多了线程安全。用户只需调用第一个接口即可，append会根据线程安全需求，自行判断是否需要加上；第二个是private接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *logline, <span class="hljs-type">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append_unlocked</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *logline, <span class="hljs-type">int</span> len)</span></span>;<br></code></pre></td></tr></table></figure>
<p>append_unlocked 会先将log消息写入file_文件，之后再判断是否需要滚动日志文件；如果不滚动，就根据append_unlocked的调用次数和时间，确保1）一个log文件超时（默认1天），就创建一个新的；2）flush文件操作，不会频繁执行（默认间隔3秒）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogFile::append_unlocked</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *logline, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    file_-&gt;<span class="hljs-built_in">append</span>(logline, len);<br><br>    <span class="hljs-keyword">if</span> (file_-&gt;<span class="hljs-built_in">writtenBytes</span>() &gt; rollSize_)<br>    &#123; <span class="hljs-comment">// written bytes to file_ &gt; roll threshold (rollSize_)</span><br>        <span class="hljs-built_in">rollFile</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ++count_;<br>        <span class="hljs-keyword">if</span> (count_ &gt;= checkEveryN_)<br>        &#123;<br>            count_ = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">time_t</span> now = ::<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br>            <span class="hljs-type">time_t</span> thisPeriod_ = now / kRollPerSeconds_ * kRollPerSeconds_;<br><br>            <span class="hljs-keyword">if</span> (thisPeriod_ != startOfPeriod_)<br>            &#123; <span class="hljs-comment">// new period, roll file for log</span><br>                <span class="hljs-built_in">rollFile</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now - lastFlush_ &gt; flushInterval_)<br>            &#123; <span class="hljs-comment">// timeout ( flushInterval_ = 3 seconds)</span><br>                lastFlush_ = now;<br>                file_-&gt;<span class="hljs-built_in">flush</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>滚动日志</strong><br />
当文件写入量超过一个大小，就会创建一个新的日志文件，向里面写入数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LogFile::rollFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">time_t</span> now = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 获取日志文件名字</span><br>  string filename = <span class="hljs-built_in">getLogFileName</span>(basename_, &amp;now);<br>  <span class="hljs-comment">// 计算现在是第几天 now/kRollPerSeconds求出现在是第几天，再乘以秒数相当于是当前天数0点对应的秒数</span><br>  <span class="hljs-type">time_t</span> start = now / kRollPerSeconds_ * kRollPerSeconds_;<br><br>  <span class="hljs-keyword">if</span> (now &gt; lastRoll_)<br>  &#123;<br>    lastRoll_ = now;<br>    lastFlush_ = now;<br>    startOfPeriod_ = start;<br>    <span class="hljs-comment">// 让file_指向一个名为filename的文件，相当于新建了一个文件</span><br>    file_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> FileUtil::<span class="hljs-built_in">AppendFile</span>(filename));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>flush 日志文件</strong><br />
flush操作往往与write文件操作配套。LogFile::flush实际上是通过AppendFile::flush()，完成对日志文件的冲刷。与LogFile::append()类似，flush也能通过mutex_指针是否为空，自动选择线程安全版本，还是非线程安全版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogFile::flush</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (mutex_)<br>    &#123;<br>        <span class="hljs-function">MutexLockGuard <span class="hljs-title">lock</span><span class="hljs-params">(*mutex_)</span></span>;<br>        file_-&gt;<span class="hljs-built_in">flush</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        file_-&gt;<span class="hljs-built_in">flush</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h1 id="appendfile"><a class="markdownIt-Anchor" href="#appendfile"></a> AppendFile</h1>
<p>AppendFile 在 <a target="_blank" rel="noopener" href="http://FileUtil.cc">FileUtil.cc</a> 文件中被实现，其封装了 FILE 对文件操作的方法。以组合的形式被 LogFile 使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// not thread safe</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppendFile</span> : <span class="hljs-keyword">public</span> noncopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">AppendFile</span><span class="hljs-params">(StringArg filename)</span></span>;<br>    ~<span class="hljs-built_in">AppendFile</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* logline, <span class="hljs-type">size_t</span> len)</span></span>; <span class="hljs-comment">// 添加log消息到文件末尾</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 冲刷文件到磁盘</span><br>    <span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">writtenBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> writtenBytes_; &#125; <span class="hljs-comment">// 返回已写字节数</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* logline, <span class="hljs-type">size_t</span> len)</span></span>; <span class="hljs-comment">// 写数据到文件</span><br><br>    FILE* fp_;                                <span class="hljs-comment">// 文件指针</span><br>    <span class="hljs-type">char</span> buffer_[ReadSmallFile::kBufferSize]; <span class="hljs-comment">// 文件操作的缓冲区</span><br>    <span class="hljs-type">off_t</span> writtenBytes_;                      <span class="hljs-comment">// 已写字节数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>使用 RALL 手法，初始化即构造对象，析构则释放文件资源。setBuffer 可以设置系统默认的 IO 缓冲区为自己指定的用户缓冲区。大小为 64 KB。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FileUtil::AppendFile::<span class="hljs-built_in">AppendFile</span>(StringArg filename)<br>  : <span class="hljs-built_in">fp_</span>(::<span class="hljs-built_in">fopen</span>(filename.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;ae&quot;</span>)),  <span class="hljs-comment">// &#x27;e&#x27; for O_CLOEXEC</span><br>    <span class="hljs-built_in">writtenBytes_</span>(<span class="hljs-number">0</span>)<br>&#123;<br>  <span class="hljs-built_in">assert</span>(fp_);<br>  ::<span class="hljs-built_in">setbuffer</span>(fp_, buffer_, <span class="hljs-keyword">sizeof</span> buffer_);<br>  <span class="hljs-comment">// posix_fadvise POSIX_FADV_DONTNEED ?</span><br>&#125;<br><br>FileUtil::AppendFile::~<span class="hljs-built_in">AppendFile</span>()<br>&#123;<br>  ::<span class="hljs-built_in">fclose</span>(fp_);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>AppendFile 有个两个接口：append 和 write。其中，append() 是供用户调用的 public 接口，确保将指定数据附加到文件末尾，实际的写文件操作是通过 write() 来完成的；write 通过非线程安全的 glibc 库函数fwrite_unlocked() 来完成写文件操作，而没有选择线程安全的 fwrite()，主要是出于性能考虑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> FileUtil::AppendFile::<span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* logline, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)<br>&#123;<br>  <span class="hljs-type">size_t</span> written = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录已经写入的数据大小</span><br><br>  <span class="hljs-keyword">while</span> (written != len)<br>  &#123;<br>    <span class="hljs-type">size_t</span> remain = len - written; <span class="hljs-comment">// 还需写入的数据大小</span><br>    <span class="hljs-type">size_t</span> n = <span class="hljs-built_in">write</span>(logline + written, remain);<br>    <span class="hljs-keyword">if</span> (n != remain)<br>    &#123;<br>      <span class="hljs-type">int</span> err = <span class="hljs-built_in">ferror</span>(fp_);<br>      <span class="hljs-keyword">if</span> (err)<br>      &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;AppendFile::append() failed %s\n&quot;</span>, <span class="hljs-built_in">strerror_tl</span>(err));<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    written += n; <span class="hljs-comment">// 更新写入的数据大小</span><br>  &#125;<br><br>  writtenBytes_ += written; <span class="hljs-comment">// 记录目前为止写入的数据大小，超过限制会滚动日志</span><br>&#125;<br><br><span class="hljs-type">size_t</span> FileUtil::AppendFile::<span class="hljs-built_in">write</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* logline, <span class="hljs-type">size_t</span> len)<br>&#123;<br>  <span class="hljs-comment">// #undef fwrite_unlocked</span><br>  <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">fwrite_unlocked</span>(logline, <span class="hljs-number">1</span>, len, fp_);<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fortunely/p/15973948.html#small-buffer%E5%AD%98%E6%94%BElog%E6%B6%88%E6%81%AF">博客园 muduo笔记 日志库（一）</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">项目实战</a>
                    
                      <a class="hover-with-bg" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%93%E9%80%A0WebServer/">从零开始打造WebServer</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/08/WebServer(6)/">
                        <span class="hidden-mobile">WebServer(6) 定时器模块</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
