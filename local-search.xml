<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第一到七章流程整理</title>
    <link href="/2022/07/19/os(a)/"/>
    <url>/2022/07/19/os(a)/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><p>这一章节我将把从第一章到第七章的内容串联起来，缕清思路。</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><h3 id="第一章"><a class="markdownIt-Anchor" href="#第一章"></a> 第一章</h3><p>略</p><h3 id="第二章"><a class="markdownIt-Anchor" href="#第二章"></a> 第二章</h3><p>在电脑未开机前，BIOS就被事先写入到内存的0xF0000~0xFFFFF中。此区域为ROM。MBR被加载到磁盘的0盘0道1扇区（CHS方式），CHS 方式中扇区的编号是从1开始的。</p><p>在计算机启动之后，cs：ip寄存器会被强制置为0xF000:0xFFF0，由于在实模式下的段基址要乘以16，也就是左移四位，所以0xF000:0xFFF0的等效地址是0xFFFF0，这就是BIOS的入口地址。</p><p>0xFFFF0处的指令为跳转指令jmp far f000:e05b，跳转到BIOS真正的地址，进行检测内存、显卡等外设信息，当检测通过，并初始化好硬件后，开始在内存中 0x000~0x3FF处建立数据结构，中断向量表 IVT 并填写中断例程。</p><p>BIOS 最后一项工作校验启动盘中位于0盘0道1扇区的内容。如果此扇区末尾的两个字节分别是魔数0x55和0xaa，就会把该扇区内容加载到内存地址 0x7c00处，然后执行跳转指令jmp 0: 0x7c00，这里正是MBR的起始地址。</p><h3 id="第三章"><a class="markdownIt-Anchor" href="#第三章"></a> 第三章</h3><p>这一章主要是改进MBR，第一步是使其能直接访问显存，从而在显示器上打印字段。</p><p>第二步是让MBR直接操作硬盘，将硬盘中0盘0道2扇区的内容写入内存，然后跳转执行loader。这一步略微复杂，MBR需要执行以下步骤：</p><blockquote><p>第1步将LBA地址、扇区数放入相应I/O端口，再将读命令0x20放入Command端口，硬盘控制器就会自动将硬盘的数据读入Data端口，再存入硬盘控制器的缓冲区。</p></blockquote><blockquote><p>第2步就是利用查询传输方式，这段代码一直循环，也就是一直占用cpu查询Status端口，直到规定好的硬盘数据全部读入缓冲区，Status第3位被置为1，程序才会继续执行第3步。</p></blockquote><blockquote><p>第3步就是将缓冲区数据以2个字节为单位循环先读入Data端口，再用in指令读入内存。</p></blockquote><h3 id="第四章"><a class="markdownIt-Anchor" href="#第四章"></a> 第四章</h3><p>到这里我们就要从实模式进入保护模式了，首先修改boot.inc和loader.S，在内存里写好3个段描述符(代码段、数据段、显存段）、赋值好GDTR寄存器、创建好表示3个选择子的字段后，进入保护模式。</p><h4 id="bootinc"><a class="markdownIt-Anchor" href="#bootinc"></a> boot.inc</h4><blockquote><p>根据高32位的段描述符，依次定义字段最后相加，合成了代码段、数据段、显存段三个段的段描述符的高32位的字段。方便loader.S引用这些字段来构建代码段、数据段、显存段描述符。</p></blockquote><h4 id="loaders"><a class="markdownIt-Anchor" href="#loaders"></a> loader.S</h4><blockquote><p>1、通过给出低4字节加上引用boot.inc定义好的高4字节字段来向内存写入无用的第0段和3个有用段的段描述符（代码段、数据段、显存段）。并将他们的内存地址依次标记为GDT_BASE、CODE_DESC、DATA_STACK_DESC、VIDEO_DESC。<br />2、GDT_BASE因此为GDT的内存起始地址，可以用来创建GDTR。根据上述标号可以计算出3个段描述符各自的索引，从而可以创建各个段的选择子。<br />3、内存里写好3个段描述符、赋值好GDTR寄存器、创建好表示3个选择子的字段后，在实模式下利用BIOS中断13号中断打印字符串“2 loader in real”，再执行“3步走”代码打开保护模式，然后用定义好的选择子字段初始化段寄存器，当进入保护模式后打印“P”。<br />4、数据段和代码段段描述符段基址均为0，段界限均为4GB，即平坦模式：段偏移寄存器32位访问范围4GB，不可能换段。ss和ds寄存器都为数据段选择子。<br />5、显存段段基址为0xb8000，用于访问显存，gs为显存段选择子。</p></blockquote><h3 id="第五章"><a class="markdownIt-Anchor" href="#第五章"></a> 第五章</h3><p>这一章内容较多，我们要实现内容容量检测的函数、启用分页、加载内核。</p><h4 id="内存检测"><a class="markdownIt-Anchor" href="#内存检测"></a> 内存检测</h4><p>使用BIOS中断0x15的3个子功能0xe820、0xe801、0x88，可以获得内存容量。</p><blockquote><p>1、0xe820 获得os可用内存的基址和内存长度（单位字节）所有ards结构的低32基址+低32为内存长度的最大值即为内存容量；<br />2、0xe801获得低15MB(单位1KB)+1MB +16MB（单位64KB）以上内存容量 AX * 1024字节+1MB+BX * 1024*64字节；<br />3、0xe88 获得1MB以上内存容量AX * 1024字节+1MB</p></blockquote><p>loader.S在进入保护模式前测出内存容量，保存于内存0xb00处。</p><h4 id="启用分页"><a class="markdownIt-Anchor" href="#启用分页"></a> 启用分页</h4><p>对于本书实验而言，分页属性如下，</p><blockquote><p>虚拟地址：32位=4GB<br />物理地址：32MB (但是分页机制下能访问的实地址只有低1MB）32MB是内存容量的检测结果。<br />一块物理页大小：4kB<br />一个页表大小：4kB<br />一个页表项大小：4B<br />一个页表有1024个页表项，所以一个页表可表示1024*4kB=4MB的虚拟内存。</p></blockquote><blockquote><p>一个页目录大小：4kB<br />一个页目录项大小：4B<br />一个页目录有1024个页目录项，所以该页目录可表示4MB*1024=4GB虚拟内存。</p></blockquote><p>根据物理页大小4B 页表项个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个 ，页目录项个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个，可以将虚拟地址分成：</p><table><thead><tr><th>10位</th><th>10位</th><th>12位</th></tr></thead><tbody><tr><td>页目录项索引</td><td>页表项索引</td><td>块内偏移量</td></tr></tbody></table><p>具体实现步骤如下：</p><blockquote><p>1.构造页目录及页表，完成从虚拟地址3GB~3GB+1MB到实地址0 ~1MB的映射以及虚拟地址0 ~ 1MB向物理地址0 ~ 1MB的映射。[注]本次实验虚拟地址3GB和虚拟地址0将会转化成相同的物理地址0。<br />2.开启保护模式，将页目录地址赋值给cr3寄存器，并开启保护模式的分页机制。<br />3.修改GDTR中的段基址，以及显存段段描述符中的段基址，确保代码 mov byte [gs:160],‘V’  中的[gs:160]在保护模式的分段机制和分页机制下，最后会拼出虚拟地址0xc00b800+160，显然此地址在3GB~3GB+1MB的虚拟地址之间。</p></blockquote><h4 id="加载内核"><a class="markdownIt-Anchor" href="#加载内核"></a> 加载内核</h4><p>gcc会自动将main.c转化成具有elf格式的kernel.bin。<br />将kernel.bin刻入磁盘第9扇区，修改loader.S将其从磁盘加载到内存0x70000，该地址就是elf头的首地址。<br />在loader.S新编一个函数kernel_init，读取elf头内的信息，再读取程序头表，根据elf规范将kernel.bin的所有段拷贝到内存中相应位置，我们这次的main.c只有一个段，段内是死循环。<br />loader.S最后一句代码是jmp到0xc0001500地址。该地址就是设计好的死循环函数的入口地址。<br />bochs模拟最后程序死循环，说明死循环段被成功加载到虚拟地址0xc0001500处。</p><h3 id="第六章"><a class="markdownIt-Anchor" href="#第六章"></a> 第六章</h3><p>通过c语言和汇编混合编程的方式实现打印函数，其中会使用到内联汇编的知识。具体实现没有什么问题，看看书就能理解了。</p><h3 id="第七章"><a class="markdownIt-Anchor" href="#第七章"></a> 第七章</h3>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>真象还原</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第七章 实现中断处理 柳暗花明又一村</title>
    <link href="/2022/07/19/os(7)/"/>
    <url>/2022/07/19/os(7)/</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-实现中断处理-柳暗花明又一村"><a class="markdownIt-Anchor" href="#第七章-实现中断处理-柳暗花明又一村"></a> 第七章 实现中断处理 柳暗花明又一村</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>落笔前已经完成了这一章节的内容，本章难度不大但要编写的代码比较多，中断处理是os的必需内容，所以还是简单介绍下。</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>我把代码和头文件分别介绍一下：</p><h3 id="主体代码"><a class="markdownIt-Anchor" href="#主体代码"></a> 主体代码</h3><h4 id="kernels"><a class="markdownIt-Anchor" href="#kernels"></a> kernel.S</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><pre><code class="hljs x86asm">[<span class="hljs-meta">bits</span> <span class="hljs-number">32</span>]<br><span class="hljs-meta">%define</span> ERROR_CODE <span class="hljs-keyword">nop</span> <span class="hljs-comment">; 若在相关的异常中cpu已经自动压入了错误码,为保持栈中格式统一,这里不做操作.</span><br><span class="hljs-meta">%define</span> <span class="hljs-meta">ZERO</span> <span class="hljs-keyword">push</span> <span class="hljs-number">0</span> <span class="hljs-comment">; 若在相关的异常中cpu没有压入错误码,为了统一栈中格式,就手工压入一个0</span><br><br><span class="hljs-meta">extern</span> put_str<span class="hljs-comment">;</span><br><br><span class="hljs-meta">section</span> .data<br>intr_str <span class="hljs-built_in">db</span> <span class="hljs-string">&quot;interrupt occur!&quot;</span>, <span class="hljs-number">0xa</span>, <span class="hljs-number">0</span><br><span class="hljs-meta">global</span> intr_entry_table<br><span class="hljs-symbol">intr_entry_table:</span><br><br>%macro VECTOR <span class="hljs-number">2</span><br><span class="hljs-meta">section</span> .text<br>intr<span class="hljs-subst">%1</span>entry: <span class="hljs-comment">; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少</span><br><br>   <span class="hljs-subst">%2</span> <span class="hljs-comment">; 中断若有错误码会压在eip后面 </span><br><span class="hljs-keyword">push</span> intr_str<span class="hljs-comment">;</span><br><span class="hljs-keyword">call</span> put_str<span class="hljs-comment">;</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">4</span><span class="hljs-comment">;</span><br><br>   <span class="hljs-comment">; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI </span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x20</span>                   <span class="hljs-comment">; 中断结束命令EOI</span><br>   <span class="hljs-keyword">out</span> <span class="hljs-number">0xa0</span>,<span class="hljs-built_in">al</span>                   <span class="hljs-comment">; 向从片发送</span><br>   <span class="hljs-keyword">out</span> <span class="hljs-number">0x20</span>,<span class="hljs-built_in">al</span>                   <span class="hljs-comment">; 向主片发送</span><br>   <br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">4</span><span class="hljs-comment">;跨过错误码</span><br><span class="hljs-keyword">iret</span><span class="hljs-comment">;</span><br><br><span class="hljs-meta">section</span> .data<br>   <span class="hljs-built_in">dd</span>    intr<span class="hljs-subst">%1</span>entry <span class="hljs-comment">; 存储各个中断入口程序的地址，形成intr_entry_table数组</span><br>%endmacro<br><br>VECTOR <span class="hljs-number">0x00</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x01</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x02</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x03</span>,<span class="hljs-meta">ZERO</span> <br>VECTOR <span class="hljs-number">0x04</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x05</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x06</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x07</span>,<span class="hljs-meta">ZERO</span> <br>VECTOR <span class="hljs-number">0x08</span>,ERROR_CODE<br>VECTOR <span class="hljs-number">0x09</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x0a</span>,ERROR_CODE<br>VECTOR <span class="hljs-number">0x0b</span>,ERROR_CODE <br>VECTOR <span class="hljs-number">0x0c</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x0d</span>,ERROR_CODE<br>VECTOR <span class="hljs-number">0x0e</span>,ERROR_CODE<br>VECTOR <span class="hljs-number">0x0f</span>,<span class="hljs-meta">ZERO</span> <br>VECTOR <span class="hljs-number">0x10</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x11</span>,ERROR_CODE<br>VECTOR <span class="hljs-number">0x12</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x13</span>,<span class="hljs-meta">ZERO</span> <br>VECTOR <span class="hljs-number">0x14</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x15</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x16</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x17</span>,<span class="hljs-meta">ZERO</span> <br>VECTOR <span class="hljs-number">0x18</span>,ERROR_CODE<br>VECTOR <span class="hljs-number">0x19</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x1a</span>,ERROR_CODE<br>VECTOR <span class="hljs-number">0x1b</span>,ERROR_CODE <br>VECTOR <span class="hljs-number">0x1c</span>,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x1d</span>,ERROR_CODE<br>VECTOR <span class="hljs-number">0x1e</span>,ERROR_CODE<br>VECTOR <span class="hljs-number">0x1f</span>,<span class="hljs-meta">ZERO</span> <br>VECTOR <span class="hljs-number">0x20</span>,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;时钟中断对应的入口</span><br></code></pre></td></tr></table></figure><p>定义了33个中断处理程序<br />数组intr_entry_table记录每个程序入口地址</p><h4 id="interruptc"><a class="markdownIt-Anchor" href="#interruptc"></a> interrupt.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;interrupt.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;io.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;print.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIC_M_CTRL 0x20       <span class="hljs-comment">// 这里用的可编程中断控制器是8259A,主片的控制端口是0x20</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIC_M_DATA 0x21       <span class="hljs-comment">// 主片的数据端口是0x21</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIC_S_CTRL 0xa0       <span class="hljs-comment">// 从片的控制端口是0xa0</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIC_S_DATA 0xa1       <span class="hljs-comment">// 从片的数据端口是0xa1</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_CNT 0x81      <span class="hljs-comment">// 目前总共支持的中断数</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFLAGS_IF   0x00000200       <span class="hljs-comment">// eflags寄存器中的if位为1</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_EFLAGS(EFLAG_VAR) asm volatile(<span class="hljs-string">&quot;pushfl; popl %0&quot;</span> : <span class="hljs-string">&quot;=g&quot;</span> (EFLAG_VAR))</span><br><br><br><span class="hljs-comment">/*中断门描述符结构体*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gate_desc</span> &#123;</span><br>   <span class="hljs-type">uint16_t</span>    func_offset_low_word;<br>   <span class="hljs-type">uint16_t</span>    selector;<br>   <span class="hljs-type">uint8_t</span>     dcount;   <span class="hljs-comment">//此项为双字计数字段，是门描述符中的第4字节。此项固定值，不用考虑</span><br>   <span class="hljs-type">uint8_t</span>     attribute;<br>   <span class="hljs-type">uint16_t</span>    func_offset_high_word;<br>&#125;;<br><br><span class="hljs-comment">// 静态函数声明,非必须</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">make_idt_desc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gate_desc* p_gdesc, <span class="hljs-type">uint8_t</span> attr, intr_handler function)</span>;<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gate_desc</span> <span class="hljs-title">idt</span>[<span class="hljs-title">IDT_DESC_CNT</span>];</span>   <span class="hljs-comment">// idt是中断描述符表,本质上就是个中断门描述符数组</span><br><br><span class="hljs-comment">/********    定义中断处理程序数组    ********</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/********************************************/</span><br><span class="hljs-keyword">extern</span> intr_handler intr_entry_table[IDT_DESC_CNT];    <span class="hljs-comment">// 声明引用定义在kernel.S中的中断处理函数入口数组</span><br><br><span class="hljs-comment">/* 初始化可编程中断控制器8259A */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">pic_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><br>   <span class="hljs-comment">/* 初始化主片 */</span><br>   outb (PIC_M_CTRL, <span class="hljs-number">0x11</span>);   <span class="hljs-comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span><br>   outb (PIC_M_DATA, <span class="hljs-number">0x20</span>);   <span class="hljs-comment">// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.</span><br>   outb (PIC_M_DATA, <span class="hljs-number">0x04</span>);   <span class="hljs-comment">// ICW3: IR2接从片. </span><br>   outb (PIC_M_DATA, <span class="hljs-number">0x01</span>);   <span class="hljs-comment">// ICW4: 8086模式, 正常EOI</span><br><br>   <span class="hljs-comment">/* 初始化从片 */</span><br>   outb (PIC_S_CTRL, <span class="hljs-number">0x11</span>);    <span class="hljs-comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span><br>   outb (PIC_S_DATA, <span class="hljs-number">0x28</span>);    <span class="hljs-comment">// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.</span><br>   outb (PIC_S_DATA, <span class="hljs-number">0x02</span>);    <span class="hljs-comment">// ICW3: 设置从片连接到主片的IR2引脚</span><br>   outb (PIC_S_DATA, <span class="hljs-number">0x01</span>);    <span class="hljs-comment">// ICW4: 8086模式, 正常EOI</span><br>   <br>  <span class="hljs-comment">/* IRQ2用于级联从片,必须打开,否则无法响应从片上的中断</span><br><span class="hljs-comment">  主片上打开的中断有IRQ0的时钟,IRQ1的键盘和级联从片的IRQ2,其它全部关闭 */</span><br>   outb (PIC_M_DATA, <span class="hljs-number">0xf8</span>);<br><br><span class="hljs-comment">/* 打开从片上的IRQ14,此引脚接收硬盘控制器的中断 */</span><br>   outb (PIC_S_DATA, <span class="hljs-number">0xbf</span>);<br><br>   put_str(<span class="hljs-string">&quot;   pic_init done\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* 创建中断门描述符 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">make_idt_desc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gate_desc* p_gdesc, <span class="hljs-type">uint8_t</span> attr, intr_handler function)</span> &#123; <br>   p_gdesc-&gt;func_offset_low_word = (<span class="hljs-type">uint32_t</span>)function &amp; <span class="hljs-number">0x0000FFFF</span>;<br>   p_gdesc-&gt;selector = SELECTOR_K_CODE;<br>   p_gdesc-&gt;dcount = <span class="hljs-number">0</span>;<br>   p_gdesc-&gt;attribute = attr;<br>   p_gdesc-&gt;func_offset_high_word = ((<span class="hljs-type">uint32_t</span>)function &amp; <span class="hljs-number">0xFFFF0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br>&#125;<br><br><span class="hljs-comment">/*初始化中断描述符表*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">idt_desc_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   <span class="hljs-type">int</span> i, lastindex = IDT_DESC_CNT - <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; IDT_DESC_CNT; i++) &#123;<br>      make_idt_desc(&amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); <br>   &#125;<br><span class="hljs-comment">/* 单独处理系统调用,系统调用对应的中断门dpl为3,</span><br><span class="hljs-comment"> * 中断处理程序为单独的syscall_handler */</span><br><br>   put_str(<span class="hljs-string">&quot;   idt_desc_init done\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">/*完成有关中断的所有初始化工作*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">idt_init</span><span class="hljs-params">()</span> &#123;<br>   put_str(<span class="hljs-string">&quot;idt_init start\n&quot;</span>);<br>   idt_desc_init();   <span class="hljs-comment">// 初始化中断描述符表</span><br><br>   pic_init();   <span class="hljs-comment">// 初始化8259A</span><br><br>   <span class="hljs-comment">/* 加载idt */</span><br>   <span class="hljs-type">uint64_t</span> idt_operand = ((<span class="hljs-keyword">sizeof</span>(idt) - <span class="hljs-number">1</span>) | ((<span class="hljs-type">uint64_t</span>)(<span class="hljs-type">uint32_t</span>)idt &lt;&lt; <span class="hljs-number">16</span>));<br>   <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lidt %0&quot;</span> : : <span class="hljs-string">&quot;m&quot;</span> (idt_operand))</span>;<br>   put_str(<span class="hljs-string">&quot;idt_init done\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>idt_desc_init():填写33个中断处理程序对应的中断门描述符<br />pic_init() ; 初始化8259A芯片<br />加载idt：即赋值IDTR</p><h4 id="initc"><a class="markdownIt-Anchor" href="#initc"></a> init.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;init.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;print.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;interrupt.h&quot;</span></span><br><br><span class="hljs-comment">/*负责初始化所有模块 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_all</span><span class="hljs-params">()</span> &#123;<br>   put_str(<span class="hljs-string">&quot;init_all\n&quot;</span>);<br>   idt_init();     <span class="hljs-comment">// 初始化中断</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mainc"><a class="markdownIt-Anchor" href="#mainc"></a> main.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;print.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;init.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   put_str(<span class="hljs-string">&quot;I am kernel\n&quot;</span>);<br>   init_all();<br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;sti&quot;</span>)</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h3><h4 id="inith"><a class="markdownIt-Anchor" href="#inith"></a> init.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __KERNEL_INIT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __KERNEL_INIT_H</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_all</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="interrupth"><a class="markdownIt-Anchor" href="#interrupth"></a> interrupt.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __KERNEL_INTERRUPT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __KERNEL_INTERRUPT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>* intr_handler;<br><span class="hljs-type">void</span> <span class="hljs-title function_">idt_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>intr_handler是用来修饰33个中断处理程序入口地址数组intr_entry_table[IDT_DESC_CNT]的，该数组位于某个数据段，成员均是地址。</p><p>void*是空指针类型，表地址。</p><h4 id="ioh"><a class="markdownIt-Anchor" href="#ioh"></a> io.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/************** 机器模式   ***************</span><br><span class="hljs-comment"> b -- 输出寄存器QImode名称,即寄存器中的最低8位:[a-d]l。</span><br><span class="hljs-comment"> w -- 输出寄存器HImode名称,即寄存器中2个字节的部分,如[a-d]x。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> HImode</span><br><span class="hljs-comment">     “Half-Integer”模式，表示一个两字节的整数。 </span><br><span class="hljs-comment"> QImode</span><br><span class="hljs-comment">     “Quarter-Integer”模式，表示一个一字节的整数。 </span><br><span class="hljs-comment">*******************************************/</span> <br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LIB_IO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __LIB_IO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><br><span class="hljs-comment">/* 向端口port写入一个字节*/</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">outb</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port, <span class="hljs-type">uint8_t</span> data)</span> &#123;<br><span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment"> a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, </span><br><span class="hljs-comment"> %b0表示对应al,%w1表示对应dx */</span> <br>   <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">( <span class="hljs-string">&quot;outb %b0, %w1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (data), <span class="hljs-string">&quot;Nd&quot;</span> (port))</span>;    <br><span class="hljs-comment">/******************************************************/</span><br>&#125;<br><br><span class="hljs-comment">/* 将addr处起始的word_cnt个字写入端口port */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">outsw</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr, <span class="hljs-type">uint32_t</span> word_cnt)</span> &#123;<br><span class="hljs-comment">/*********************************************************</span><br><span class="hljs-comment">   +表示此限制即做输入又做输出.</span><br><span class="hljs-comment">   outsw是把ds:esi处的16位的内容写入port端口, 我们在设置段描述符时, </span><br><span class="hljs-comment">   已经将ds,es,ss段的选择子都设置为相同的值了,此时不用担心数据错乱。*/</span><br>   <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;cld; rep outsw&quot;</span> : <span class="hljs-string">&quot;+S&quot;</span> (addr), <span class="hljs-string">&quot;+c&quot;</span> (word_cnt) : <span class="hljs-string">&quot;d&quot;</span> (port))</span>;<br><span class="hljs-comment">/******************************************************/</span><br>&#125;<br><br><span class="hljs-comment">/* 将从端口port读入的一个字节返回 */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">inb</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port)</span> &#123;<br>   <span class="hljs-type">uint8_t</span> data;<br>   <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;inb %w1, %b0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;Nd&quot;</span> (port))</span>;<br>   <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">/* 将从端口port读入的word_cnt个字写入addr */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">insw</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port, <span class="hljs-type">void</span>* addr, <span class="hljs-type">uint32_t</span> word_cnt)</span> &#123;<br><span class="hljs-comment">/******************************************************</span><br><span class="hljs-comment">   insw是将从端口port处读入的16位内容写入es:edi指向的内存,</span><br><span class="hljs-comment">   我们在设置段描述符时, 已经将ds,es,ss段的选择子都设置为相同的值了,</span><br><span class="hljs-comment">   此时不用担心数据错乱。*/</span><br>   <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;cld; rep insw&quot;</span> : <span class="hljs-string">&quot;+D&quot;</span> (addr), <span class="hljs-string">&quot;+c&quot;</span> (word_cnt) : <span class="hljs-string">&quot;d&quot;</span> (port) : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br><span class="hljs-comment">/******************************************************/</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>平时写函数都是把函数体写在.c的文件里，函数声明写在.h里，其他文件要调用就include .h的文件即可。但是这次却把这些函数写在了.h里。static作用域只是此文件，也就是只有此文件才可以调用。</p><p>对端口的读写或一段连续的内存对端口读写都可以调用汇编指令inb(AT&amp;A)/ins(intel), outsw等。<br />但是为了内核使用c语言在main函数完成8259A的设置，所以可以使用c函数封装内联汇编形式，这些函数都是static inline，意味着当调用此函数时不再是函数调用，而是就地展开，不再需要传递参数入栈，执行快，但程序体积更庞大。<br />之所以这样是因为对端口操作属于I/O操作，非常慢，一旦用户程序调用他们，可能会等很长时间，所以在函数调用方面就要尽可能快来追求更短的总时间。</p><h4 id="globalh"><a class="markdownIt-Anchor" href="#globalh"></a> global.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __KERNEL_GLOBAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __KERNEL_GLOBAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RPL0  0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RPL1  1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RPL2  2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RPL3  3</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TI_GDT 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TI_LDT 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_CODE   ((1 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_DATA   ((2 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_STACK   SELECTOR_K_DATA </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_GS   ((3 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><br><br><span class="hljs-comment">//--------------   IDT描述符属性  ------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_P 1 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_DPL0   0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_DPL3   3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_32_TYPE     0xE   <span class="hljs-comment">// 32位的门</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_16_TYPE     0x6   <span class="hljs-comment">// 16位的门，不用，定义它只为和32位门区分</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_ATTR_DPL0  ((IDT_DESC_P &lt;&lt; 7) + (IDT_DESC_DPL0 &lt;&lt; 5) + IDT_DESC_32_TYPE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_ATTR_DPL3  ((IDT_DESC_P &lt;&lt; 7) + (IDT_DESC_DPL3 &lt;&lt; 5) + IDT_DESC_32_TYPE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="写在后面"><a class="markdownIt-Anchor" href="#写在后面"></a> 写在后面</h2><p>不知不觉已经走过了将近一半的路程，回过头看实在艰辛，不过想想自己在这几天收获的东西真是很多。下一章节不准备向下进行了，我想把这半程的过程重新整理一下，并且把代码托管到github上。收拾一下行囊，再出发！</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>真象还原</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第六章 完善内核 开启c和汇编混合编程</title>
    <link href="/2022/07/18/os(6)/"/>
    <url>/2022/07/18/os(6)/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-完善内核-开启c和汇编混合编程"><a class="markdownIt-Anchor" href="#第六章-完善内核-开启c和汇编混合编程"></a> 第六章 完善内核 开启c和汇编混合编程</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>不知不觉已经16日了，前几天出门旅游几天放松了下，回来继续学习。这章开始进入了C语言和汇编混合编程，用来丰富我们的内核。</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>本章围绕在C语言和汇编混合编程这一块，有了前面几章的铺垫，书上概念理解起来不是很困难。但是在实际编程过程中如果按照书上代码照搬的话会有很多报错。其原因主要出现在gcc编译器的版本和64位系统无法编译。</p><p>下面贴上本章代码：<br />print.S:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></div></td><td class="code"><pre><code class="hljs x86asm">TI_GDT <span class="hljs-built_in">equ</span>  <span class="hljs-number">0</span><br>RPL0  <span class="hljs-built_in">equ</span>   <span class="hljs-number">0</span><br>SELECTOR_VIDEO <span class="hljs-built_in">equ</span> (<span class="hljs-number">0x0003</span>&lt;&lt;<span class="hljs-number">3</span>) + TI_GDT + RPL0<br><br><br>[<span class="hljs-meta">bits</span> <span class="hljs-number">32</span>]<br><span class="hljs-meta">section</span> .text<br><br><span class="hljs-comment">;------------------------   put_char   -----------------------------</span><br><span class="hljs-comment">;功能描述:把栈中的1个字符写入光标所在处</span><br><span class="hljs-comment">;-------------------------------------------------------------------   </span><br><span class="hljs-meta">global</span> put_char<br><span class="hljs-symbol">put_char:</span><br>   <span class="hljs-keyword">pushad</span>   <span class="hljs-comment">;备份32位寄存器环境</span><br>   <span class="hljs-comment">;需要保证gs中为正确的视频段选择子,为保险起见,每次打印时都为gs赋值</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, SELECTOR_VIDEO       <span class="hljs-comment">; 不能直接把立即数送入段寄存器</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><br><span class="hljs-comment">;;;;;;;;;  获取当前光标位置 ;;;;;;;;;</span><br>   <span class="hljs-comment">;先获得高8位</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d4</span>  <span class="hljs-comment">;索引寄存器</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0e</span>   <span class="hljs-comment">;用于提供光标位置的高8位</span><br>   <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d5</span>  <span class="hljs-comment">;通过读写数据端口0x3d5来获得或设置光标位置 </span><br>   <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span>   <span class="hljs-comment">;得到了光标位置的高8位</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-built_in">al</span><br><br>   <span class="hljs-comment">;再获取低8位</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d4</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0f</span><br>   <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d5</span> <br>   <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span><br><br>   <span class="hljs-comment">;将光标存入bx</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, <span class="hljs-built_in">ax</span>  <br>   <span class="hljs-comment">;下面这行是在栈中获取待打印的字符</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, [<span class="hljs-built_in">esp</span> + <span class="hljs-number">36</span>]      <span class="hljs-comment">;pushad压入4×8＝32字节,加上主调函数的返回地址4字节,故esp+36字节</span><br>   <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">0xd</span>  <span class="hljs-comment">;CR是0x0d,LF是0x0a</span><br>   <span class="hljs-keyword">jz</span> .is_carriage_return<br>   <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">0xa</span><br>   <span class="hljs-keyword">jz</span> .is_line_feed<br><br>   <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">0x8</span>  <span class="hljs-comment">;BS(backspace)的asc码是8</span><br>   <span class="hljs-keyword">jz</span> .is_backspace<br>   <span class="hljs-keyword">jmp</span> .put_other   <br><span class="hljs-comment">;;;;;;;;;;;;;;;;;;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> .is_backspace:</span>      <br><span class="hljs-comment">;;;;;;;;;;;;       backspace的一点说明     ;;;;;;;;;;</span><br><span class="hljs-comment">; 当为backspace时,本质上只要将光标移向前一个显存位置即可.后面再输入的字符自然会覆盖此处的字符</span><br><span class="hljs-comment">; 但有可能在键入backspace后并不再键入新的字符,这时在光标已经向前移动到待删除的字符位置,但字符还在原处,</span><br><span class="hljs-comment">; 这就显得好怪异,所以此处添加了空格或空字符0</span><br>   <span class="hljs-keyword">dec</span> <span class="hljs-built_in">bx</span><br>   <span class="hljs-keyword">shl</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-number">0x20</span>  <span class="hljs-comment">;将待删除的字节补为0或空格皆可</span><br>   <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-number">0x07</span><br>   <span class="hljs-keyword">shr</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br>   <span class="hljs-keyword">jmp</span> .set_cursor<br><span class="hljs-comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> .put_other:</span><br>   <span class="hljs-keyword">shl</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">1</span>  <span class="hljs-comment">; 光标位置是用2字节表示,将光标值乘2,表示对应显存中的偏移字节</span><br>   <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">cl</span>  <span class="hljs-comment">; ascii字符本身</span><br>   <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>],<span class="hljs-number">0x07</span>  <span class="hljs-comment">; 字符属性</span><br>   <span class="hljs-keyword">shr</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">1</span>  <span class="hljs-comment">; 恢复老的光标值</span><br>   <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span>  <span class="hljs-comment">; 下一个光标值</span><br>   <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">2000</span>   <br>   <span class="hljs-keyword">jl</span> .set_cursor  <span class="hljs-comment">; 若光标值小于2000,表示未写到显存的最后,则去设置新的光标值</span><br>  <span class="hljs-comment">; 若超出屏幕字符数大小(2000)则换行处理</span><br><span class="hljs-symbol"> .is_line_feed:</span>  <span class="hljs-comment">; 是换行符LF(\n)</span><br><span class="hljs-symbol"> .is_carriage_return:</span>  <span class="hljs-comment">; 是回车符CR(\r)</span><br>  <span class="hljs-comment">; 如果是CR(\r),只要把光标移到行首就行了。</span><br>   <span class="hljs-keyword">xor</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">dx</span>  <span class="hljs-comment">; dx是被除数的高16位,清0.</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">bx</span>  <span class="hljs-comment">; ax是被除数的低16位.</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>, <span class="hljs-number">80</span>  <span class="hljs-comment">; 由于是效仿linux，linux中\n便表示下一行的行首，所以本系统中，</span><br>   <span class="hljs-keyword">div</span> <span class="hljs-built_in">si</span>  <span class="hljs-comment">; 把\n和\r都处理为linux中\n的意思，也就是下一行的行首。</span><br>   <span class="hljs-keyword">sub</span> <span class="hljs-built_in">bx</span>, <span class="hljs-built_in">dx</span>  <span class="hljs-comment">; 光标值减去除80的余数便是取整</span><br>  <span class="hljs-comment">; 以上4行处理\r的代码</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> .is_carriage_return_end:</span>                 <span class="hljs-comment">; 回车符CR处理结束</span><br>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">80</span><br>   <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">2000</span><br><span class="hljs-symbol"> .is_line_feed_end:</span>  <span class="hljs-comment">; 若是LF(\n),将光标移+80便可。  </span><br>   <span class="hljs-keyword">jl</span> .set_cursor<br><br><span class="hljs-comment">;屏幕行范围是0~24,滚屏的原理是将屏幕的1~24行搬运到0~23行,再将第24行用空格填充</span><br><span class="hljs-symbol"> .roll_screen:</span>  <span class="hljs-comment">; 若超出屏幕大小，开始滚屏</span><br>   <span class="hljs-keyword">cld</span>  <br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">960</span>  <span class="hljs-comment">; 一共有2000-80=1920个字符要搬运,共1920*2=3840字节.一次搬4字节,共3840/4=960次 </span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">0xc00b80a0</span>  <span class="hljs-comment">; 第1行行首</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>, <span class="hljs-number">0xc00b8000</span>  <span class="hljs-comment">; 第0行行首</span><br>   <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsd</span>  <br><br><span class="hljs-comment">;;;;;;;将最后一行填充为空白</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">3840</span>  <span class="hljs-comment">; 最后一行首字符的第一个字节偏移= 1920 * 2</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">80</span>  <span class="hljs-comment">;一行是80字符(160字节),每次清理1字符(2字节),一行需要移动80次</span><br><span class="hljs-symbol"> .cls:</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">ebx</span>], <span class="hljs-number">0x0720</span>  <span class="hljs-comment">;0x0720是黑底白字的空格键</span><br>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">2</span><br>   <span class="hljs-keyword">loop</span> .cls <br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1920</span>  <span class="hljs-comment">;将光标值重置为1920,最后一行的首字符.</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> .set_cursor:</span>   <br>  <span class="hljs-comment">;将光标设为bx值</span><br><span class="hljs-comment">;;;;;;; 1 先设置高8位 ;;;;;;;;</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d4</span>  <span class="hljs-comment">;索引寄存器</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0e</span>  <span class="hljs-comment">;用于提供光标位置的高8位</span><br>   <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d5</span>  <span class="hljs-comment">;通过读写数据端口0x3d5来获得或设置光标位置 </span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">bh</span><br>   <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br><br><span class="hljs-comment">;;;;;;; 2 再设置低8位 ;;;;;;;;;</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d4</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0f</span><br>   <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d5</span> <br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">bl</span><br>   <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br><span class="hljs-symbol"> .put_char_done:</span> <br>   <span class="hljs-keyword">popad</span><br>   <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>main.c:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#include</span> &quot;print<span class="hljs-selector-class">.h</span>&quot;<br>void <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br><span class="hljs-built_in">put_char</span>(&#x27;K&#x27;);<br><span class="hljs-built_in">put_char</span>(&#x27;e&#x27;);<br><span class="hljs-built_in">put_char</span>(&#x27;r&#x27;);<br><span class="hljs-built_in">put_char</span>(&#x27;n&#x27;);<br><span class="hljs-built_in">put_char</span>(&#x27;e&#x27;);<br><span class="hljs-built_in">put_char</span>(&#x27;l&#x27;);<br><span class="hljs-built_in">put_char</span>(&#x27;\n&#x27;);<br><span class="hljs-built_in">put_char</span>(&#x27;<span class="hljs-number">1</span>&#x27;);<br><span class="hljs-built_in">put_char</span>(&#x27;<span class="hljs-number">2</span>&#x27;);<br><span class="hljs-built_in">put_char</span>(&#x27;\b&#x27;);<br><span class="hljs-built_in">put_char</span>(&#x27;<span class="hljs-number">3</span>&#x27;);<br><span class="hljs-built_in">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>stdint.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LIB_STDINT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __LIB_STDINT_H</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">char</span> <span class="hljs-type">int8_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">int16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">int</span> <span class="hljs-type">int32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">int64_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">uint16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">uint64_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>print.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LIB_KERNEL_PRINT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __LIB_KERNEL_PRINT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put_char</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> char_asci)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>以上就是本章全部的代码，下面我再把编译链接的语句也贴上，直接复制到终端就行了：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle">nasm -o boot<span class="hljs-regexp">/mbr.bin boot/m</span>br.S<br>dd <span class="hljs-keyword">if</span>=<span class="hljs-regexp">/home/</span>podest<span class="hljs-regexp">/bochs/</span>boot<span class="hljs-regexp">/mbr.bin of=/</span>home<span class="hljs-regexp">/podest/</span>bochs/hd60M.img bs=<span class="hljs-number">512</span> <span class="hljs-keyword">count</span>=<span class="hljs-number">1</span> seek=<span class="hljs-number">0</span> conv=notrunc<br>nasm -o boot<span class="hljs-regexp">/loader.bin boot/</span>loader.S<br>dd <span class="hljs-keyword">if</span>=<span class="hljs-regexp">/home/</span>podest<span class="hljs-regexp">/bochs/</span>boot<span class="hljs-regexp">/loader.bin of=/</span>home<span class="hljs-regexp">/podest/</span>bochs/hd60M.img bs=<span class="hljs-number">512</span> <span class="hljs-keyword">count</span>=<span class="hljs-number">3</span> seek=<span class="hljs-number">2</span> conv=notrunc<br>nasm -f elf -o lib<span class="hljs-regexp">/kernel/</span><span class="hljs-keyword">print</span>.o lib<span class="hljs-regexp">/kernel/</span><span class="hljs-keyword">print</span>.S<br>gcc -m32 -I  lib<span class="hljs-regexp">/kernel/</span> -c -o kernel<span class="hljs-regexp">/main.o kernel/m</span>ain.c<br>ld -m elf_i386 -Ttext <span class="hljs-number">0</span>xc0001500 -e main -o kernel<span class="hljs-regexp">/kernel.bin kernel/m</span>ain.o  lib<span class="hljs-regexp">/kernel/</span><span class="hljs-keyword">print</span>.o<br>dd <span class="hljs-keyword">if</span>=<span class="hljs-regexp">/home/</span>podest<span class="hljs-regexp">/bochs/</span>kernel<span class="hljs-regexp">/kernel.bin of=/</span>home<span class="hljs-regexp">/podest/</span>bochs/hd60M.img bs=<span class="hljs-number">512</span> <span class="hljs-keyword">count</span>=<span class="hljs-number">200</span> seek=<span class="hljs-number">9</span> conv=notrunc<br>bin/bochs -f bochsrc.disk<br></code></pre></td></tr></table></figure><h2 id="写在后面"><a class="markdownIt-Anchor" href="#写在后面"></a> 写在后面</h2><p>本来想着在17日晚上就把这一章结束的，但是17日bochs一直在崩溃退出，原因也是出在代码上面，又参考了别人的代码才勉强完成。在调试的过程中也深知自己对于汇编的掌握还需加强。也开始再重新回看之前几章的内容，这一过程相比第一次读更令我受益匪浅。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>真象还原</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第五章 内存分页 向内核迈进</title>
    <link href="/2022/07/12/os(5)/"/>
    <url>/2022/07/12/os(5)/</url>
    
    <content type="html"><![CDATA[<h1 id="第五章-内存分页-向内核迈进"><a class="markdownIt-Anchor" href="#第五章-内存分页-向内核迈进"></a> 第五章 内存分页 向内核迈进</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>现在是10号早上8点，外面阴雨连绵，翻看目录想必这一章又是难上加难，继续战斗吧。<br />补：本章主要代码部分是loader和boot.inc的修改，书中描绘是按功能来的，过程中我就不再贴代码了，否则会显得太过冗长，我会将总代码放在文末。</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>梳理一下本章节基本内容。首先描述了通过loader获取到整个物理内存容量的基本操作，后面会经常用到。主要是通过BIOS中断0x15的三个子功能实现，其中0xe820功能最强但也最为繁琐，0xe801次之，0x88最后。然后对loader进行一个修改就可以了，目前还用不到这项功能。</p><blockquote><p>虽然博客只写了这么几行，但是遗憾的是现在已经是11号晚上9点了。这两天一直在调试这一章的内容，但是按书上的代码运行却出现了许多错误，究其原因，问题来自于gcc的版本，如果高于gcc5就会出现各种问题，所以我尝试将gcc降级，难以接受的是我找遍了网络也没找到ubuntu22.04gcc降级的方法。一气之下我又重新下载了ubuntu16的虚拟机，又重新将之前的代码调试了一遍，真是劳心费神。</p></blockquote><p>其次，实现了内存分页机制，再次修改loader，同时为了匹配上loader的修改，也要对boot进行一个更新。最后，用C语言加载了一个简单的内核，并且在loader中创建一个接口跳转向内核。</p><h3 id="loaders"><a class="markdownIt-Anchor" href="#loaders"></a> loader.S</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">   %include <span class="hljs-string">&quot;include/boot.inc&quot;</span><br>   section loader vstart=LOADER_BASE_ADDR<br>   LOADER_STACK_TOP equ LOADER_BASE_ADDR<br><span class="hljs-comment">;构建gdt及其内部的描述符</span><br><span class="hljs-symbol">   GDT_BASE:</span>   dd    <span class="hljs-number">0x00000000</span> <br>       dd    <span class="hljs-number">0x00000000</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   CODE_DESC:</span>  dd    <span class="hljs-number">0x0000FFFF</span> <br>       dd    DESC_CODE_HIGH4<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   DATA_STACK_DESC:</span>  dd    <span class="hljs-number">0x0000FFFF</span><br>     dd    DESC_DATA_HIGH4<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   VIDEO_DESC:</span> dd    <span class="hljs-number">0x80000007</span>       <span class="hljs-comment">; limit=(0xbffff-0xb8000)/4k=0x7</span><br>       dd    DESC_VIDEO_HIGH4  <span class="hljs-comment">; 此时dpl为0</span><br><br>   GDT_SIZE   equ   $ - GDT_BASE<br>   GDT_LIMIT   equ   GDT_SIZE -<span class="hljs-number">1</span> <br>   times <span class="hljs-number">60</span> dq <span class="hljs-number">0</span> <span class="hljs-comment">; 此处预留60个描述符的空位(slot)</span><br>   SELECTOR_CODE equ (<span class="hljs-number">0x0001</span>&lt;&lt;<span class="hljs-number">3</span>) + TI_GDT + RPL0         <span class="hljs-comment">; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span><br>   SELECTOR_DATA equ (<span class="hljs-number">0x0002</span>&lt;&lt;<span class="hljs-number">3</span>) + TI_GDT + RPL0 <span class="hljs-comment">; 同上</span><br>   SELECTOR_VIDEO equ (<span class="hljs-number">0x0003</span>&lt;&lt;<span class="hljs-number">3</span>) + TI_GDT + RPL0 <span class="hljs-comment">; 同上 </span><br><br>   <span class="hljs-comment">; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span><br>   <span class="hljs-comment">; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span><br>   <span class="hljs-comment">; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span><br>   total_mem_bytes dd <span class="hljs-number">0</span> <br>   <span class="hljs-comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><br>   <span class="hljs-comment">;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br>   gdt_ptr  dw  GDT_LIMIT <br>    dd  GDT_BASE<br><br>   <span class="hljs-comment">;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span><br>   ards_buf times <span class="hljs-number">244</span> db <span class="hljs-number">0</span><br>   ards_nr dw <span class="hljs-number">0</span>      <span class="hljs-comment">;用于记录ards结构体数量</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   loader_start:</span><br>   <br><span class="hljs-comment">;-------  int 15h eax = 0000E820h ,edx = 534D4150h (&#x27;SMAP&#x27;) 获取内存布局  -------</span><br><br>   <span class="hljs-keyword">xor </span>ebx, ebx      <span class="hljs-comment">;第一次调用时，ebx值要为0</span><br>   mov edx, <span class="hljs-number">0x534d4150</span>      <span class="hljs-comment">;edx只赋值一次，循环体中不会改变</span><br>   mov <span class="hljs-keyword">di, </span>ards_buf      <span class="hljs-comment">;ards结构缓冲区</span><br><span class="hljs-symbol">.e820_mem_get_loop:</span>      <span class="hljs-comment">;循环获取每个ARDS内存范围描述结构</span><br>   mov eax, <span class="hljs-number">0x0000e820</span>      <span class="hljs-comment">;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br>   mov ecx, <span class="hljs-number">20</span>      <span class="hljs-comment">;ARDS地址范围描述符结构大小是20字节</span><br>   int <span class="hljs-number">0x15</span><br>   <span class="hljs-keyword">jc </span>.e820_failed_so_try_e801   <span class="hljs-comment">;若cf位为1则有错误发生，尝试0xe801子功能</span><br>   <span class="hljs-keyword">add </span><span class="hljs-keyword">di, </span>cx      <span class="hljs-comment">;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br>   inc word [ards_nr]      <span class="hljs-comment">;记录ARDS数量</span><br>   cmp ebx, <span class="hljs-number">0</span>      <span class="hljs-comment">;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br>   <span class="hljs-keyword">jnz </span>.e820_mem_get_loop<br><br><span class="hljs-comment">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br>   mov cx, [ards_nr]      <span class="hljs-comment">;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br>   mov ebx, ards_buf <br>   <span class="hljs-keyword">xor </span>edx, edx      <span class="hljs-comment">;edx为最大的内存容量,在此先清0</span><br><span class="hljs-symbol">.find_max_mem_area:</span>      <span class="hljs-comment">;无须判断type是否为1,最大的内存块一定是可被使用</span><br>   mov eax, [ebx]      <span class="hljs-comment">;base_add_low</span><br>   <span class="hljs-keyword">add </span>eax, [ebx+<span class="hljs-number">8</span>]      <span class="hljs-comment">;length_low</span><br>   <span class="hljs-keyword">add </span>ebx, <span class="hljs-number">20</span>      <span class="hljs-comment">;指向缓冲区中下一个ARDS结构</span><br>   cmp edx, eax      <span class="hljs-comment">;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br>   <span class="hljs-keyword">jge </span>.next_ards<br>   mov edx, eax      <span class="hljs-comment">;edx为总内存大小</span><br><span class="hljs-symbol">.next_ards:</span><br>   loop .find_max_mem_area<br>   <span class="hljs-keyword">jmp </span>.mem_get_ok<br><br><span class="hljs-comment">;------  int 15h ax = E801h 获取内存大小,最大支持4G  ------</span><br><span class="hljs-comment">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="hljs-comment">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="hljs-symbol">.e820_failed_so_try_e801:</span><br>   mov ax,<span class="hljs-number">0xe801</span><br>   int <span class="hljs-number">0x15</span><br>   <span class="hljs-keyword">jc </span>.e801_failed_so_try88   <span class="hljs-comment">;若当前e801方法失败,就尝试0x88方法</span><br><br><span class="hljs-comment">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br>   mov cx,<span class="hljs-number">0x400</span>     <span class="hljs-comment">;cx和ax值一样,cx用做乘数</span><br>   <span class="hljs-keyword">mul </span>cx <br>   <span class="hljs-keyword">shl </span>edx,<span class="hljs-number">16</span><br>   <span class="hljs-keyword">and </span>eax,<span class="hljs-number">0x0000FFFF</span><br>   <span class="hljs-keyword">or </span>edx,eax<br>   <span class="hljs-keyword">add </span>edx, <span class="hljs-number">0x100000</span> <span class="hljs-comment">;ax只是15MB,故要加1MB</span><br>   mov esi,edx     <span class="hljs-comment">;先把低15MB的内存容量存入esi寄存器备份</span><br><br><span class="hljs-comment">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br>   <span class="hljs-keyword">xor </span>eax,eax<br>   mov ax,<span class="hljs-keyword">bx</span><br>   mov ecx, <span class="hljs-number">0x10000</span><span class="hljs-comment">;0x10000十进制为64KB</span><br>   <span class="hljs-keyword">mul </span>ecx<span class="hljs-comment">;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br>   <span class="hljs-keyword">add </span>esi,eax<span class="hljs-comment">;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br>   mov edx,esi<span class="hljs-comment">;edx为总内存大小</span><br>   <span class="hljs-keyword">jmp </span>.mem_get_ok<br><br><span class="hljs-comment">;-----------------  int 15h ah = 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="hljs-symbol">.e801_failed_so_try88:</span> <br>   <span class="hljs-comment">;int 15后，ax存入的是以kb为单位的内存容量</span><br>   mov  ah, <span class="hljs-number">0x88</span><br>   int  <span class="hljs-number">0x15</span><br>   <span class="hljs-keyword">jc </span>.error_hlt<br>   <span class="hljs-keyword">and </span>eax,<span class="hljs-number">0x0000FFFF</span><br>      <br>   <span class="hljs-comment">;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br>   mov cx, <span class="hljs-number">0x400</span>     <span class="hljs-comment">;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br>   <span class="hljs-keyword">mul </span>cx<br>   <span class="hljs-keyword">shl </span>edx, <span class="hljs-number">16</span>     <span class="hljs-comment">;把dx移到高16位</span><br>   <span class="hljs-keyword">or </span>edx, eax     <span class="hljs-comment">;把积的低16位组合到edx,为32位的积</span><br>   <span class="hljs-keyword">add </span>edx,<span class="hljs-number">0x100000</span>  <span class="hljs-comment">;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">.mem_get_ok:</span><br>   mov [total_mem_bytes], edx <span class="hljs-comment">;将内存换为byte单位后存入total_mem_bytes处。</span><br><br><br><span class="hljs-comment">;-----------------   准备进入保护模式   -------------------</span><br><span class="hljs-comment">;1 打开A20</span><br><span class="hljs-comment">;2 加载gdt</span><br><span class="hljs-comment">;3 将cr0的pe位置1</span><br><br>   <span class="hljs-comment">;-----------------  打开A20  ----------------</span><br>   in al,<span class="hljs-number">0x92</span><br>   <span class="hljs-keyword">or </span>al,<span class="hljs-number">0000</span>_<span class="hljs-symbol">0010B</span><br>   out <span class="hljs-number">0x92</span>,al<br><br>   <span class="hljs-comment">;-----------------  加载GDT  ----------------</span><br>   lgdt [gdt_ptr]<br><br>   <span class="hljs-comment">;-----------------  cr0第0位置1  ----------------</span><br>   mov eax, cr0<br>   <span class="hljs-keyword">or </span>eax, <span class="hljs-number">0x00000001</span><br>   mov cr0, eax<br><br>   <span class="hljs-keyword">jmp </span>dword SELECTOR_CODE:p_mode_start     <span class="hljs-comment">; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br>     <span class="hljs-comment">; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="hljs-symbol">.error_hlt:</span>      <span class="hljs-comment">;出错则挂起</span><br>   hlt<br><br>[<span class="hljs-keyword">bits </span><span class="hljs-number">32</span>]<br><span class="hljs-symbol">p_mode_start:</span><br>   mov ax, SELECTOR_DATA<br>   mov ds, ax<br>   mov es, ax<br>   mov ss, ax<br>   mov esp,LOADER_STACK_TOP<br>   mov ax, SELECTOR_VIDEO<br>   mov gs, ax<br><br><span class="hljs-comment">; -------------------------   加载kernel  ----------------------</span><br>   mov eax, KERNEL_START_SECTOR        <span class="hljs-comment">; kernel.bin所在的扇区号</span><br>   mov ebx, KERNEL_BIN_BASE_ADDR       <span class="hljs-comment">; 从磁盘读出后，写入到ebx指定的地址</span><br>   mov ecx, <span class="hljs-number">200</span>       <span class="hljs-comment">; 读入的扇区数</span><br><br>   call rd_disk_m_32<br><br>   <span class="hljs-comment">; 创建页目录及页表并初始化页内存位图</span><br>   call setup_page<br><br>   <span class="hljs-comment">;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span><br>   sgdt [gdt_ptr]      <span class="hljs-comment">; 存储到原来gdt所有的位置</span><br><br>   <span class="hljs-comment">;将gdt描述符中视频段描述符中的段基址+0xc0000000</span><br>   mov ebx, [gdt_ptr + <span class="hljs-number">2</span>]  <br>   <span class="hljs-keyword">or </span>dword [ebx + <span class="hljs-number">0x18</span> + <span class="hljs-number">4</span>], <span class="hljs-number">0xc0000000</span>      <span class="hljs-comment">;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span><br>      <span class="hljs-comment">;段描述符的高4字节的最高位是段基址的31~24位</span><br><br>   <span class="hljs-comment">;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span><br>   <span class="hljs-keyword">add </span>dword [gdt_ptr + <span class="hljs-number">2</span>], <span class="hljs-number">0xc0000000</span><br><br>   <span class="hljs-keyword">add </span>esp, <span class="hljs-number">0xc0000000</span>        <span class="hljs-comment">; 将栈指针同样映射到内核地址</span><br><br>   <span class="hljs-comment">; 把页目录地址赋给cr3</span><br>   mov eax, PAGE_DIR_TABLE_POS<br>   mov cr3, eax<br><br>   <span class="hljs-comment">; 打开cr0的pg位(第31位)</span><br>   mov eax, cr0<br>   <span class="hljs-keyword">or </span>eax, <span class="hljs-number">0x80000000</span><br>   mov cr0, eax<br><br>   <span class="hljs-comment">;在开启分页后,用gdt新的地址重新加载</span><br>   lgdt [gdt_ptr]             <span class="hljs-comment">; 重新加载</span><br><br><span class="hljs-comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;  此时不刷新流水线也没问题  ;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="hljs-comment">;由于一直处在32位下,原则上不需要强制刷新,经过实际测试没有以下这两句也没问题.</span><br><span class="hljs-comment">;但以防万一，还是加上啦，免得将来出来莫句奇妙的问题.</span><br>   <span class="hljs-keyword">jmp </span>SELECTOR_CODE:enter_kernel  <span class="hljs-comment">;强制刷新流水线,更新gdt</span><br><span class="hljs-symbol">enter_kernel:</span>    <br><span class="hljs-comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br>   call kernel_init<br>   mov esp, <span class="hljs-number">0xc009f000</span><br>   <span class="hljs-keyword">jmp </span>KERNEL_ENTRY_POINT                 <span class="hljs-comment">; 用地址0x1500访问测试，结果ok</span><br><br><br><span class="hljs-comment">;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------</span><br><span class="hljs-symbol">kernel_init:</span><br>   <span class="hljs-keyword">xor </span>eax, eax<br>   <span class="hljs-keyword">xor </span>ebx, ebx<span class="hljs-comment">;ebx记录程序头表地址</span><br>   <span class="hljs-keyword">xor </span>ecx, ecx<span class="hljs-comment">;cx记录程序头表中的program header数量</span><br>   <span class="hljs-keyword">xor </span>edx, edx<span class="hljs-comment">;dx 记录program header尺寸,即e_phentsize</span><br><br>   mov dx, [KERNEL_BIN_BASE_ADDR + <span class="hljs-number">42</span>]  <span class="hljs-comment">; 偏移文件42字节处的属性是e_phentsize,表示program header大小</span><br>   mov ebx, [KERNEL_BIN_BASE_ADDR + <span class="hljs-number">28</span>]   <span class="hljs-comment">; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量</span><br>  <span class="hljs-comment">; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值</span><br>   <span class="hljs-keyword">add </span>ebx, KERNEL_BIN_BASE_ADDR<br>   mov cx, [KERNEL_BIN_BASE_ADDR + <span class="hljs-number">44</span>]    <span class="hljs-comment">; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header</span><br><span class="hljs-symbol">.each_segment:</span><br>   cmp <span class="hljs-keyword">byte </span>[ebx + <span class="hljs-number">0</span>], PT_NULL  <span class="hljs-comment">; 若p_type等于 PT_NULL,说明此program header未使用。</span><br>   <span class="hljs-keyword">je </span>.PTNULL<br><br>   <span class="hljs-comment">;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)</span><br>   push dword [ebx + <span class="hljs-number">16</span>]  <span class="hljs-comment">; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size</span><br>   mov eax, [ebx + <span class="hljs-number">4</span>]  <span class="hljs-comment">; 距程序头偏移量为4字节的位置是p_offset</span><br>   <span class="hljs-keyword">add </span>eax, KERNEL_BIN_BASE_ADDR  <span class="hljs-comment">; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址</span><br>   push eax  <span class="hljs-comment">; 压入函数memcpy的第二个参数:源地址</span><br>   push dword [ebx + <span class="hljs-number">8</span>]  <span class="hljs-comment">; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址</span><br>   call mem_cpy  <span class="hljs-comment">; 调用mem_cpy完成段复制</span><br>   <span class="hljs-keyword">add </span>esp,<span class="hljs-number">12</span>  <span class="hljs-comment">; 清理栈中压入的三个参数</span><br><span class="hljs-symbol">.PTNULL:</span><br>   <span class="hljs-keyword">add </span>ebx, edx  <span class="hljs-comment">; edx为program header大小,即e_phentsize,在此ebx指向下一个program header </span><br>   loop .each_segment<br>   ret<br><br><span class="hljs-comment">;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------</span><br><span class="hljs-comment">;输入:栈中三个参数(dst,src,size)</span><br><span class="hljs-comment">;输出:无</span><br><span class="hljs-comment">;---------------------------------------------------------</span><br><span class="hljs-symbol">mem_cpy:</span>      <br>   cld<br>   push ebp<br>   mov ebp, esp<br>   push ecx   <span class="hljs-comment">; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份</span><br>   mov edi, [ebp + <span class="hljs-number">8</span>]   <span class="hljs-comment">; dst</span><br>   mov esi, [ebp + <span class="hljs-number">12</span>]   <span class="hljs-comment">; src</span><br>   mov ecx, [ebp + <span class="hljs-number">16</span>]   <span class="hljs-comment">; size</span><br>   rep movsb   <span class="hljs-comment">; 逐字节拷贝</span><br><br>   <span class="hljs-comment">;恢复环境</span><br>   pop ecx<br>   pop ebp<br>   ret<br><br><br><span class="hljs-comment">;-------------   创建页目录及页表   ---------------</span><br><span class="hljs-symbol">setup_page:</span><br><span class="hljs-comment">;先把页目录占用的空间逐字节清0</span><br>   mov ecx, <span class="hljs-number">4096</span><br>   mov esi, <span class="hljs-number">0</span><br><span class="hljs-symbol">.clear_page_dir:</span><br>   mov <span class="hljs-keyword">byte </span>[PAGE_DIR_TABLE_POS + esi], <span class="hljs-number">0</span><br>   inc esi<br>   loop .clear_page_dir<br><br><span class="hljs-comment">;开始创建页目录项(PDE)</span><br><span class="hljs-symbol">.create_pde:</span>     <span class="hljs-comment">; 创建Page Directory Entry</span><br>   mov eax, PAGE_DIR_TABLE_POS<br>   <span class="hljs-keyword">add </span>eax, <span class="hljs-number">0x1000</span>      <span class="hljs-comment">; 此时eax为第一个页表的位置及属性</span><br>   mov ebx, eax     <span class="hljs-comment">; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span><br><br><span class="hljs-comment">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span><br><span class="hljs-comment">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span><br><span class="hljs-comment">;   这是为将地址映射为内核地址做准备</span><br>   <span class="hljs-keyword">or </span>eax, PG_US_U <span class="hljs-title">| PG_RW_W |</span> PG_P     <span class="hljs-comment">; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span><br>   mov [PAGE_DIR_TABLE_POS + <span class="hljs-number">0x0</span>], eax       <span class="hljs-comment">; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(3)</span><br>   mov [PAGE_DIR_TABLE_POS + <span class="hljs-number">0xc00</span>], eax     <span class="hljs-comment">; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span><br>     <span class="hljs-comment">; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span><br>   <span class="hljs-keyword">sub </span>eax, <span class="hljs-number">0x1000</span><br>   mov [PAGE_DIR_TABLE_POS + <span class="hljs-number">4092</span>], eax     <span class="hljs-comment">; 使最后一个目录项指向页目录表自己的地址</span><br><br><span class="hljs-comment">;下面创建页表项(PTE)</span><br>   mov ecx, <span class="hljs-number">256</span>     <span class="hljs-comment">; 1M低端内存 / 每页大小4k = 256</span><br>   mov esi, <span class="hljs-number">0</span><br>   mov edx, PG_US_U <span class="hljs-title">| PG_RW_W |</span> PG_P     <span class="hljs-comment">; 属性为7,US=1,RW=1,P=1</span><br><span class="hljs-symbol">.create_pte:</span>     <span class="hljs-comment">; 创建Page Table Entry</span><br>   mov [ebx+esi*<span class="hljs-number">4</span>],edx     <span class="hljs-comment">; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span><br>   <span class="hljs-keyword">add </span>edx,<span class="hljs-number">4096</span><br>   inc esi<br>   loop .create_pte<br><br><span class="hljs-comment">;创建内核其它页表的PDE</span><br>   mov eax, PAGE_DIR_TABLE_POS<br>   <span class="hljs-keyword">add </span>eax, <span class="hljs-number">0x2000</span>      <span class="hljs-comment">; 此时eax为第二个页表的位置</span><br>   <span class="hljs-keyword">or </span>eax, PG_US_U <span class="hljs-title">| PG_RW_W |</span> PG_P  <span class="hljs-comment">; 页目录项的属性RW和P位为1,US为0</span><br>   mov ebx, PAGE_DIR_TABLE_POS<br>   mov ecx, <span class="hljs-number">254</span>     <span class="hljs-comment">; 范围为第769~1022的所有目录项数量</span><br>   mov esi, <span class="hljs-number">769</span><br><span class="hljs-symbol">.create_kernel_pde:</span><br>   mov [ebx+esi*<span class="hljs-number">4</span>], eax<br>   inc esi<br>   <span class="hljs-keyword">add </span>eax, <span class="hljs-number">0x1000</span><br>   loop .create_kernel_pde<br>   ret<br><br><br><span class="hljs-comment">;-------------------------------------------------------------------------------</span><br>   <span class="hljs-comment">;功能:读取硬盘n个扇区</span><br><span class="hljs-symbol">rd_disk_m_32:</span>   <br><span class="hljs-comment">;-------------------------------------------------------------------------------</span><br> <span class="hljs-comment">; eax=LBA扇区号</span><br> <span class="hljs-comment">; ebx=将数据写入的内存地址</span><br> <span class="hljs-comment">; ecx=读入的扇区数</span><br>      mov esi,eax   <span class="hljs-comment">; 备份eax</span><br>      mov <span class="hljs-keyword">di,cx</span>   <span class="hljs-comment">; 备份扇区数到di</span><br><span class="hljs-comment">;读写硬盘:</span><br><span class="hljs-comment">;第1步：设置要读取的扇区数</span><br>      mov dx,<span class="hljs-number">0x1f2</span><br>      mov al,cl<br>      out dx,al            <span class="hljs-comment">;读取的扇区数</span><br><br>      mov eax,esi   <span class="hljs-comment">;恢复ax</span><br><br><span class="hljs-comment">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span><br><br>      <span class="hljs-comment">;LBA地址7~0位写入端口0x1f3</span><br>      mov dx,<span class="hljs-number">0x1f3</span>                       <br>      out dx,al                          <br><br>      <span class="hljs-comment">;LBA地址15~8位写入端口0x1f4</span><br>      mov cl,<span class="hljs-number">8</span><br>      <span class="hljs-keyword">shr </span>eax,cl<br>      mov dx,<span class="hljs-number">0x1f4</span><br>      out dx,al<br><br>      <span class="hljs-comment">;LBA地址23~16位写入端口0x1f5</span><br>      <span class="hljs-keyword">shr </span>eax,cl<br>      mov dx,<span class="hljs-number">0x1f5</span><br>      out dx,al<br><br>      <span class="hljs-keyword">shr </span>eax,cl<br>      <span class="hljs-keyword">and </span>al,<span class="hljs-number">0x0f</span>   <span class="hljs-comment">;lba第24~27位</span><br>      <span class="hljs-keyword">or </span>al,<span class="hljs-number">0xe0</span>   <span class="hljs-comment">; 设置7～4位为1110,表示lba模式</span><br>      mov dx,<span class="hljs-number">0x1f6</span><br>      out dx,al<br><br><span class="hljs-comment">;第3步：向0x1f7端口写入读命令，0x20 </span><br>      mov dx,<span class="hljs-number">0x1f7</span><br>      mov al,<span class="hljs-number">0x20</span>                        <br>      out dx,al<br><br><span class="hljs-comment">;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来</span><br><br><span class="hljs-comment">;第4步：检测硬盘状态</span><br><span class="hljs-symbol">  .not_ready:</span>   <span class="hljs-comment">;测试0x1f7端口(status寄存器)的的BSY位</span><br>      <span class="hljs-comment">;同一端口,写时表示写入命令字,读时表示读入硬盘状态</span><br>      <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>      in al,dx<br>      <span class="hljs-keyword">and </span>al,<span class="hljs-number">0x88</span>   <span class="hljs-comment">;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙</span><br>      cmp al,<span class="hljs-number">0x08</span><br>      <span class="hljs-keyword">jnz </span>.not_ready   <span class="hljs-comment">;若未准备好,继续等。</span><br><br><span class="hljs-comment">;第5步：从0x1f0端口读数据</span><br>      mov ax, <span class="hljs-keyword">di</span>   <span class="hljs-comment">;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,</span><br>   <span class="hljs-comment">;在此先用这种方法,在后面内容会用到insw和outsw等</span><br><br>      mov dx, <span class="hljs-number">256</span>   <span class="hljs-comment">;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256</span><br>      <span class="hljs-keyword">mul </span>dx<br>      mov cx, ax   <br>      mov dx, <span class="hljs-number">0x1f0</span><br><span class="hljs-symbol">  .go_on_read:</span><br>      in ax,dx<br>      mov [ebx], ax<br>      <span class="hljs-keyword">add </span>ebx, <span class="hljs-number">2</span><br>  <span class="hljs-comment">; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。</span><br>  <span class="hljs-comment">; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，</span><br>  <span class="hljs-comment">; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，</span><br>  <span class="hljs-comment">; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，</span><br>  <span class="hljs-comment">; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,</span><br>  <span class="hljs-comment">; 故程序出会错,不知道会跑到哪里去。</span><br>  <span class="hljs-comment">; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。</span><br>  <span class="hljs-comment">; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.</span><br>  <span class="hljs-comment">; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,</span><br>  <span class="hljs-comment">; 也会认为要执行的指令是32位.</span><br>  <span class="hljs-comment">; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，</span><br>  <span class="hljs-comment">; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67，</span><br>  <span class="hljs-comment">; 临时改变当前cpu模式到另外的模式下.</span><br>  <span class="hljs-comment">; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.</span><br>  <span class="hljs-comment">; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.</span><br>  <span class="hljs-comment">; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址</span><br>  <span class="hljs-comment">; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.</span><br><br>      loop .go_on_read<br>      ret<br><br></code></pre></td></tr></table></figure><h3 id="boot"><a class="markdownIt-Anchor" href="#boot"></a> boot：</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">;一一一一一一loader和 kernel<br><br>LOADER_BASE_ADDR equ <span class="hljs-number">0x900</span> <br>LOADER_START_SECTOR equ  <span class="hljs-number">0x2</span> <br> <br>;一一一一一一－ gdt 描述符属性 一一一一一一 <br>DESC_G_4K equ <span class="hljs-number">1000</span>_0000_0000_0000_0000_0000b   ;G位为第<span class="hljs-number">23</span>位,置<span class="hljs-number">1</span>代表段界限为单位<span class="hljs-number">4</span>k<br>DESC_D_32 equ <span class="hljs-number">1</span>_00_0000_0000_0000_0000_0000b ;D/B 宇段,第<span class="hljs-number">22</span>位<br>;对代码段来说是D位,置<span class="hljs-number">1</span>表示指令中的有效地址及<br>;操作数是<span class="hljs-number">32</span>位，指令有效地址用EIP寄存器。<br><br>DESC_L equ <span class="hljs-number">0</span>_0000_0000_0000_0000_0000_0000b ; <span class="hljs-number">64</span>位代码标记,我们在<span class="hljs-number">32</span>位CPU下编程，<br>;标记为<span class="hljs-number">0</span>便可<br>DESC_AVL equ <span class="hljs-number">0</span>_0000_0000_0000_0000_0000b ;CPU不用此位，暂置为<br>DESC_LIMIT_CODE2 equ <span class="hljs-number">1111</span>_0000_0000_0000_0000b  ;段界限<span class="hljs-number">16</span>~<span class="hljs-number">19</span>位<br>;全设为<span class="hljs-number">1</span>，它在下面代码中会与段界限的<span class="hljs-number">0</span>~<span class="hljs-number">15</span>位拼成<span class="hljs-number">0xFFFF</span>，<br>;<span class="hljs-number">0xFFFF</span>*<span class="hljs-number">4</span>k等于<span class="hljs-number">4</span>G，段基址设为<span class="hljs-number">0</span>，采用平坦模型<br><br>DESC_LIMIT_DATA2 equ DESC_LIMIT_CODE2 ;<br>DESC_LIMIT_VIDEO2 equ <span class="hljs-number">0000</span>_0000_0000_0000_0000b ;<br>DESC_P equ <span class="hljs-number">1</span>_000_0000_0000_0000b   ;第<span class="hljs-number">15</span>位，表示段存在<br>DESC_DPL_0 equ <span class="hljs-number">00</span>_0_0000_0000_0000b ;DPL在<span class="hljs-number">13</span>~<span class="hljs-number">14</span>位 <span class="hljs-number">0</span>为最高特权级<br>DESC_DPL_1 equ <span class="hljs-number">01</span>_0_0000_0000_0000b <br>DESC_DPL_2 equ <span class="hljs-number">10</span>_0_0000_0000_0000b <br>DESC_DPL_3 equ <span class="hljs-number">11</span>_0_0000_0000_0000b <br>DESC_S_CODE equ <span class="hljs-number">1</span>_0000_0000_0000b ; S为<span class="hljs-number">0</span>时表示系统段， S为<span class="hljs-number">1</span>时表示非系统段。<br>DESC_S_DATA equ DESC_S_CODE <br>DESC_S_sys equ <span class="hljs-number">0</span>_0000_0000_0000b <br>DESC_TYPE_CODE equ <span class="hljs-number">1000</span>_0000_0000b ;x=<span class="hljs-number">1</span>，c=<span class="hljs-number">0</span>, r=<span class="hljs-number">0</span>,a=<span class="hljs-number">0</span> ，即代码段是可执行的，非一致<br>;性，不可读，己访问位a清<span class="hljs-number">0</span> 配合S使用<br>DESC_TYPE_DATA equ <span class="hljs-number">0010</span>_0000_0000b ;<br>;x=<span class="hljs-number">0</span>,e=<span class="hljs-number">0</span>,w=<span class="hljs-number">1</span>,a=<span class="hljs-number">0</span> 数据段是不可执行的，向上扩展的，可写，己访问位a清<span class="hljs-number">0</span>。<br><br>DESC_CODE_HIGH4 equ (<span class="hljs-number">0x00</span> &lt;&lt; <span class="hljs-number">24</span>) + DESC_G_4K + DESC_D_32 + \<br>DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + \<br>DESC_P + DESC_DPL_0 + DESC_S_CODE +\<br>DESC_TYPE_CODE + <span class="hljs-number">0x00</span> <br><br>DESC_DATA_HIGH4 equ (<span class="hljs-number">0x00</span> &lt;&lt; <span class="hljs-number">24</span>) + DESC_G_4K + DESC_D_32 +\<br>DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + \<br>DESC_P + DESC_DPL_0 + DESC_S_DATA + \<br>DESC_TYPE_DATA + <span class="hljs-number">0x00</span><br><br>DESC_VIDEO_HIGH4 equ (<span class="hljs-number">0x00</span> &lt;&lt; <span class="hljs-number">24</span>) + DESC_G_4K + DESC_D_32 +\<br>DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + \<br>DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + <span class="hljs-number">0x0B</span>   ;注意书上这里写的是<span class="hljs-number">0x00</span>，写错了<br>;显存起始地址应该是<span class="hljs-number">0xB8000</span><br><br> <br>;一一一一一一 选择子属性一一一一一一一<br>RPL0 equ <span class="hljs-number">00</span>b <br>RPL1 equ <span class="hljs-number">01</span>b <br>RPL2 equ <span class="hljs-number">10</span>b <br>RPL3 equ <span class="hljs-number">11</span>b <br>TI_GDT equ <span class="hljs-number">000</span>b <br>TI_LDT equ <span class="hljs-number">100</span>b<br><br>;<span class="hljs-comment">-------------   页表配置   ----------------</span><br>PAGE_DIR_TABLE_POS equ <span class="hljs-number">0x100000</span><br>;<span class="hljs-comment">----------------   页表相关属性    --------------</span><br>PG_P  equ   <span class="hljs-number">1</span>b<br>PG_RW_R equ  <span class="hljs-number">00</span>b <br>PG_RW_W equ  <span class="hljs-number">10</span>b <br>PG_US_S equ  <span class="hljs-number">000</span>b <br>PG_US_U equ  <span class="hljs-number">100</span>b <br><br><br>KERNEL_BIN_BASE_ADDR equ <span class="hljs-number">0x70000</span><br>KERNEL_START_SECTOR equ <span class="hljs-number">0x9</span><br>KERNEL_ENTRY_POINT equ <span class="hljs-number">0xc0001500</span><br>;<span class="hljs-comment">-------------  program type 定义   --------------</span><br>PT_NULL equ <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="mainc"><a class="markdownIt-Anchor" href="#mainc"></a> main.c</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//main.c</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写在后面"><a class="markdownIt-Anchor" href="#写在后面"></a> 写在后面</h2><p>写到这里的时候已经是12日傍晚了，又花费了一天与loader进行搏斗，幸好最终拿到了胜利，否则再拖可能就把我胸口的火焰拖没了。这一章节内容实在繁多，期间经过了无数个调试失败，一度想要放弃，感谢老天爷在我每每将近放弃的时候让我调试成功！歇几天休息一下，调整好状态再大踏步进入第六章的学习。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>真象还原</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第四章 进入保护模式，理论的抽象轰炸</title>
    <link href="/2022/07/09/os(4)/"/>
    <url>/2022/07/09/os(4)/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-进入保护模式理论的抽象轰炸"><a class="markdownIt-Anchor" href="#第四章-进入保护模式理论的抽象轰炸"></a> 第四章 进入保护模式，理论的抽象轰炸</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>今天已经来到了9日，因为昨日状态不是很好，没有在往下进行，而是把前今天的内容做成博客发表上来，也是给自己一个复习的机会。今天争取拿下第四章！</p><h2 id="进入正文"><a class="markdownIt-Anchor" href="#进入正文"></a> 进入正文</h2><p>咱们还是先简单翻过前面的理论知识，记住里面的一些名词和简单概念，然后直接来到实战部分。前面说了，不要忘记主线任务，咱们之前已经完成了loader的基本实现，但是这一切都建立在实模式之下，我们需要进入保护模式。</p><h3 id="mbrs"><a class="markdownIt-Anchor" href="#mbrs"></a> mbr.S</h3><p>首先是修改了MBR，</p><figure class="highlight x86asm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">1</span><span class="hljs-comment">; 待读入内存的扇区数</span><br><span class="hljs-keyword">call</span> rd_disk_m_16<span class="hljs-comment">;</span><br><br>修改后代码<br><span class="hljs-comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">4</span><span class="hljs-comment">; 改成待读入4个扇区， loader.bin 超过了 512 字节</span><br><span class="hljs-keyword">call</span> rd_disk_m_16<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="bootinc"><a class="markdownIt-Anchor" href="#bootinc"></a> boot.inc</h3><p>然后对boot.inc进行一个补充，配置好loader以便后面在loader中进入保护模式。这里贴上boot.inc的代码。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;一一一一一一loader和 kernel</span><br><br>LOADER_BASE_ADDR <span class="hljs-built_in">equ</span> <span class="hljs-number">0x900</span> <br>LOADER_START_SECTOR <span class="hljs-built_in">equ</span>  <span class="hljs-number">0x2</span> <br> <br><span class="hljs-comment">;一一一一一一－ gdt 描述符属性 一一一一一一 </span><br>DESC_G_4K <span class="hljs-built_in">equ</span> <span class="hljs-number">1000_0000_0000_0000_0000_0000b</span>   <span class="hljs-comment">;G位为第23位,置1代</span><br><span class="hljs-comment">;表</span><br><span class="hljs-comment">;段界限为单位4k</span><br>DESC_D_32 <span class="hljs-built_in">equ</span> <span class="hljs-number">1_00_0000_0000_0000_0000_0000b</span> <span class="hljs-comment">;D/B 宇段,第22位</span><br><span class="hljs-comment">;对代码段来说是D位,置1表示指令中的有效地址及</span><br><span class="hljs-comment">;操作数是32位，指令有效地址用EIP寄存器。</span><br><br>DESC_L <span class="hljs-built_in">equ</span> <span class="hljs-number">0_0000_0000_0000_0000_0000_0000b</span> <span class="hljs-comment">; 64位代码标记,我们在32位CPU下编程，</span><br><span class="hljs-comment">;标记为0便可</span><br>DESC_AVL <span class="hljs-built_in">equ</span> <span class="hljs-number">0_0000_0000_0000_0000_0000b</span> <span class="hljs-comment">;CPU不用此位，暂置为</span><br>DESC_LIMIT_CODE2 <span class="hljs-built_in">equ</span> <span class="hljs-number">1111_0000_0000_0000_0000b</span>  <span class="hljs-comment">;段界限16~19位</span><br><span class="hljs-comment">;全设为1，它在下面代码中会与段界限的0~15位拼成0xFFFF，</span><br><span class="hljs-comment">;0xFFFF*4k等于4G，段基址设为0，采用平坦模型</span><br><br>DESC_LIMIT_DATA2 <span class="hljs-built_in">equ</span> DESC_LIMIT_CODE2 <span class="hljs-comment">;</span><br>DESC_LIMIT_VIDEO2 <span class="hljs-built_in">equ</span> <span class="hljs-number">0000_0000_0000_0000_0000b</span> <span class="hljs-comment">;</span><br>DESC_P <span class="hljs-built_in">equ</span> <span class="hljs-number">1_000_0000_0000_0000b</span>   <span class="hljs-comment">;第15位，表示段存在</span><br>DESC_DPL_0 <span class="hljs-built_in">equ</span> <span class="hljs-number">00_0_0000_0000_0000b</span> <span class="hljs-comment">;DPL在13~14位 0为最高特权级</span><br>DESC_DPL_1 <span class="hljs-built_in">equ</span> <span class="hljs-number">01_0_0000_0000_0000b</span> <br>DESC_DPL_2 <span class="hljs-built_in">equ</span> <span class="hljs-number">10_0_0000_0000_0000b</span> <br>DESC_DPL_3 <span class="hljs-built_in">equ</span> <span class="hljs-number">11_0_0000_0000_0000b</span> <br>DESC_S_CODE <span class="hljs-built_in">equ</span> <span class="hljs-number">1_0000_0000_0000b</span> <span class="hljs-comment">; S为0时表示系统段， S为1时表示非系统段。</span><br>DESC_S_DATA <span class="hljs-built_in">equ</span> DESC_S_CODE <br>DESC_S_sys <span class="hljs-built_in">equ</span> <span class="hljs-number">0_0000_0000_0000b</span> <br>DESC_TYPE_CODE <span class="hljs-built_in">equ</span> <span class="hljs-number">1000_0000_0000b</span> <span class="hljs-comment">;x=1，c=0, r=0,a=0 ，即代码段是可执行的，非一致</span><br><span class="hljs-comment">;性，不可读，己访问位a清0 配合S使用</span><br>DESC_TYPE_DATA <span class="hljs-built_in">equ</span> <span class="hljs-number">0010_0000_0000b</span> <span class="hljs-comment">;</span><br><span class="hljs-comment">;x=0,e=0,w=1,a=0 数据段是不可执行的，向上扩展的，可写，己访问位a清0。</span><br><br>DESC_CODE_HIGH4 <span class="hljs-built_in">equ</span> (<span class="hljs-number">0x00</span> &lt;&lt; <span class="hljs-number">24</span>) + DESC_G_4K + DESC_D_32 + \<br>DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + \<br>DESC_P + DESC_DPL_0 + DESC_S_CODE +\<br>DESC_TYPE_CODE + <span class="hljs-number">0x00</span> <br><br>DESC_DATA_HIGH4 <span class="hljs-built_in">equ</span> (<span class="hljs-number">0x00</span> &lt;&lt; <span class="hljs-number">24</span>) + DESC_G_4K + DESC_D_32 +\<br>DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + \<br>DESC_P + DESC_DPL_0 + DESC_S_DATA + \<br>DESC_TYPE_DATA + <span class="hljs-number">0x00</span><br><br>DESC_VIDEO_HIGH4 <span class="hljs-built_in">equ</span> (<span class="hljs-number">0x00</span> &lt;&lt; <span class="hljs-number">24</span>) + DESC_G_4K + DESC_D_32 +\<br>DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + \<br>DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + <span class="hljs-number">0x0B</span>   <span class="hljs-comment">;注意书上这里写的是0x00，写错了</span><br><span class="hljs-comment">;显存起始地址应该是0xB8000</span><br><br> <br><span class="hljs-comment">;一一一一一一 选择子属性一一一一一一一</span><br>RPL0 <span class="hljs-built_in">equ</span> <span class="hljs-number">00b</span> <br>RPL1 <span class="hljs-built_in">equ</span> <span class="hljs-number">01b</span> <br>RPL2 <span class="hljs-built_in">equ</span> <span class="hljs-number">10b</span> <br>RPL3 <span class="hljs-built_in">equ</span> <span class="hljs-number">11b</span> <br>TI_GDT <span class="hljs-built_in">equ</span> <span class="hljs-number">000b</span> <br>TI_LDT <span class="hljs-built_in">equ</span> <span class="hljs-number">100b</span><br></code></pre></td></tr></table></figure><p>注释比较详细了，注意这里都是以宏的形式编写的，说白了就是给nasm编译器看的，我觉得这里只需了解其背后隐含的理论就好，不必过于纠结代码形式。</p><h3 id="loaders"><a class="markdownIt-Anchor" href="#loaders"></a> loader.S</h3><p>然后就要上正菜了，改一下loader。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;------------------------</span><br><span class="hljs-meta">%include</span> <span class="hljs-string">&quot;boot.inc&quot;</span> <br><span class="hljs-meta">section</span> loader vstart=LOADER_BASE_ADDR <br>LOADER_STACK_TOP <span class="hljs-built_in">equ</span> LOADER_BASE_ADDR  <span class="hljs-comment">;相同内存地址，地址之下便是栈</span><br><span class="hljs-keyword">jmp</span> loader_start <br><br><span class="hljs-comment">;构建 gdt 及其内部的描述符</span><br><span class="hljs-symbol">GDT_BASE:</span> <span class="hljs-built_in">dd</span> <span class="hljs-number">0x00000000</span>       <span class="hljs-comment">;第0个段描述符不可用</span><br><span class="hljs-built_in">dd</span> <span class="hljs-number">0x00000000</span>  <br><span class="hljs-symbol"></span><br><span class="hljs-symbol">CODE_DESC:</span> <span class="hljs-built_in">dd</span> <span class="hljs-number">0x0000FFFF</span>   <span class="hljs-comment">;代码段描述符</span><br> <span class="hljs-built_in">dd</span> DESC_CODE_HIGH4 <br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">DATA_STACK_DESC:</span> <span class="hljs-built_in">dd</span> <span class="hljs-number">0x0000FFFF</span> <span class="hljs-comment">;栈段描述符 栈段和数据段共用一个描述符 均向上扩展</span><br> <span class="hljs-built_in">dd</span> DESC_DATA_HIGH4  <br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">VIDEO_DESC:</span> <span class="hljs-built_in">dd</span> <span class="hljs-number">0x80000007</span>   <span class="hljs-comment">; limit=(0xbffff-0xb8000)/4k=0x7  故段界限为7</span><br><span class="hljs-built_in">dd</span>  DESC_VIDEO_HIGH4  <span class="hljs-comment">;此时dpl为0</span><br> <br>GDT_SIZE <span class="hljs-built_in">equ</span> $ - GDT_BASE <span class="hljs-comment">; 先是通过地址差来获得 GDT的大小，进而用 GDT大小减1得到了段界限</span><br>GDT_LIMIT <span class="hljs-built_in">equ</span> GDT_SIZE - <span class="hljs-number">1</span>   <span class="hljs-comment">;用于构建GDTR的段界限</span><br><span class="hljs-built_in">times</span> <span class="hljs-number">60</span> <span class="hljs-built_in">dq</span> <span class="hljs-number">0</span> <span class="hljs-comment">;此处预留 60 个描述符的空位</span><br><br><span class="hljs-comment">;以下是构建代码段、数据段、显存段选择子</span><br>SELECTOR_CODE <span class="hljs-built_in">equ</span> (<span class="hljs-number">0x0001</span> &lt;&lt; <span class="hljs-number">3</span>) + TI_GDT + RPL0 <br><span class="hljs-comment">;相当于[(CODE_DESC - GDT_BASE) /8 ]&lt;&lt;3+ TI_GDT + RPL0 </span><br><span class="hljs-comment">;内存地址的编号是一个存储单元8比特，这里CODE_DESC - GDT_BASE应该等于8</span><br><span class="hljs-comment">;书里的备注应该写掉了&quot;&lt;&lt;3&quot;</span><br>SELECTOR_DATA <span class="hljs-built_in">equ</span> (<span class="hljs-number">0x0002</span>&lt;&lt; <span class="hljs-number">3</span>) + TI_GDT + RPL0 <br>SELECTOR_VIDEO <span class="hljs-built_in">equ</span> (<span class="hljs-number">0x0003</span> &lt;&lt; <span class="hljs-number">3</span>) + TI_GDT + RPL0 <br><br><span class="hljs-comment">;以下是 gdt 的指针即GDTR，前2字节是gdt界限，后4字节是gdt起始地址 后面代码使用lgdt指令时会用上</span><br>gdt_ptr <span class="hljs-built_in">dw</span> GDT_LIMIT <br><span class="hljs-built_in">dd</span> GDT_BASE <br><br> loadermsg <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;2 loader in real.&#x27;</span> <br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> loader_start:</span> <br> <br><span class="hljs-comment">;------------------------------------------------------------</span><br><span class="hljs-comment">; INT 0x10 功能号： 0x13 功能描述：打印字符串</span><br><span class="hljs-comment">;------------------------------------------------------------</span><br><span class="hljs-comment">;输入：</span><br><span class="hljs-comment">;AH 子功能号＝13H</span><br><span class="hljs-comment">;BH ＝页码</span><br><span class="hljs-comment">;BL ＝属性（若 AL=OOH OlH)</span><br><span class="hljs-comment">;CX ＝字符串长度</span><br><span class="hljs-comment">; (DH DL ）＝坐标｛行、列）</span><br><span class="hljs-comment">;ES:BP＝字符串地址</span><br><span class="hljs-comment">;AL＝显示输出方式</span><br><span class="hljs-comment">; 一一字符串中只含显示字符，其显示属性在 BL</span><br><span class="hljs-comment">;显示后，光标位置不变</span><br><span class="hljs-comment">; 一一字符串中只含显示字符，其显示属性在 BL</span><br><span class="hljs-comment">;显示后，光标位置改变</span><br><span class="hljs-comment">; 一一字符事中含显示字符和显示属性。显示后，光标位置不变</span><br><span class="hljs-comment">; 一一字符串中含显示字符和显示属性。显示后，光标位置改变</span><br><span class="hljs-comment">;无返回值</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, LOADER_BASE_ADDR <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bp</span>, loadermsg <span class="hljs-comment">; ES:BP ＝字符串地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">17</span> <span class="hljs-comment">; cx ＝字符串长度</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0x1301</span> <span class="hljs-comment">; AH = 13, AL = 01h </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">0x001f</span> <span class="hljs-comment">;页号为0(BH = 0）蓝底粉红字（ BL = 1fh) </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1800</span>  <span class="hljs-comment">;  dh=0x18 十进制为24,代表行数；dl=0x00 表示列数。使用显存的文本模式下，一共25行，所以2 loader in real 会出现在屏幕最后一行</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span> <span class="hljs-comment">; 10h号中断 由于AH=0x13，所以该BIOS中断后会执行打印字符串的中断处理程序。</span><br> <br><span class="hljs-comment">; 一一一一一一一一一一 准备进入保护模式 一一一一一一一一一一一一一一－</span><br><span class="hljs-comment">;1 打开 A20</span><br><span class="hljs-comment">;2 加载 gdt</span><br><span class="hljs-comment">;3 将cr0 的 pe 位置1 </span><br><br><span class="hljs-comment">;一一一一一一一－打开 A20 一一一一一</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x92</span><br><span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0000_0010B</span> <br><span class="hljs-keyword">out</span> <span class="hljs-number">0x92</span>,<span class="hljs-built_in">al</span> <br> <br><span class="hljs-comment">;一一一一一一一一加载 GDT (也就是设置好gdtr，gdtr记录着gdt的起始地址)一一一一一一一－</span><br><span class="hljs-keyword">lgdt</span> [gdt_ptr ] <br><br><span class="hljs-comment">;一一一一一一一一 cr0位置1 一一一一一一一－</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">cr0</span> <br><span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x00000001</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr0</span>, <span class="hljs-built_in">eax</span> <br><br><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">dword</span> SELECTOR_CODE:p_mode_start  <span class="hljs-comment">;刷新流水线</span><br><br>[<span class="hljs-meta">bits</span> <span class="hljs-number">32</span>] <br><span class="hljs-symbol">p_mode_start:</span> <br><span class="hljs-comment">;;;;用选择子初始化段寄存器</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, SELECTOR_DATA <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">ax</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">ax</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">ax</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, LOADER_STACK_TOP <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, SELECTOR_VIDEO <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span> <br><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0xA0</span>], <span class="hljs-string">&#x27;P&#x27;</span> <br> <br><span class="hljs-keyword">jmp</span> $<br></code></pre></td></tr></table></figure><p>然后编译运行，输入info gdt发现gdt顺利加载成功了。</p><h2 id="写在后面"><a class="markdownIt-Anchor" href="#写在后面"></a> 写在后面</h2><p>这一章真是遇到了很大的阻力，需要静下心来一行行地啃汇编代码，同时还需要不断学习理论知识，现在已经是9日的21点了，虽然代码过了一遍但还是有许多模棱两可的地方，随着后面章节的进行还是需要回看。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>真象还原</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章 让MBR直接操作硬盘，硬件深似海</title>
    <link href="/2022/07/08/os(3)/"/>
    <url>/2022/07/08/os(3)/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-让mbr直接操作硬盘硬件深似海"><a class="markdownIt-Anchor" href="#第三章-让mbr直接操作硬盘硬件深似海"></a> 第三章 让MBR直接操作硬盘，硬件深似海</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>7月7日，这一章的概念实在繁多，加上自己也没有汇编的基础，只能硬着头皮攻，加上晚上有学生会主席的竞选，心烦意乱，不过为了完成日更的目标，还是要尽力去做。面对压力时也不要被负能量击溃，我也始终保持着寻找乐趣的心态去学习、阅读。</p><h2 id="进入正题"><a class="markdownIt-Anchor" href="#进入正题"></a> 进入正题</h2><p>本章一上来讲述了许多晦涩难懂的概念，涉及到了一些汇编的知识，也讲述了一些NASM编译器的使用方法。我在初读这些知识的时候实在无心仔细研究，但是在进行到后面章节的时候发现这些前缀知识是必不可少的。我建议读者在初读的时候如果实在烦躁，可以适当跳过一些内容，等到后面进行编程的时候遇到不会的点再回过头来看，切忌在理论知识的重压下失去信心从而放弃。</p><p>然后咱们还是继续主线任务，上一章节我们完成了一个简单MBR编写，并且成功运行在了bochs上，但是需要注意的是这时我们的输出是建立在软件的基础上的，我们最终要实现在显卡上执行任务，首先从修改mbr.S的输出打印部分开始。这里源码我在这里粘出来吧。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; mbr.S</span><br><br><span class="hljs-comment">; 主引导程序</span><br><span class="hljs-comment">; --------------------------------------------------</span><br><br><span class="hljs-meta">SECTION</span> MBR vstart=<span class="hljs-number">0x7c00</span> <span class="hljs-comment">; 把起始地址编译为 0x7c00</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">cs</span>     <span class="hljs-comment">; cs 代码段寄存器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">ax</span>     <span class="hljs-comment">; dx 数据段寄存器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">ax</span>     <span class="hljs-comment">; es 附加段寄存器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">ax</span>     <span class="hljs-comment">; ss 堆栈段寄存器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">fs</span>, <span class="hljs-built_in">ax</span>     <span class="hljs-comment">; fs 80386 后添加的寄存器，无全称</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x7c00</span> <span class="hljs-comment">; sp 堆栈指针寄存器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xb800</span> <span class="hljs-comment">;</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;</span><br><br><span class="hljs-comment">; 清屏</span><br><span class="hljs-comment">; --------------------------------------------------</span><br><span class="hljs-comment">; INT 0x10    功能号: 0x06    功能描述：上卷窗口</span><br><span class="hljs-comment">; --------------------------------------------------</span><br><span class="hljs-comment">; 输入：</span><br><span class="hljs-comment">; AH 功能号 = 0x06</span><br><span class="hljs-comment">; AL = 上卷的行数(如果为0，表示全部)</span><br><span class="hljs-comment">; BH = 上卷行属性</span><br><span class="hljs-comment">; (CL, CH) = 窗口左上角的 (X, Y) 位置</span><br><span class="hljs-comment">; (DL, DH) = 窗口右下角的 (X, Y) 位置</span><br><span class="hljs-comment">; 无返回值:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0x600</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">0x700</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x184f</span> <span class="hljs-comment">; 右下角: (80, 25)</span><br>                   <span class="hljs-comment">; VGA 文本模式种，一行只能容纳 80 个字符，共 25 行</span><br>                   <span class="hljs-comment">; 下标从 0 开始，所以 0x18=24, 0x4f=79</span><br>        <br>    <span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span>       <span class="hljs-comment">; int 0x10</span><br><span class="hljs-comment">;;;;;;;;输出背景色绿色，前景色红色，并且跳动的字符串;;;;;;;;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x00</span>], <span class="hljs-string">&#x27;1&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x01</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x02</span>], <span class="hljs-string">&#x27; &#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x03</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x04</span>], <span class="hljs-string">&#x27;M&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x05</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x06</span>], <span class="hljs-string">&#x27;B&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x07</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x08</span>], <span class="hljs-string">&#x27;R&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x09</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><span class="hljs-comment">;;;;;;;;;;;;;;;;;;;;;;打印字符串结束;;;;;;;;;;;;;;;;</span><br><span class="hljs-keyword">jmp</span> $<span class="hljs-comment">;     程序悬停在此</span><br><br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$)   <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>,<span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure><p>后面介绍了bochs的调试方法，等后面遇到不懂得知识时回看也不迟。当然，512字节的MBR是没法满足为内核准备好环境的功能的，所以我们需要另一个更大的程序完成这项任务，它就是loader，加载器。所以MBR需要把loader从硬盘加载到内存中，在第二章中有提到两块可用区域，加载到那里面就ok了，我跟作者一样，也把loader加载到0x900这里。</p><p>在读取硬盘扇区这一部分。建议先好好阅读一下本节的前置章节，硬盘部分，再看代码就不会再有吃力的地方了。至此，mbr.S的任务也就结束了，接下来我们写一个简单的loader来进行一个结果实现，验证一下思路是否正确就ok了。还是贴出代码：</p><h3 id="mbrs"><a class="markdownIt-Anchor" href="#mbrs"></a> mbr.S</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; mbr.S</span><br><br><span class="hljs-comment">; 主引导程序</span><br><span class="hljs-comment">; --------------------------------------------------</span><br><span class="hljs-meta">%include</span> <span class="hljs-string">&quot;boot.inc&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-comment">;LOADER_BASE_ADDR equ 0x900  将loader加载到内存0x900</span><br><span class="hljs-comment">;LOADER_START_SECTOR equ 0x2  loader位于磁盘第2块扇区</span><br><br><span class="hljs-meta">SECTION</span> MBR vstart=<span class="hljs-number">0x7c00</span> <span class="hljs-comment">; 把起始地址编译为 0x7c00</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">cs</span>     <span class="hljs-comment">; cs 代码段寄存器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">ax</span>     <span class="hljs-comment">; dx 数据段寄存器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">ax</span>     <span class="hljs-comment">; es 附加段寄存器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">ax</span>     <span class="hljs-comment">; ss 堆栈段寄存器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">fs</span>, <span class="hljs-built_in">ax</span>     <span class="hljs-comment">; fs 80386 后添加的寄存器，无全称</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x7c00</span> <span class="hljs-comment">; sp 堆栈指针寄存器</span><br>     <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xb800</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><span class="hljs-comment">;</span><br><br><span class="hljs-comment">; 清屏</span><br><span class="hljs-comment">; --------------------------------------------------</span><br><span class="hljs-comment">; INT 0x10    功能号: 0x06    功能描述：上卷窗口</span><br><span class="hljs-comment">; --------------------------------------------------</span><br><span class="hljs-comment">; 输入：</span><br><span class="hljs-comment">; AH 功能号 = 0x06</span><br><span class="hljs-comment">; AL = 上卷的行数(如果为0，表示全部)</span><br><span class="hljs-comment">; BH = 上卷行属性</span><br><span class="hljs-comment">; (CL, CH) = 窗口左上角的 (X, Y) 位置</span><br><span class="hljs-comment">; (DL, DH) = 窗口右下角的 (X, Y) 位置</span><br><span class="hljs-comment">; 无返回值:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0x600</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">0x700</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x184f</span> <span class="hljs-comment">; 右下角: (80, 25)</span><br>                   <span class="hljs-comment">; VGA 文本模式种，一行只能容纳 80 个字符，共 25 行</span><br>                   <span class="hljs-comment">; 下标从 0 开始，所以 0x18=24, 0x4f=79</span><br>        <br>    <span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span>       <span class="hljs-comment">; int 0x10</span><br><br><br><span class="hljs-comment">;;;;;下面代码是新增功能;;;;;;;;;;;;;;;;;;;;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, LOADER_START_SECTOR<span class="hljs-comment">; 磁盘中loader的LBA地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, LOADER_BASE_ADDR<span class="hljs-comment">;      loader加入内存的起始地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">1</span><span class="hljs-comment">; 待读入内存的扇区数</span><br><span class="hljs-keyword">call</span> rd_disk_m_16<span class="hljs-comment">;</span><br><br><span class="hljs-keyword">jmp</span> LOADER_BASE_ADDR<span class="hljs-comment">;</span><br><span class="hljs-comment">;--------------------------------------------------------------</span><br><span class="hljs-comment">;功能：读取硬盘n个扇区</span><br><span class="hljs-symbol">rd_disk_m_16:</span><br><span class="hljs-comment">;----------------------------------------------------------</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-built_in">eax</span><span class="hljs-comment">;   备份eax  al在in/out指令会被使用</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>, <span class="hljs-built_in">cx</span><span class="hljs-comment">;    备份cx cl会在接下来代码中频繁使用</span><br><span class="hljs-comment">;读写硬盘:</span><br><span class="hljs-comment">;第一步：设置要读取的扇区数 1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f2</span><span class="hljs-comment">; 配置的硬盘是ata0-master 是Primary通道  主盘</span><br>       <span class="hljs-comment">;sector count寄存器是0x1f2端口</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">cl</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">; 从内存把扇区数1输出到端口号0x1f2; </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">esi</span><span class="hljs-comment">; 恢复eax</span><br><br><span class="hljs-comment">;第二步 将LBA地址存入0x1f3~0x1f6</span><br><span class="hljs-comment">;LBA地址7~0位写入端口0x1f3</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f3</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">;</span><br><br><span class="hljs-comment">;LBA地址15~8位写入端口0x1f4</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">8</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">shr</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">cl</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f4</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">;</span><br><br><span class="hljs-comment">;LBA地址23~16位写入端口0x1f5</span><br><span class="hljs-keyword">shr</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">cl</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f5</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">;</span><br><br><span class="hljs-comment">;LBA地址24~27位写入端口0x1f6</span><br><span class="hljs-keyword">shr</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">cl</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0f</span><span class="hljs-comment">;  与运算al中低四位为LBA地址24~27位</span><br><span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0xe0</span><span class="hljs-comment">; 或运算拼出0x1f6的高四位1110 第6位为1表示LBA</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f6</span><span class="hljs-comment">; </span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">;</span><br><br><span class="hljs-comment">;第三步 向0x1f7端口写入读命令,0x20  </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f7</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">;  命令 写入端口0x1f7后，硬盘立即开始工作，将数据放入硬</span><br><span class="hljs-comment">;盘控制器的缓冲区</span><br><br><span class="hljs-comment">;第四步 检测硬盘状态,判断loader是否已经读入0x1f0端口中</span><br><span class="hljs-symbol">  .not_ready:</span><br><span class="hljs-keyword">nop</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span><span class="hljs-comment">; 将端口0x1f7的status写入al;</span><br><span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x88</span><span class="hljs-comment">; 获得status的第3位和第7位;</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x08</span><span class="hljs-comment">; 与第3位相减作比较 会影响ZF CF PF</span><br>  <span class="hljs-keyword">jnz</span> .not_ready<span class="hljs-comment">;   ZF不等于0就跳,相当于循环等缓冲区中的数据准备好为止</span><br><br><span class="hljs-comment">;第5步 将0x1f0端口的数据搬向内存</span><br>  <span class="hljs-comment">;5.1 计算搬运次数</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">di</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">256</span><span class="hljs-comment">;0x1f0端口是16比特</span><br><span class="hljs-keyword">mul</span> <span class="hljs-built_in">dx</span><span class="hljs-comment">;    di*512字节/2字节=搬运次数  16位乘法乘积32位</span><br><span class="hljs-comment">;高16位在dx,低16位在ax;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-built_in">ax</span><span class="hljs-comment">;   dx=1 乘积高16位是0,故把低16位移入cx</span><br>  <span class="hljs-comment">;5.2 循环搬运至内存         </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f0</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">  .go_on_read:</span>     <span class="hljs-comment">;我们的loader只有一个扇区512字节</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">dx</span><span class="hljs-comment">;;bx的寻址范围位64KB 65536字节</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">ax</span><span class="hljs-comment">;该循环不能加载大于64KB的程序于内存</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">2</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">loop</span> .go_on_read<span class="hljs-comment">; cx不等于0 就回到循环处继续搬</span><br><span class="hljs-keyword">ret</span>    <span class="hljs-comment">;搬运完loader 回到LOADER_BASE_ADDR;</span><br><br>  <br>  <span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span> <span class="hljs-comment">; 填充文件末尾的魔数 0xaa55 和当前位置之间的空间</span><br>                          <span class="hljs-comment">; 保证编译后生成的文件大小为 512 字节（硬盘一个扇区的大小）</span><br>    <span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>, <span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure><h3 id="loaders"><a class="markdownIt-Anchor" href="#loaders"></a> loader.S</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">%include</span> <span class="hljs-string">&quot;boot.inc&quot;</span><br><span class="hljs-meta">section</span> loader vstart=LOADER_BASE_ADDR<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x00</span>], <span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x01</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x02</span>], <span class="hljs-string">&#x27; &#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x03</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x04</span>], <span class="hljs-string">&#x27;L&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x05</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x06</span>], <span class="hljs-string">&#x27;O&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x07</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x08</span>], <span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x09</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x0a</span>], <span class="hljs-string">&#x27;D&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x0b</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x0c</span>], <span class="hljs-string">&#x27;E&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x0d</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x0e</span>], <span class="hljs-string">&#x27;R&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0x0f</span>], <span class="hljs-number">0xA4</span><span class="hljs-comment">;</span><br><br><span class="hljs-keyword">jmp</span> $<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="bootinc"><a class="markdownIt-Anchor" href="#bootinc"></a> boot.inc</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-comment">;----------------------loader AND kernel-----------------------------</span><br>LOADER_BASE_ADDR equ <span class="hljs-number">0</span>x900  <span class="hljs-comment">;loader.s加载到内存地址0x900</span><br>LOADER_START_SECTOR equ <span class="hljs-number">0</span>x2  <span class="hljs-comment">;loader.s刻入硬盘0盘0道2扇区（LBA）</span><br></code></pre></td></tr></table></figure><h2 id="写在后面"><a class="markdownIt-Anchor" href="#写在后面"></a> 写在后面</h2><p>建议读者在阅读的时候不要偏离主线，作者花费了大量的篇幅去补充理论知识，但我们还是要记得自己的主线任务是os的实现，所以要秉持着理论服侍实践的想法去阅读。我虽阅读时间还很短，但能感觉到自己是真的学到并运用了一些知识，后面就要进入保护模式了，但我的夏令营集训也开始了，希望flag能完成.</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>真象还原</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二章 编写MBR，开始进入系统的世界</title>
    <link href="/2022/07/08/os(2)/"/>
    <url>/2022/07/08/os(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-编写mbr开始进入系统的世界"><a class="markdownIt-Anchor" href="#第二章-编写mbr开始进入系统的世界"></a> 第二章 编写MBR，开始进入系统的世界</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>今天是7月6日，这一章涉及了汇编语言，阅读开始变得吃力，加上书中排版密密麻麻的文字，很容易心生退意，相信在开发的过程中一定会有些许乐趣等待挖掘，借此博客督促自己加强学习。</p><h2 id="lets-go-bios"><a class="markdownIt-Anchor" href="#lets-go-bios"></a> Let`s go! BIOS！</h2><p>首先说明了计算机启动后第一个运行的程序是我们常见的BIOS，然后为了说明BIOS加载的一系列问题，作者列出了实模式下内存布局的一张表用以说明CPU提交地址后会进行一个地址映射，分配给对应的物理设备。</p><p>然后就是BIOS的启动，在接电的瞬间，CPU中的cs:ip寄存器会被初始化为0xF000:0xFFF0（关于寄存器的一些概念涉及到汇编语言，这里不再赘述，我也是边读边学的），这段地址正好对应BIOS的入口地址。需要注意的是，这块地址只起到一个指引的作用，计算机执行它时需要跳转到BIOS的真正地址。</p><p>在BIOS里的最后一项工作时校验启动盘0盘0道1扇区（第一个扇区）的内容，如果该扇区末尾的两个字节分别是魔数0x55和0xaa，BIOS便会跳转到物理地址0x7c00，执行MBR（主引导记录）。</p><blockquote><p>我还想了下魔数是什么，一开始以为是计算机固定写死的某些程序，搜了一下才知道它是像魔法一样神奇的数。。。</p></blockquote><h2 id="mbr"><a class="markdownIt-Anchor" href="#mbr"></a> MBR</h2><p>MBR的大小是512字节，因为x86平台是小端字节序，所以为了保证最后两个字节（即510字节和511字节）为0x55和0xaa，其内容应为0xaa55。然后提到了NASM的两个关键字$和$$，它们用来表示当前行和本section的地址，起到标号的作用。</p><p>终于来到了MBR的编程，这一程序目前实现了一个在屏幕上打印字符串“1 MBR”的功能，其背景色为黑色，前景色为绿色。在打印字符串之前，还包含了不少代码，其功能不再解释。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">; mbr.S</span><br><br><span class="hljs-comment">; 主引导程序</span><br><span class="hljs-comment">; --------------------------------------------------</span><br><br>SECTION MBR vstart=<span class="hljs-number">0x7c00</span> <span class="hljs-comment">; 把起始地址编译为 0x7c00</span><br>    mov ax, cs     <span class="hljs-comment">; cs 代码段寄存器</span><br>    mov ds, ax     <span class="hljs-comment">; dx 数据段寄存器</span><br>    mov es, ax     <span class="hljs-comment">; es 附加段寄存器</span><br>    mov ss, ax     <span class="hljs-comment">; ss 堆栈段寄存器</span><br>    mov fs, ax     <span class="hljs-comment">; fs 80386 后添加的寄存器，无全称</span><br>    mov <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x7c00</span> <span class="hljs-comment">; sp 堆栈指针寄存器</span><br><br><span class="hljs-comment">; 清屏</span><br><span class="hljs-comment">; --------------------------------------------------</span><br><span class="hljs-comment">; INT 0x10    功能号: 0x06    功能描述：上卷窗口</span><br><span class="hljs-comment">; --------------------------------------------------</span><br><span class="hljs-comment">; 输入：</span><br><span class="hljs-comment">; AH 功能号 = 0x06</span><br><span class="hljs-comment">; AL = 上卷的行数(如果为0，表示全部)</span><br><span class="hljs-comment">; BH = 上卷行属性</span><br><span class="hljs-comment">; (CL, CH) = 窗口左上角的 (X, Y) 位置</span><br><span class="hljs-comment">; (DL, DH) = 窗口右下角的 (X, Y) 位置</span><br><span class="hljs-comment">; 无返回值:</span><br>    mov ax, <span class="hljs-number">0x600</span><br>    mov <span class="hljs-keyword">bx, </span><span class="hljs-number">0x700</span><br>    mov cx, <span class="hljs-number">0</span><br>    mov dx, <span class="hljs-number">0x184f</span> <span class="hljs-comment">; 右下角: (80, 25)</span><br>                   <span class="hljs-comment">; VGA 文本模式种，一行只能容纳 80 个字符，共 25 行</span><br>                   <span class="hljs-comment">; 下标从 0 开始，所以 0x18=24, 0x4f=79</span><br>        <br>    int <span class="hljs-number">0x10</span>       <span class="hljs-comment">; int 0x10</span><br><br><span class="hljs-comment">;;;;;;;;;;;;;下面这三行代码获取光标位置;;;;;;;;;;;;;;;;</span><br><br><span class="hljs-comment">; .get_cursor 获取当前光标位置，在光标处打印字符</span><br>    mov ah, <span class="hljs-number">3</span>      <span class="hljs-comment">; 3 号子功能</span><br>    mov <span class="hljs-keyword">bh, </span><span class="hljs-number">0</span>      <span class="hljs-comment">; 待获取光标的页号</span><br><br>    int <span class="hljs-number">0x10</span>       <span class="hljs-comment">; 输出：</span><br>                   <span class="hljs-comment">; ch = 光标开始行，cl = 光标结束行</span><br>                   <span class="hljs-comment">; dh = 光标所在行号，dl = 光标所在列号</span><br><br><span class="hljs-comment">; 打印字符串</span><br>    mov ax, message<br>    mov <span class="hljs-keyword">bp, </span>ax     <span class="hljs-comment">; es:bp 为串首地址</span><br>    <br>    mov cx, <span class="hljs-number">5</span>      <span class="hljs-comment">; cx 为串长度，不包括结束符 &#x27;\0&#x27;</span><br>    mov ax, <span class="hljs-number">0x1301</span> <span class="hljs-comment">; 13 号子功能</span><br>                   <span class="hljs-comment">; ah = 13</span><br>                   <span class="hljs-comment">; al = 01: 写字符方式，显式字符串，光标跟随移动</span><br>    mov <span class="hljs-keyword">bx, </span><span class="hljs-number">0x2</span>    <span class="hljs-comment">; bh = 0，要显示的页号</span><br>                   <span class="hljs-comment">; bl = 02，字符属性，黑底绿字</span><br>    <br>    int <span class="hljs-number">0x10</span><br><span class="hljs-comment">;;;;;;;;;;;;;;;;;;;;;;打印字符串结束;;;;;;;;;;;;;;;;</span><br><span class="hljs-keyword">jmp </span>$<span class="hljs-comment">;     程序悬停在此</span><br><br>message db <span class="hljs-string">&quot;1 MBR&quot;</span><br>times <span class="hljs-number">510</span>-($-$$)   db <span class="hljs-number">0</span><br>db <span class="hljs-number">0x55</span>,<span class="hljs-number">0xaa</span><br><br></code></pre></td></tr></table></figure><p>之后我们利用dd命令（用于磁盘操作的命令）将mbr.bin输出到第一章我们创建的虚拟硬盘hd60M.img，记得按照作者提示，将块大小指定为512字节，只操作1块。</p><p>运行bochs，界面是我们预想的输出一串字符串，大功告成！</p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>这一章总体内容并不是很多，主要集中在一些概念的描述，如果没有一定的知识储备读起来会很生涩，但是到了实际操作的时候就会发现基础必不可少。总体来说有一种学到的知识马上就能用到的感觉，比之前读ostep时总感觉有一层纱布隔着的感觉有很大不同，接下来还是争取做到每天一更。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>真象还原</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一章 部署工作环境，千里之行，始于足下</title>
    <link href="/2022/07/08/os(1)/"/>
    <url>/2022/07/08/os(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-部署工作环境千里之行始于足下"><a class="markdownIt-Anchor" href="#第一章-部署工作环境千里之行始于足下"></a> 第一章 部署工作环境，千里之行，始于足下</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>在读ostep的时候就已经萌生了自己写一个os的想法，在网上搜了一下，发现不少人都推荐读一下《操作系统真象还原》这本书，说是跟着这本书可以写一个简单的操作系统，正合我心。今天是7月5日，也是我翻开这本书的第一天，特记录一下此过程。给自己立一个flag，希望在进入8月之前能完整实现，马上又要进行数学建模国赛的集训，所以压力还是非常大，希望能顶住。</p><p>还有一点需要说明的是，本专栏不会详细记录制作系统的具体过程，书中和其他人写的博客都记载的非常清楚了，这里只做一个每章的总结，方便复习时回顾。</p><h2 id="进入正题吧"><a class="markdownIt-Anchor" href="#进入正题吧"></a> 进入正题吧</h2><p>首先介绍一下在制作os过程中要使用的<strong>编译器</strong>：<br />一个是我们已经非常熟悉的GCC，用来编译C代码，不用再详细说明了；<br />另一个是汇编语言的编译器NASM，汇编语言是我之前没有系统学习过的，但是既然涉及到底层实现，那么汇编一定是必不可少的，所以我在学习的过程中还会再配套学习它，选用的教材是王爽的《汇编语言》，突然觉得压力陡增。</p><p>然后是实验环境的搭建，因为我的主系统是Windows10，所以先在主系统上创建一个虚拟机用来模拟linux系统，这里用的不是书上写的virtualBox，而是目前比较主流的vmware workstation，然后装的ubuntu系统，这里有个小插叙值得分享一下，放在引用里了。</p><blockquote><p>因为之前做ostep的homework和csapp的lab时候就已经接触过linux系统了，当时装的也是比较大众的ubuntu系统，然后读这本书的时候因为怕自己水平不够，所以装的是和作者一样的cent os，但是装完后发现运行过程中出现了不少问题，比如无法联网、安装软件等等，发觉还是ubuntu系统好用一些，加上网上对于cent os教程也比较稀有，所以又装回了ubuntu，这就花费了我大半天的时间。。。</p></blockquote><p>为了实现自主创建操作系统，又在linux里面再装一个虚拟机Bochs，这是一个“PC兼容机模拟器和调试工具”，它貌似是用软件来模拟仿真出计算机的常用外设。</p><p>再下载完Bochs之后还要对它进行configure、make、make install三部曲，又是半天。。。<br />configure设置了一些参数，有bochs的安装目录、打开它的调试器、打开反汇编、启用io接口调试器等等，这些也是后面我们需要的功能。</p><p>最后再对安装好的bochs进行配置，这一步需要我们自己创建一个配置文件，我按照书中所写将其命名为bochsrc.disk。这个配置文件设置了一些内容，这里粘一下代码，注释已经给的很详细了。</p><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 第一步，首先设置Bochs在运行过程中能够使用的内存，单位为MB。</span><br>megs: 512<br><br><span class="hljs-comment"># 第二步，设置对应真实机器的BIOS和VGA BIOS。</span><br>romimage: <span class="hljs-attribute">file</span>=/home/podest/bochs/share/bochs/BIOS-bochs-latest<br>vgaromimage: <span class="hljs-attribute">file</span>=/home/podest/bochs/share/bochs/VGABIOS-lgpl-latest<br><br><span class="hljs-comment"># 第三步，设置Bochs所使用的磁盘，软盘的关键字为floppy。</span><br><span class="hljs-comment"># 若只有一个软盘，则使用floppya即可，若有多个，则为floppya，floppyb……</span><br><span class="hljs-comment">#floppya: 1_44=a.img, status=inserted</span><br><br><span class="hljs-comment"># 第四步，选择启动盘符。</span><br><span class="hljs-comment">#boot: floppy#默认从软盘启动</span><br>boot: disk#改为从硬盘启动，代码直接写在硬盘上，不会再有读取软盘的操作<br><br><span class="hljs-comment"># 第五步，设置日志文件的输出。</span><br>log: bochs.out<br><br><span class="hljs-comment"># 第六步，开启或关闭某些功能。</span><br><span class="hljs-comment"># 关闭鼠标，打开键盘。</span><br>mouse:<span class="hljs-attribute">enabled</span>=0<br>keyboard:<span class="hljs-attribute">keymap</span>=/home/podest/bochs/share/bochs/keymaps/x11-pc-us.map<br><br><span class="hljs-comment"># 硬盘设置</span><br>ata0: <span class="hljs-attribute">enabled</span>=1, <span class="hljs-attribute">ioaddr1</span>=0x1f0, <span class="hljs-attribute">ioaddr2</span>=0x3f0, <span class="hljs-attribute">irq</span>=14<br>ata0-master: <span class="hljs-attribute">type</span>=disk, <span class="hljs-attribute">path</span>=<span class="hljs-string">&quot;hd60M.img&quot;</span>, <span class="hljs-attribute">mode</span>=flat,cylinders=121,heads=16,spt=63<br><br><span class="hljs-comment"># 增加的bochs对gdb的支持，这样gdb便可以从远程连接到此机器的1234端口调试了</span><br><span class="hljs-comment"># gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0</span><br></code></pre></td></tr></table></figure><p>到这里bochs的配置就完成了，以后运行它就可以直接执行命令bin/bochs即可，在读取配置文件的时候输入bochsrc.disc即可。目前我们运行的时候会弹出一个窗口提示bochs启动时找不到启动盘，所以我们就需要进行下一步，创建一个虚拟硬盘。按照书中操作即可，最终创建了一个名称为hd60M.img的虚拟硬盘。这次运行bochs依然弹出窗口，这一次提示该硬盘不是启动盘。</p><p>到这里这一章就戛然而止了，作者给留了一个小悬念。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>真象还原</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ostep homework(8)</title>
    <link href="/2022/06/25/Ostep(8)/"/>
    <url>/2022/06/25/Ostep(8)/</url>
    
    <content type="html"><![CDATA[<h1 id="第8章-调度多级反馈队列-homework详解"><a class="markdownIt-Anchor" href="#第8章-调度多级反馈队列-homework详解"></a> 第8章 <em>调度：多级反馈队列</em>  homework详解</h1><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><p>笔者采用的是<strong>Ubuntu22.04</strong>的虚拟机。<br />本次作业需要用到<strong>cpu-sched-mlfq</strong>文件，按照<strong>readme</strong>提示操作即可。</p><h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2><h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h3><figure class="highlight tap"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs tap">$ python3 mlfq.py -n<span class="hljs-number"> 2 </span>-j<span class="hljs-number"> 2 </span>-m<span class="hljs-number"> 10 </span>-M<span class="hljs-number"> 0 </span>-c  <br>……  <br>Job List:  <br>  Job  0: startTime  <span class="hljs-number"> 0 </span>- runTime  <span class="hljs-number"> 8 </span>- ioFreq  <span class="hljs-number"> 0 </span> <br>  Job  1: startTime  <span class="hljs-number"> 0 </span>- runTime  <span class="hljs-number"> 4 </span>- ioFreq  <span class="hljs-number"> 0 </span> <br><br><br>Execution Trace:  <br><br>[ time<span class="hljs-number"> 0 </span>] JOB BEGINS by JOB<span class="hljs-number"> 0 </span> <br>[ time<span class="hljs-number"> 0 </span>] JOB BEGINS by JOB<span class="hljs-number"> 1 </span> <br>[ time<span class="hljs-number"> 0 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 1 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 7 </span>(of 8) ]  <br>……  <br>[ time<span class="hljs-number"> 7 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 1 </span>[ TICKS<span class="hljs-number"> 2 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 0 </span>(of 8) ]  <br>[ time<span class="hljs-number"> 8 </span>] FINISHED JOB<span class="hljs-number"> 0 </span> <br>[ time<span class="hljs-number"> 8 </span>] Run JOB<span class="hljs-number"> 1 </span>at PRIORITY<span class="hljs-number"> 1 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 3 </span>(of 4) ]  <br>……  <br>[ time<span class="hljs-number"> 11 </span>] Run JOB<span class="hljs-number"> 1 </span>at PRIORITY<span class="hljs-number"> 1 </span>[ TICKS<span class="hljs-number"> 6 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 0 </span>(of 4) ]  <br>[ time<span class="hljs-number"> 12 </span>] FINISHED JOB<span class="hljs-number"> 1 </span> <br><br>Final statistics:  <br>  Job  0: startTime  <span class="hljs-number"> 0 </span>- response  <span class="hljs-number"> 0 </span>- turnaround  <span class="hljs-number"> 8 </span> <br>  Job  1: startTime  <span class="hljs-number"> 0 </span>- response  <span class="hljs-number"> 8 </span>- turnaround <span class="hljs-number"> 12 </span> <br><br>  Avg  1: startTime n/a - response 4.00 - turnaround 10.00  <br></code></pre></td></tr></table></figure><p>给出限制条件：队列数为2，工作数为2，工作最大长度为10，I/O最大长度为0。</p><h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h3><p><strong>实例1</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ python3 mlfq.py -l 0,200,0 -q<span class="hljs-number"> 10 </span>-n<span class="hljs-number"> 3 </span>-c  <br>……  <br><br>Job List:  <br>  Job  0: startTime  <span class="hljs-number"> 0 </span>- runTime<span class="hljs-number"> 200 </span>- ioFreq  <span class="hljs-number"> 0 </span> <br><br><br>Execution Trace:  <br><br>[ time<span class="hljs-number"> 0 </span>] JOB BEGINS by JOB<span class="hljs-number"> 0 </span> <br>[ time<span class="hljs-number"> 0 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 2 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 199 </span>(of 200) ]  <br>……  <br>[ time<span class="hljs-number"> 9 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 2 </span>[ TICKS<span class="hljs-number"> 0 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 190 </span>(of 200) ]  <br>[ time<span class="hljs-number"> 10 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 1 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 189 </span>(of 200) ]  <br>……  <br>[ time<span class="hljs-number"> 19 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 1 </span>[ TICKS<span class="hljs-number"> 0 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 180 </span>(of 200) ]  <br>[ time<span class="hljs-number"> 20 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 0 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 179 </span>(of 200) ]  <br>……  <br>[ time<span class="hljs-number"> 199 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 0 </span>[ TICKS<span class="hljs-number"> 0 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 0 </span>(of 200) ]  <br>[ time<span class="hljs-number"> 200 </span>] FINISHED JOB<span class="hljs-number"> 0 </span> <br><br>Final statistics:  <br>  Job  0: startTime  <span class="hljs-number"> 0 </span>- response  <span class="hljs-number"> 0 </span>- turnaround<span class="hljs-number"> 200 </span> <br><br>  Avg  0: startTime n/a - response 0.00 - turnaround 200.00  <br></code></pre></td></tr></table></figure><p>单个长工作，其运行时间为200ms，3个队列，时间片长度为10ms。</p><p><strong>实例2</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ python3 mlfq.py -l 0,180,0:100,20,0 -q<span class="hljs-number"> 10 </span>-n<span class="hljs-number"> 3 </span>-c  <br>……  <br><br>Job List:  <br>  Job  0: startTime  <span class="hljs-number"> 0 </span>- runTime<span class="hljs-number"> 180 </span>- ioFreq  <span class="hljs-number"> 0 </span> <br>  Job  1: startTime<span class="hljs-number"> 100 </span>- runTime <span class="hljs-number"> 20 </span>- ioFreq  <span class="hljs-number"> 0 </span> <br><br><br>Execution Trace:  <br><br>[ time<span class="hljs-number"> 0 </span>] JOB BEGINS by JOB<span class="hljs-number"> 0 </span> <br>[ time<span class="hljs-number"> 0 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 2 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 179 </span>(of 180) ]  <br>……  <br>[ time<span class="hljs-number"> 9 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 2 </span>[ TICKS<span class="hljs-number"> 0 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 170 </span>(of 180) ]  <br>[ time<span class="hljs-number"> 10 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 1 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 169 </span>(of 180) ]  <br>……  <br>[ time<span class="hljs-number"> 19 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 1 </span>[ TICKS<span class="hljs-number"> 0 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 160 </span>(of 180) ]  <br>[ time<span class="hljs-number"> 20 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 0 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 159 </span>(of 180) ]  <br>……  <br>[ time<span class="hljs-number"> 99 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 0 </span>[ TICKS<span class="hljs-number"> 0 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 80 </span>(of 180) ]  <br>[ time<span class="hljs-number"> 100 </span>] JOB BEGINS by JOB<span class="hljs-number"> 1 </span> <br>[ time<span class="hljs-number"> 100 </span>] Run JOB<span class="hljs-number"> 1 </span>at PRIORITY<span class="hljs-number"> 2 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 19 </span>(of 20) ]  <br>……  <br>[ time<span class="hljs-number"> 109 </span>] Run JOB<span class="hljs-number"> 1 </span>at PRIORITY<span class="hljs-number"> 2 </span>[ TICKS<span class="hljs-number"> 0 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 10 </span>(of 20) ]  <br>[ time<span class="hljs-number"> 110 </span>] Run JOB<span class="hljs-number"> 1 </span>at PRIORITY<span class="hljs-number"> 1 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 9 </span>(of 20) ]  <br>……  <br>[ time<span class="hljs-number"> 119 </span>] Run JOB<span class="hljs-number"> 1 </span>at PRIORITY<span class="hljs-number"> 1 </span>[ TICKS<span class="hljs-number"> 0 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 0 </span>(of 20) ]  <br>[ time<span class="hljs-number"> 120 </span>] FINISHED JOB<span class="hljs-number"> 1 </span> <br>[ time<span class="hljs-number"> 120 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 0 </span>[ TICKS<span class="hljs-number"> 9 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 79 </span>(of 180) ]  <br>……  <br>[ time<span class="hljs-number"> 199 </span>] Run JOB<span class="hljs-number"> 0 </span>at PRIORITY<span class="hljs-number"> 0 </span>[ TICKS<span class="hljs-number"> 0 </span>ALLOT<span class="hljs-number"> 1 </span>TIME<span class="hljs-number"> 0 </span>(of 180) ]  <br>[ time<span class="hljs-number"> 200 </span>] FINISHED JOB<span class="hljs-number"> 0 </span> <br><br>Final statistics:  <br>  Job  0: startTime  <span class="hljs-number"> 0 </span>- response  <span class="hljs-number"> 0 </span>- turnaround<span class="hljs-number"> 200 </span> <br>  Job  1: startTime<span class="hljs-number"> 100 </span>- response  <span class="hljs-number"> 0 </span>- turnaround <span class="hljs-number"> 20 </span> <br><br>  Avg  1: startTime n/a - response 0.00 - turnaround 110.00  <br></code></pre></td></tr></table></figure><p>长工作运行期间进入了一个短工作，由于短工作优先级高，故优先执行短工作。书上写长工作从最低优先队列开始运行，这里是从最高优先队列运行的，不过不影响结果。<br /><strong>实例3</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ python3 mlfq<span class="hljs-selector-class">.py</span>  -l <span class="hljs-number">0</span>,<span class="hljs-number">40</span>,<span class="hljs-number">2</span>:<span class="hljs-number">0</span>,<span class="hljs-number">200</span>,<span class="hljs-number">0</span> -<span class="hljs-selector-tag">q</span> <span class="hljs-number">10</span> -n <span class="hljs-number">3</span> -<span class="hljs-selector-tag">i</span> <span class="hljs-number">5</span> -c  <br></code></pre></td></tr></table></figure><h1 id="第8章-调度多级反馈队列-homework详解-2"><a class="markdownIt-Anchor" href="#第8章-调度多级反馈队列-homework详解-2"></a> 第8章 <em>调度：多级反馈队列</em> homework详解</h1><h2 id="实验环境-2"><a class="markdownIt-Anchor" href="#实验环境-2"></a> 实验环境</h2><p>笔者采用的是<strong>Ubuntu22.04</strong>的虚拟机。<br />本次作业需要用到<strong>cpu-sched-mlfq</strong>文件，按照<strong>readme</strong>提示操作即可。</p><h2 id="实验内容-2"><a class="markdownIt-Anchor" href="#实验内容-2"></a> 实验内容</h2><h3 id="1-2"><a class="markdownIt-Anchor" href="#1-2"></a> 1</h3><div class="code-wrapper"><pre><code class="hljs">$ python3 mlfq.py -n 2 -j 2 -m 10 -M 0 -c……Job List:  Job  0: startTime   0 - runTime   8 - ioFreq   0  Job  1: startTime   0 - runTime   4 - ioFreq   0Execution Trace:[ time 0 ] JOB BEGINS by JOB 0[ time 0 ] JOB BEGINS by JOB 1[ time 0 ] Run JOB 0 at PRIORITY 1 [ TICKS 9 ALLOT 1 TIME 7 (of 8) ]……[ time 7 ] Run JOB 0 at PRIORITY 1 [ TICKS 2 ALLOT 1 TIME 0 (of 8) ][ time 8 ] FINISHED JOB 0[ time 8 ] Run JOB 1 at PRIORITY 1 [ TICKS 9 ALLOT 1 TIME 3 (of 4) ]……[ time 11 ] Run JOB 1 at PRIORITY 1 [ TICKS 6 ALLOT 1 TIME 0 (of 4) ][ time 12 ] FINISHED JOB 1Final statistics:  Job  0: startTime   0 - response   0 - turnaround   8  Job  1: startTime   0 - response   8 - turnaround  12  Avg  1: startTime n/a - response 4.00 - turnaround 10.00</code></pre></div><p>给出限制条件：队列数为2，工作数为2，工作最大长度为10，I/O最大长度为0。</p><h3 id="2-2"><a class="markdownIt-Anchor" href="#2-2"></a> 2</h3><p><strong>实例1</strong></p><div class="code-wrapper"><pre><code class="hljs">$ python3 mlfq.py -l 0,200,0 -q 10 -n 3 -c……Job List:  Job  0: startTime   0 - runTime 200 - ioFreq   0Execution Trace:[ time 0 ] JOB BEGINS by JOB 0[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 9 ALLOT 1 TIME 199 (of 200) ]……[ time 9 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 190 (of 200) ][ time 10 ] Run JOB 0 at PRIORITY 1 [ TICKS 9 ALLOT 1 TIME 189 (of 200) ]……[ time 19 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 180 (of 200) ][ time 20 ] Run JOB 0 at PRIORITY 0 [ TICKS 9 ALLOT 1 TIME 179 (of 200) ]……[ time 199 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 200) ][ time 200 ] FINISHED JOB 0Final statistics:  Job  0: startTime   0 - response   0 - turnaround 200  Avg  0: startTime n/a - response 0.00 - turnaround 200.00</code></pre></div><p>单个长工作，其运行时间为200ms，3个队列，时间片长度为10ms。</p><p><strong>实例2</strong></p><div class="code-wrapper"><pre><code class="hljs">$ python3 mlfq.py -l 0,180,0:100,20,0 -q 10 -n 3 -c……Job List:  Job  0: startTime   0 - runTime 180 - ioFreq   0  Job  1: startTime 100 - runTime  20 - ioFreq   0Execution Trace:[ time 0 ] JOB BEGINS by JOB 0[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 9 ALLOT 1 TIME 179 (of 180) ]……[ time 9 ] Run JOB 0 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 170 (of 180) ][ time 10 ] Run JOB 0 at PRIORITY 1 [ TICKS 9 ALLOT 1 TIME 169 (of 180) ]……[ time 19 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 160 (of 180) ][ time 20 ] Run JOB 0 at PRIORITY 0 [ TICKS 9 ALLOT 1 TIME 159 (of 180) ]……[ time 99 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 80 (of 180) ][ time 100 ] JOB BEGINS by JOB 1[ time 100 ] Run JOB 1 at PRIORITY 2 [ TICKS 9 ALLOT 1 TIME 19 (of 20) ]……[ time 109 ] Run JOB 1 at PRIORITY 2 [ TICKS 0 ALLOT 1 TIME 10 (of 20) ][ time 110 ] Run JOB 1 at PRIORITY 1 [ TICKS 9 ALLOT 1 TIME 9 (of 20) ]……[ time 119 ] Run JOB 1 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 0 (of 20) ][ time 120 ] FINISHED JOB 1[ time 120 ] Run JOB 0 at PRIORITY 0 [ TICKS 9 ALLOT 1 TIME 79 (of 180) ]……[ time 199 ] Run JOB 0 at PRIORITY 0 [ TICKS 0 ALLOT 1 TIME 0 (of 180) ][ time 200 ] FINISHED JOB 0Final statistics:  Job  0: startTime   0 - response   0 - turnaround 200  Job  1: startTime 100 - response   0 - turnaround  20  Avg  1: startTime n/a - response 0.00 - turnaround 110.00</code></pre></div><p>长工作运行期间进入了一个短工作，由于短工作优先级高，故优先执行短工作。书上写长工作从最低优先队列开始运行，这里是从最高优先队列运行的，不过不影响结果。<br /><strong>实例3</strong></p><div class="code-wrapper"><pre><code class="hljs">$ python3 mlfq.py  -l 0,40,2:0,200,0 -q 10 -n 3 -i 5 -c</code></pre></div><p>Markdown 2475 字数 113 行数 当前行 112, 当前列 0 文章已保存11:18:23</p><p>HTML 2414 字数 85 段落</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>ostep</category>
      
      <category>homework详解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ostep homework(7)</title>
    <link href="/2022/05/24/Ostep(7)/"/>
    <url>/2022/05/24/Ostep(7)/</url>
    
    <content type="html"><![CDATA[<h1 id="第7章-进程调度介绍-homework详解"><a class="markdownIt-Anchor" href="#第7章-进程调度介绍-homework详解"></a> 第7章 <em>进程调度：介绍</em>  homework详解</h1><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><p>笔者采用的是<strong>Ubuntu22.04</strong>的虚拟机。<br />本次作业需要先通过所学知识手动解题，再按教程运行程序<strong><a href="http://scheduler.py">scheduler.py</a></strong>即可。<br />需要用到<strong>cpu-sched</strong>文件，先阅读<strong>readme</strong>文件。</p><h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2><h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">$ ./scheduler.py -p SJF -l <span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span> -c<br>ARG policy SJF<br>ARG jlist <span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span><br><br>Here is <span class="hljs-keyword">the</span> job list, <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> run <span class="hljs-built_in">time</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">each</span> job: <br>  Job <span class="hljs-number">0</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">200.0</span> )<br>  Job <span class="hljs-number">1</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">200.0</span> )<br>  Job <span class="hljs-number">2</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">200.0</span> )<br><br><br>** Solutions **<br><br>Execution trace:<br>  [ <span class="hljs-built_in">time</span>   <span class="hljs-number">0</span> ] Run job <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> <span class="hljs-number">200.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">200.00</span> )<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">200</span> ] Run job <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-number">200.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">400.00</span> )<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">400</span> ] Run job <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> <span class="hljs-number">200.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">600.00</span> )<br><br>Final statistics:<br>  Job   <span class="hljs-number">0</span> <span class="hljs-comment">-- Response: 0.00  Turnaround 200.00  Wait 0.00</span><br>  Job   <span class="hljs-number">1</span> <span class="hljs-comment">-- Response: 200.00  Turnaround 400.00  Wait 200.00</span><br>  Job   <span class="hljs-number">2</span> <span class="hljs-comment">-- Response: 400.00  Turnaround 600.00  Wait 400.00</span><br><br>  Average <span class="hljs-comment">-- Response: 200.00  Turnaround 400.00  Wait 200.00</span><br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ ./scheduler.py -p FIFO -l <span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span> -c<br>ARG policy FIFO<br>ARG jlist <span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span><br><br>Here is <span class="hljs-keyword">the</span> job list, <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> run <span class="hljs-built_in">time</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">each</span> job: <br>  Job <span class="hljs-number">0</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">200.0</span> )<br>  Job <span class="hljs-number">1</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">200.0</span> )<br>  Job <span class="hljs-number">2</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">200.0</span> )<br><br><br>** Solutions **<br><br>Execution trace:<br>  [ <span class="hljs-built_in">time</span>   <span class="hljs-number">0</span> ] Run job <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> <span class="hljs-number">200.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">200.00</span> )<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">200</span> ] Run job <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-number">200.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">400.00</span> )<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">400</span> ] Run job <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> <span class="hljs-number">200.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">600.00</span> )<br><br>Final statistics:<br>  Job   <span class="hljs-number">0</span> <span class="hljs-comment">-- Response: 0.00  Turnaround 200.00  Wait 0.00</span><br>  Job   <span class="hljs-number">1</span> <span class="hljs-comment">-- Response: 200.00  Turnaround 400.00  Wait 200.00</span><br>  Job   <span class="hljs-number">2</span> <span class="hljs-comment">-- Response: 400.00  Turnaround 600.00  Wait 400.00</span><br><br>  Average <span class="hljs-comment">-- Response: 200.00  Turnaround 400.00  Wait 200.00</span><br></code></pre></td></tr></table></figure><p>这两个代码块分别是SJF和FIFO调度，因为三个任务长度相等且同时到达，所以它们的响应时间和周转时间相同。</p><h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ ./scheduler.py -p SJF -l <span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span> -c<br>ARG policy SJF<br>ARG jlist <span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span><br><br>Here is <span class="hljs-keyword">the</span> job list, <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> run <span class="hljs-built_in">time</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">each</span> job: <br>  Job <span class="hljs-number">0</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">100.0</span> )<br>  Job <span class="hljs-number">1</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">200.0</span> )<br>  Job <span class="hljs-number">2</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">300.0</span> )<br><br><br>** Solutions **<br><br>Execution trace:<br>  [ <span class="hljs-built_in">time</span>   <span class="hljs-number">0</span> ] Run job <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> <span class="hljs-number">100.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">100.00</span> )<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">100</span> ] Run job <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-number">200.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">300.00</span> )<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">300</span> ] Run job <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> <span class="hljs-number">300.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">600.00</span> )<br><br>Final statistics:<br>  Job   <span class="hljs-number">0</span> <span class="hljs-comment">-- Response: 0.00  Turnaround 100.00  Wait 0.00</span><br>  Job   <span class="hljs-number">1</span> <span class="hljs-comment">-- Response: 100.00  Turnaround 300.00  Wait 100.00</span><br>  Job   <span class="hljs-number">2</span> <span class="hljs-comment">-- Response: 300.00  Turnaround 600.00  Wait 300.00</span><br><br>  Average <span class="hljs-comment">-- Response: 133.33  Turnaround 333.33  Wait 133.33</span><br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ ./scheduler.py -p FIFO -l <span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span> -c<br>ARG policy FIFO<br>ARG jlist <span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span><br><br>Here is <span class="hljs-keyword">the</span> job list, <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> run <span class="hljs-built_in">time</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">each</span> job: <br>  Job <span class="hljs-number">0</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">100.0</span> )<br>  Job <span class="hljs-number">1</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">200.0</span> )<br>  Job <span class="hljs-number">2</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">300.0</span> )<br><br><br>** Solutions **<br><br>Execution trace:<br>  [ <span class="hljs-built_in">time</span>   <span class="hljs-number">0</span> ] Run job <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> <span class="hljs-number">100.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">100.00</span> )<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">100</span> ] Run job <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-number">200.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">300.00</span> )<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">300</span> ] Run job <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> <span class="hljs-number">300.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">600.00</span> )<br><br>Final statistics:<br>  Job   <span class="hljs-number">0</span> <span class="hljs-comment">-- Response: 0.00  Turnaround 100.00  Wait 0.00</span><br>  Job   <span class="hljs-number">1</span> <span class="hljs-comment">-- Response: 100.00  Turnaround 300.00  Wait 100.00</span><br>  Job   <span class="hljs-number">2</span> <span class="hljs-comment">-- Response: 300.00  Turnaround 600.00  Wait 300.00</span><br><br>  Average <span class="hljs-comment">-- Response: 133.33  Turnaround 333.33  Wait 133.33</span><br></code></pre></td></tr></table></figure><p>因为是按照100，200，300的顺序插入任务的，所以二者调度模式是相同的，如果将100，200，300的顺序交换，结果会产生差异。例如，</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ ./scheduler.py -p FIFO -l <span class="hljs-number">200</span>,<span class="hljs-number">100</span>,<span class="hljs-number">300</span> -c<br>ARG policy FIFO<br>ARG jlist <span class="hljs-number">200</span>,<span class="hljs-number">100</span>,<span class="hljs-number">300</span><br><br>Here is <span class="hljs-keyword">the</span> job list, <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> run <span class="hljs-built_in">time</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">each</span> job: <br>  Job <span class="hljs-number">0</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">200.0</span> )<br>  Job <span class="hljs-number">1</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">100.0</span> )<br>  Job <span class="hljs-number">2</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">300.0</span> )<br><br><br>** Solutions **<br><br>Execution trace:<br>  [ <span class="hljs-built_in">time</span>   <span class="hljs-number">0</span> ] Run job <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> <span class="hljs-number">200.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">200.00</span> )<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">200</span> ] Run job <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-number">100.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">300.00</span> )<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">300</span> ] Run job <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> <span class="hljs-number">300.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">600.00</span> )<br><br>Final statistics:<br>  Job   <span class="hljs-number">0</span> <span class="hljs-comment">-- Response: 0.00  Turnaround 200.00  Wait 0.00</span><br>  Job   <span class="hljs-number">1</span> <span class="hljs-comment">-- Response: 200.00  Turnaround 300.00  Wait 200.00</span><br>  Job   <span class="hljs-number">2</span> <span class="hljs-comment">-- Response: 300.00  Turnaround 600.00  Wait 300.00</span><br><br>  Average <span class="hljs-comment">-- Response: 166.67  Turnaround 366.67  Wait 166.67</span><br></code></pre></td></tr></table></figure><p>响应时间和周转时间都发生了变化。</p><h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ ./scheduler.py -p RR -l <span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span> -c<br>ARG policy RR<br>ARG jlist <span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span><br><br>Here is <span class="hljs-keyword">the</span> job list, <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> run <span class="hljs-built_in">time</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">each</span> job: <br>  Job <span class="hljs-number">0</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">100.0</span> )<br>  Job <span class="hljs-number">1</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">200.0</span> )<br>  Job <span class="hljs-number">2</span> ( <span class="hljs-built_in">length</span> = <span class="hljs-number">300.0</span> )<br><br><br>** Solutions **<br><br>Execution trace:<br>  [ <span class="hljs-built_in">time</span>   <span class="hljs-number">0</span> ] Run job   <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> <span class="hljs-number">1.00</span> <span class="hljs-built_in">secs</span><br>  [ <span class="hljs-built_in">time</span>   <span class="hljs-number">1</span> ] Run job   <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-number">1.00</span> <span class="hljs-built_in">secs</span><br>  [ <span class="hljs-built_in">time</span>   <span class="hljs-number">2</span> ] Run job   <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> <span class="hljs-number">1.00</span> <span class="hljs-built_in">secs</span><br>  [ <span class="hljs-built_in">time</span>   <span class="hljs-number">3</span> ] Run job   <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> <span class="hljs-number">1.00</span> <span class="hljs-built_in">secs</span><br>  [ <span class="hljs-built_in">time</span>   <span class="hljs-number">4</span> ] Run job   <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-number">1.00</span> <span class="hljs-built_in">secs</span><br>  ……<br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">598</span> ] Run job   <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> <span class="hljs-number">1.00</span> <span class="hljs-built_in">secs</span><br>  [ <span class="hljs-built_in">time</span> <span class="hljs-number">599</span> ] Run job   <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> <span class="hljs-number">1.00</span> <span class="hljs-built_in">secs</span> ( DONE <span class="hljs-keyword">at</span> <span class="hljs-number">600.00</span> )<br><br>Final statistics:<br>  Job   <span class="hljs-number">0</span> <span class="hljs-comment">-- Response: 0.00  Turnaround 298.00  Wait 198.00</span><br>  Job   <span class="hljs-number">1</span> <span class="hljs-comment">-- Response: 1.00  Turnaround 499.00  Wait 299.00</span><br>  Job   <span class="hljs-number">2</span> <span class="hljs-comment">-- Response: 2.00  Turnaround 600.00  Wait 300.00</span><br><br>  Average <span class="hljs-comment">-- Response: 1.00  Turnaround 465.67  Wait 265.67</span><br></code></pre></td></tr></table></figure><p>采用RR调度程序交换三者顺序也不会有影响了，牺牲了周转时间和等待时间换取了极快的响应时间。</p><h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h3><p>当工作负载为长度自小到大升序排列时，二者产生的效果是一样的，其周转时间和等待时间一致。</p><h3 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h3><p>当量子长度大于最大工作负载长度时，二者等效。</p><h3 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6</h3><p>容易得出结论，工作负载长度增加，其必然会使响应时间增加。</p><h3 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7</h3><p>量子长度增加，响应时间会随之增加。<br />当给定N个任务时，假设量子长度为m</p><ol><li><p>当每个任务长度都大于m时，其响应时间为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi>i</mi><mo>×</mo><mi>m</mi></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">{\sum_{i=1}^N i\times m\over N}={m(N+1)\over2} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.356941em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.670941em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6897100000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p></li><li><p>当每个任务长度都小于m时，其响应时间为总任务长度除以N。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>ostep</category>
      
      <category>homework详解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ostep homework(5)</title>
    <link href="/2022/05/20/Ostep(5)/"/>
    <url>/2022/05/20/Ostep(5)/</url>
    
    <content type="html"><![CDATA[<h1 id="第5章-插叙进程api-homework详解"><a class="markdownIt-Anchor" href="#第5章-插叙进程api-homework详解"></a> 第5章 <em>插叙：进程API</em>  homework详解</h1><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><p>笔者采用的是Ubuntu22.04的虚拟机。<br />本次作业原则上只需自己编码，不需要依靠实验材料，不过作者也提供了两个py程序可供参考，文件名为cpu-api。</p><h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2><h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h3><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d (pid:%d)\n&quot;</span>, x, (<span class="hljs-type">int</span>) getpid());<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// fork失败</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) <span class="hljs-comment">// child</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d (pid:%d)\n&quot;</span>, x, (<span class="hljs-type">int</span>) getpid());<br>        x = <span class="hljs-number">1000</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// parent</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d (pid:%d)\n&quot;</span>, x, (<span class="hljs-type">int</span>) getpid());<br>        x = <span class="hljs-number">500</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 运行结果：</span><br><span class="hljs-comment">// 100 (pid:19563)</span><br><span class="hljs-comment">// 100 (pid:19563)</span><br><span class="hljs-comment">// 500</span><br><span class="hljs-comment">// 100 (pid:19564)</span><br><span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>由此可见，在fork子进程之后修改主进程变量不会影响到子进程，要把它们理解成两个独立的进程，当然子进程的变量值全部继承于fork子进程之前的主进程。</p><h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;temp.txt&quot;</span>, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) <br>    &#123;<br>        close(fd);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) <span class="hljs-comment">// 子进程写入</span><br>    &#123;<br>        <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;child write something!\n&quot;</span>;<br>        write(fd, s, <span class="hljs-built_in">strlen</span>(s));<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 主进程写入</span><br>    &#123;<br>        <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;parent write something\n&quot;</span>;<br>        write(fd, s, <span class="hljs-built_in">strlen</span>(s));<br>        wait(<span class="hljs-literal">NULL</span>);<br>        close(fd);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// child write something!</span><br><span class="hljs-comment">// parent write something!</span><br></code></pre></td></tr></table></figure><p>两个进程都能对打开的文件进行修改。</p><h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> rc = vfork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// fork失败</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) <span class="hljs-comment">// child</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// parent</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;goodbye\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// hello</span><br><span class="hljs-comment">// goodbye</span><br></code></pre></td></tr></table></figure><p>使用vfork创建子进程，可以优先执行子进程。</p><h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> * s = <span class="hljs-string">&quot;/bin/ls&quot;</span>;<br>    <span class="hljs-type">char</span> * ss = <span class="hljs-string">&quot;ls&quot;</span>;<br>    <span class="hljs-type">char</span> * s2 = <span class="hljs-string">&quot;/&quot;</span>;<br>    <span class="hljs-type">char</span> * sv[] = &#123; ss, s2, <span class="hljs-literal">NULL</span> &#125;;<br>    <span class="hljs-keyword">for</span>(flag = <span class="hljs-number">0</span>; flag &lt; MAX; ++flag) <br>    &#123;<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// fork失败</span><br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) <span class="hljs-comment">// 子进程</span><br>        &#123;<br>            <span class="hljs-keyword">switch</span>(flag) <br>            &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    execl(s, ss, s2, <span class="hljs-literal">NULL</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    execle(s, ss, s2, <span class="hljs-literal">NULL</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    execlp(s, s, s2, <span class="hljs-literal">NULL</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    execv(s, sv);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    execvp(ss, sv);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                    execvpe(ss, sv);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">else</span> <br>            wait(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// bin    dev   lib    libx32    mnt   root  snap      sys  var</span><br><span class="hljs-comment">// boot   etc   lib32  lost+found    opt   run   srv       tmp</span><br><span class="hljs-comment">// cdrom  home  lib64  media    proc  sbin  swapfile  usr</span><br><span class="hljs-comment">// bin    dev   lib    libx32    mnt   root  snap      sys  var</span><br><span class="hljs-comment">// boot   etc   lib32  lost+found    opt   run   srv       tmp</span><br><span class="hljs-comment">// cdrom  home  lib64  media    proc  sbin  swapfile  usr</span><br><span class="hljs-comment">// bin    dev   lib    libx32    mnt   root  snap      sys  var</span><br><span class="hljs-comment">// boot   etc   lib32  lost+found    opt   run   srv       tmp</span><br><span class="hljs-comment">// cdrom  home  lib64  media    proc  sbin  swapfile  usr</span><br><span class="hljs-comment">// bin    dev   lib    libx32    mnt   root  snap      sys  var</span><br><span class="hljs-comment">// boot   etc   lib32  lost+found    opt   run   srv       tmp</span><br><span class="hljs-comment">// cdrom  home  lib64  media    proc  sbin  swapfile  usr</span><br><span class="hljs-comment">// bin    dev   lib    libx32    mnt   root  snap      sys  var</span><br><span class="hljs-comment">// boot   etc   lib32  lost+found    opt   run   srv       tmp</span><br><span class="hljs-comment">// cdrom  home  lib64  media    proc  sbin  swapfile  usr</span><br><span class="hljs-comment">// bin    dev   lib    libx32    mnt   root  snap      sys  var</span><br><span class="hljs-comment">// boot   etc   lib32  lost+found    opt   run   srv       tmp</span><br><span class="hljs-comment">// cdrom  home  lib64  media    proc  sbin  swapfile  usr</span><br></code></pre></td></tr></table></figure><p>依次调用了6个函数，可见都能实现最终效果。</p><h3 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h3><p>第一个程序，在父进程中使用wait</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) <span class="hljs-comment">// child</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child!(pid: %d)\n&quot;</span>, (<span class="hljs-type">int</span>)getpid());<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// parent</span><br>    &#123;<br>        <span class="hljs-type">int</span> wc = wait(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parent!(wc: %d  pid: %d)\n&quot;</span>, wc, (<span class="hljs-type">int</span>)getpid());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// I am child!(pid: 27378)</span><br><span class="hljs-comment">// I am parent!(wc: 27378  pid: 27377)</span><br></code></pre></td></tr></table></figure><p>可以看到wait的返回值恰好是子进程的pid</p><p>第二个程序，在子进程中使用wait</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) <span class="hljs-comment">// child</span><br>    &#123;<br>        <span class="hljs-type">int</span> wc = wait(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child!(wc:  %d  pid: %d)\n&quot;</span>, wc, (<span class="hljs-type">int</span>)getpid());<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// parent</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parent!(pid: %d)\n&quot;</span>, (<span class="hljs-type">int</span>)getpid());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// I am parent!(pid: 28697)</span><br><span class="hljs-comment">// I am child!(wc:  -1  pid: 28698)</span><br></code></pre></td></tr></table></figure><p>可以看到运行结果依然是先运行主进程，再运行子进程，值得注意的是，wait返回值为-1。</p><h3 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) <span class="hljs-comment">// child</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child!(pid: %d)\n&quot;</span>, (<span class="hljs-type">int</span>)getpid());<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// parent</span><br>    &#123;<br>        <span class="hljs-type">int</span> wc = waitpid(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parent!(wc: %d  pid: %d)\n&quot;</span>, wc, (<span class="hljs-type">int</span>)getpid());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// I am child!(pid: 27378)</span><br><span class="hljs-comment">// I am parent!(wc: 27378  pid: 27377)</span><br></code></pre></td></tr></table></figure><p>waitpid相比于wait的区别在于：<br />1 waitpid使我们可以等待指定的进程<br />2 waitpid提供了一个无阻塞的wait<br />3 waitpid支持工作控制</p><h3 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) <br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) <br>    &#123;<br>        close(STDOUT_FILENO);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output child\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;output parent\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;    <br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// output parent</span><br></code></pre></td></tr></table></figure><p>子进程不会影响到主进程。</p><h3 id="8"><a class="markdownIt-Anchor" href="#8"></a> 8</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123;<br>    <span class="hljs-type">int</span> pi[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> p = pipe(pi);<br>    <span class="hljs-keyword">if</span>(p &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// pipe failed</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;pipe failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rc[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) <br>    &#123;<br>        rc[i] = fork();<br>        <span class="hljs-keyword">if</span> (rc[i] &lt; <span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc[i] == <span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-keyword">switch</span>(i) <br>            &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    dup2(pi[<span class="hljs-number">1</span>], STDOUT_FILENO);<br>                    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;child input&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    dup2(pi[<span class="hljs-number">0</span>], STDIN_FILENO);<br>                    gets(buf);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child0 out (%s) in the child1\n&quot;</span>, buf);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    waitpid(rc[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    waitpid(rc[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// child0 out (child input) in the child1</span><br></code></pre></td></tr></table></figure><p>pipe创建一个管道，将两个进程连接到一起。<br />int wc = wait(NULL);<br />printf(“I am parent!(wc: %d  pid: %d)\n”, wc, (int)getpid());<br />}<br />return 0;<br />}<br />// 运行结果<br />// I am child!(pid: 27378)<br />// I am parent!(wc: 27378  pid: 27377)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">可以看到wait的返回值恰好是子进程的pid<br><br>第二个程序，在子进程中使用wait<br><br>```c<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) <span class="hljs-comment">// child</span><br>    &#123;<br>        <span class="hljs-type">int</span> wc = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child!(wc:  %d  pid: %d)\n&quot;</span>, wc, (<span class="hljs-type">int</span>)<span class="hljs-built_in">getpid</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// parent</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parent!(pid: %d)\n&quot;</span>, (<span class="hljs-type">int</span>)<span class="hljs-built_in">getpid</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// I am parent!(pid: 28697)</span><br><span class="hljs-comment">// I am child!(wc:  -1  pid: 28698)</span><br></code></pre></td></tr></table></figure><p>可以看到运行结果依然是先运行主进程，再运行子进程，值得注意的是，wait返回值为-1。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>ostep</category>
      
      <category>homework详解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ostep homework(4)</title>
    <link href="/2022/05/19/Ostep(4)/"/>
    <url>/2022/05/19/Ostep(4)/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-抽象进程-homework详解"><a class="markdownIt-Anchor" href="#第4章-抽象进程-homework详解"></a> 第4章 <em>抽象：进程</em>  homework详解</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>开个新坑，csapp读到汇编看不下去了，故转战操作系统。<br />题目在书中有提到，这里不再重复赘述（懒）。<br />实验材料从官网下载就好，贴个<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">传送门</a>。<br />建议在实验开始之前仔细阅读 readme 文件。</p><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><p>笔者采用的是Ubuntu22.04的虚拟机。<br />本次作业用到 cpu-intro 文件</p><h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2><h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h3><figure class="highlight tap"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs tap">$ ./process-run.py -l 5:100,5:100 -c -p<br>Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>       RUN:cpu         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 2 </span>       RUN:cpu         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 3 </span>       RUN:cpu         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 4 </span>       RUN:cpu         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 5 </span>       RUN:cpu         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 6 </span>          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 7 </span>          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 8 </span>          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 9 </span>          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 10 </span>          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br><br>Stats: Total Time 10<br>Stats: CPU Busy<span class="hljs-number"> 10 </span>(100.00%)<br>Stats: IO Busy <span class="hljs-number"> 0 </span>(0.00%)<br></code></pre></td></tr></table></figure><p>运行完第一个进程紧接着运行第二个进程，cpu利用率100%。</p><h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ./process-run.py -l 4:100,1:0 -c -p<br>Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>       RUN:cpu         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 2 </span>       RUN:cpu         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 3 </span>       RUN:cpu         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 4 </span>       RUN:cpu         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 5 </span>          DONE        RUN:io            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 6 </span>          DONE       WAITING                           1<br> <span class="hljs-number"> 7 </span>          DONE       WAITING                           1<br> <span class="hljs-number"> 8 </span>          DONE       WAITING                           1<br> <span class="hljs-number"> 9 </span>          DONE       WAITING                           1<br><span class="hljs-number"> 10 </span>          DONE       WAITING                           1<br> 11*          DONE   RUN:io_done            <span class="hljs-number"> 1 </span>         <br><br>Stats: Total Time 11<br>Stats: CPU Busy<span class="hljs-number"> 6 </span>(54.55%)<br>Stats: IO Busy <span class="hljs-number"> 5 </span>(45.45%)<br></code></pre></td></tr></table></figure><p>这里先运行第一个进程时会阻塞第二个进程运行，所以要依此进行。</p><h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ./process-run.py -l 1:0,4:100 -c -p<br>Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>        RUN:io         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 2 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 3 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 4 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 5 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 6 </span>       WAITING          DONE                           1<br>  7*   RUN:io_done          DONE            <span class="hljs-number"> 1 </span>         <br><br>Stats: Total Time 7<br>Stats: CPU Busy<span class="hljs-number"> 6 </span>(85.71%)<br>Stats: IO Busy <span class="hljs-number"> 5 </span>(71.43%)<br></code></pre></td></tr></table></figure><p>容易发现交换顺序是会对运行时间和效率产生影响的，运行io时可以同时运行cpu。</p><h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ./process-run.py -l 1:0,4:100 -c -S SWITCH_ON_END -p<br>Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>        RUN:io         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 2 </span>       WAITING         READY                           1<br> <span class="hljs-number"> 3 </span>       WAITING         READY                           1<br> <span class="hljs-number"> 4 </span>       WAITING         READY                           1<br> <span class="hljs-number"> 5 </span>       WAITING         READY                           1<br> <span class="hljs-number"> 6 </span>       WAITING         READY                           1<br>  7*   RUN:io_done         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 8 </span>          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 9 </span>          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 10 </span>          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 11 </span>          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br><br>Stats: Total Time 11<br>Stats: CPU Busy<span class="hljs-number"> 6 </span>(54.55%)<br>Stats: IO Busy <span class="hljs-number"> 5 </span>(45.45%)<br></code></pre></td></tr></table></figure><p>如果限制了当进行io操作时，系统不允许切换到另一个进程，则产生的效果和不交换顺序时相同。</p><h3 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ./process-run.py -l 1:0,4:100 -c -S SWITCH_ON_IO -p<br>Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>        RUN:io         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 2 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 3 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 4 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 5 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 6 </span>       WAITING          DONE                           1<br>  7*   RUN:io_done          DONE            <span class="hljs-number"> 1 </span>         <br><br>Stats: Total Time 7<br>Stats: CPU Busy<span class="hljs-number"> 6 </span>(85.71%)<br>Stats: IO Busy <span class="hljs-number"> 5 </span>(71.43%)<br></code></pre></td></tr></table></figure><p>和3一致，不做解释。</p><h3 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ./process-run.py -l 3:0,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p<br>Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>       PID:<span class="hljs-number"> 2 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>        RUN:io         READY         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 2 </span>       WAITING       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 3 </span>       WAITING       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 4 </span>       WAITING       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 5 </span>       WAITING       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 6 </span>       WAITING       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br>  7*         READY          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 8 </span>         READY          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 9 </span>         READY          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 10 </span>         READY          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 11 </span>         READY          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 12 </span>   RUN:io_done          DONE          DONE            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 13 </span>        RUN:io          DONE          DONE            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 14 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 15 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 16 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 17 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 18 </span>       WAITING          DONE          DONE                           1<br> 19*   RUN:io_done          DONE          DONE            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 20 </span>        RUN:io          DONE          DONE            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 21 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 22 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 23 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 24 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 25 </span>       WAITING          DONE          DONE                           1<br> 26*   RUN:io_done          DONE          DONE            <span class="hljs-number"> 1 </span>         <br><br>Stats: Total Time 26<br>Stats: CPU Busy<span class="hljs-number"> 16 </span>(61.54%)<br>Stats: IO Busy <span class="hljs-number"> 15 </span>(57.69%)<br></code></pre></td></tr></table></figure><p>在运行完第一个io操作后没有及时继续运行该进程，导致该进程后续进行io操作时浪费了时间。</p><h3 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ./process-run.py -l 3:0,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -p<br>Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>       PID:<span class="hljs-number"> 2 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>        RUN:io         READY         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 2 </span>       WAITING       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 3 </span>       WAITING       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 4 </span>       WAITING       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 5 </span>       WAITING       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 6 </span>       WAITING       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br>  7*   RUN:io_done          DONE         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 8 </span>        RUN:io          DONE         READY            <span class="hljs-number"> 1 </span>         <br> <span class="hljs-number"> 9 </span>       WAITING          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 10 </span>       WAITING          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 11 </span>       WAITING          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 12 </span>       WAITING          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 13 </span>       WAITING          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> 14*   RUN:io_done          DONE          DONE            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 15 </span>        RUN:io          DONE          DONE            <span class="hljs-number"> 1 </span>         <br><span class="hljs-number"> 16 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 17 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 18 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 19 </span>       WAITING          DONE          DONE                           1<br><span class="hljs-number"> 20 </span>       WAITING          DONE          DONE                           1<br> 21*   RUN:io_done          DONE          DONE            <span class="hljs-number"> 1 </span>         <br><br>Stats: Total Time 21<br>Stats: CPU Busy<span class="hljs-number"> 16 </span>(76.19%)<br>Stats: IO Busy <span class="hljs-number"> 15 </span>(71.43%)<br></code></pre></td></tr></table></figure><p>本题在6的基础上做了改善，立即运行进程，对运行时间做了优化。</p><h3 id="8"><a class="markdownIt-Anchor" href="#8"></a> 8</h3><p>第8题是一道开放性问题，为了让读者能够理解进程运行的奥秘，请读者自行实践。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>ostep</category>
      
      <category>homework详解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1 Date lab详解</title>
    <link href="/2022/05/11/Csapp1/"/>
    <url>/2022/05/11/Csapp1/</url>
    
    <content type="html"><![CDATA[<h1 id="date-lab详解"><a class="markdownIt-Anchor" href="#date-lab详解"></a> Date lab详解</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>最近在读大名鼎鼎的cs:app，很懵懂，开一个专栏记录解答下本课程自带的lab。</p><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><p>笔者使用Ubuntu22.04的虚拟机，用vscode做主要编程软件。<br />lab相关文件可以从课程页面下载，这里放置课程链接：<a href="http://csapp.cs.cmu.edu/3e/labs.html">csapp lab</a><br />再贴一个链接，里面包含有中文版的详细描述，简洁明了：<a href="https://hansimov.gitbook.io/csapp/">csapp中文版电子书及lab</a><br />关于实验环境的配置这里不再赘述。</p><h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2><p>首先贴上一张表格，里面是这个lab需要实现的13个函数</p><table><thead><tr><th>函数名</th><th>描述</th><th>难度级别</th><th>最大操作符数</th></tr></thead><tbody><tr><td>bitXor(x,y)</td><td>x 异或 y</td><td>1</td><td>14</td></tr><tr><td>tmin()</td><td>最小的整数补码</td><td>1</td><td>4</td></tr><tr><td>isTmax(x)</td><td>x 为最大的整数补码时为真</td><td>1</td><td>10</td></tr><tr><td>allOddBits(x)</td><td>x 的奇数位都为 1 时为真</td><td>2</td><td>12</td></tr><tr><td>negate(x)</td><td>使用 ~ 操作符返回 -x</td><td>2</td><td>5</td></tr><tr><td>isAsciDigit(x)</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>30</mn><mo>⩽</mo><mi>x</mi><mo>⩽</mo><mn>0</mn><mi>x</mi><mn>39</mn></mrow><annotation encoding="application/x-tex">0x30⩽x⩽0x39</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">3</span><span class="mord">9</span></span></span></span> 时为真</td><td>3</td><td>15</td></tr><tr><td>conditional</td><td>等同于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo stretchy="false">?</mo><mi>y</mi><mo>:</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x ? y : z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mclose">?</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span></td><td>3</td><td>16</td></tr><tr><td>isLessOrEqual(x, y)</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⩽</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x⩽y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 时为真，否则为假</td><td>3</td><td>24</td></tr><tr><td>logicalNeg(x))</td><td>不用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mclose">!</span></span></span></span> 运算符计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">!</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">!x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mclose">!</span><span class="mord mathdefault">x</span></span></span></span></td><td>4</td><td>12</td></tr><tr><td>howManyBits(x)</td><td>用补码表示 x 的最小位数</td><td>4</td><td>90</td></tr><tr><td>floatScale2(uf)</td><td>对于浮点参数 f，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">2 \times f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的位级等价数</td><td>4</td><td>30</td></tr><tr><td>floatFloat2Int(uf)</td><td>对于浮点参数 f，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">(int) f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的位级等价数</td><td>4</td><td>30</td></tr><tr><td>floatPower2(x)</td><td>对于整数 x，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.</mn><msup><mn>0</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2.0^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></td><td>4</td><td>30</td></tr></tbody></table><h3 id="1-bitxorint-x-int-y"><a class="markdownIt-Anchor" href="#1-bitxorint-x-int-y"></a> 1 bitXor(int x, int y)</h3><p><strong>要求:</strong> x^y using only ~ and &amp;</p><p><strong>运算符:</strong>  ~ &amp;</p><p><strong>解析:</strong><br />考察对几个位运算符的理解程度。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-tminvoid"><a class="markdownIt-Anchor" href="#2-tminvoid"></a> 2 tmin(void)</h3><p><strong>要求:</strong> return minimum two’s complement integer</p><p><strong>运算符:</strong> !  ~  &amp;  ^  |  +  &lt;&lt;  &gt;&gt;</p><p><strong>解析:</strong><br />由于int类型为4字节，其对应最小的整数补码为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><munder><munder><mrow><mn>0</mn><mo>…</mo><mn>0</mn></mrow><mo stretchy="true">⏟</mo></munder><mn>31</mn></munder></mrow><annotation encoding="application/x-tex">1\underbrace{0\ldots0}_{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.943548em;vertical-align:-1.299108em;"></span><span class="mord">1</span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6444400000000001em;"><span style="top:-1.700892em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000000000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64444em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.299108em;"><span></span></span></span></span></span></span></span></span>，直接输出了。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-istmaxint-x"><a class="markdownIt-Anchor" href="#3-istmaxint-x"></a> 3 isTmax(int x)</h3><p><strong>要求:</strong> returns 1 if x is the maximum, two’s complement number</p><p><strong>运算符:</strong> ! ~ &amp; ^ | +</p><p><strong>解析:</strong><br />当 x 为最大整数时，补码表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>01</mn><mo>…</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">01\ldots1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span></span></span></span>，即符号位为 0，其余位为 1，可得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn><mo>=</mo><mtext> </mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">x + 1 = ~x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace nobreak"> </span><span class="mord mathdefault">x</span></span></span></span>。然而当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 时，前述等式也成立，因此需要排除掉这种情况。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-keyword">return</span> ! ((~x ^ (x+<span class="hljs-number">1</span>)) | !(x+<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-alloddbitsint-x"><a class="markdownIt-Anchor" href="#4-alloddbitsint-x"></a> 4 allOddBits(int x)</h3><p><strong>要求:</strong> return 1 if all odd-numbered bits in word set to 1</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />构造出一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>s</mi><mi>k</mi><mo>=</mo><munder><munder><mrow><mn>1010</mn><mo>…</mo><mn>10</mn></mrow><mo stretchy="true">⏟</mo></munder><mn>32</mn></munder></mrow><annotation encoding="application/x-tex">mask = \underbrace{1010\ldots10}_{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.943548em;vertical-align:-1.299108em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6444400000000001em;"><span style="top:-1.700892em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.0000000000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64444em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.299108em;"><span></span></span></span></span></span></span></span></span>，再让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>s</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">mask</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 进行 &amp; 操作，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的偶数位全部置0，再进行一次异或操作，不要忘记取反。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-type">int</span> mask = <span class="hljs-number">0xAA</span> + (<span class="hljs-number">0xAA</span> &lt;&lt; <span class="hljs-number">8</span>);<br>  mask = mask + (mask &lt;&lt; <span class="hljs-number">16</span>);<br>  <span class="hljs-keyword">return</span> !((mask &amp; x) ^ mask);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-negateint-x"><a class="markdownIt-Anchor" href="#5-negateint-x"></a> 5 negate(int x)</h3><p><strong>要求:</strong> return -x</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />用补码表示，负数比整数取值范围多1</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-keyword">return</span> ~x + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-isasciidigitint-x"><a class="markdownIt-Anchor" href="#6-isasciidigitint-x"></a> 6 isAsciiDigit(int x)</h3><p><strong>要求:</strong> return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’)</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />问题可以转化为满足下面式子时返回1，否则返回0：$$(x - 0x30 &gt;= 0) &amp;&amp; (0x39 - x) &gt;=0$$与首位为1的二进制数进行&amp;操作，可以判断出二进制数是否为负，借此方法容易解决。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-type">int</span> TMIN = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;<br>  <span class="hljs-keyword">return</span> !((x + ~<span class="hljs-number">0x30</span> + <span class="hljs-number">1</span>) &amp; TMIN) &amp; !((<span class="hljs-number">0x39</span> + ~x + <span class="hljs-number">1</span>) &amp; TMIN);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-conditionalint-x-int-y-int-z"><a class="markdownIt-Anchor" href="#7-conditionalint-x-int-y-int-z"></a> 7 conditional(int x, int y, int z)</h3><p><strong>要求:</strong> same as x ? y : z</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />! 运算将 x 映射到 [0, 1] 区间，使用函数 f(x)=!x+(−1) 取出 y，则 ∼f(x) 取出 z。<br />当 x≠0时，f(x)=−1，其位模式全为 1，因此 f(x)&amp;y=y。<br />当 x=0 时，f(x)=0，其位模式全为 0，因此 f(x)&amp;y=0。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;<br>  x = !x + ~<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> (y &amp; x) | (z &amp; ~x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-islessorequalint-x-int-y"><a class="markdownIt-Anchor" href="#8-islessorequalint-x-int-y"></a> 8 isLessOrEqual(int x, int y)</h3><p><strong>要求:</strong> if x &lt;= y  then return 1, else return 0</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />将问题转换为下列公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mi>x</mi><mo>&lt;</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y &gt;=0 \&amp;\&amp; x &lt;0) || ((x * y &gt;= 0) \&amp;\&amp; (y + (-x) &gt;= 0)) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord">∣</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>具体见代码注释。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-type">int</span> signX = (x &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 判断x是否为负</span><br>  <span class="hljs-type">int</span> signY = (y &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 判断y是否为负</span><br>  <span class="hljs-type">int</span> signXSubY = ((y + ~x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 判断y+(-x)是否为负</span><br>  <span class="hljs-keyword">return</span> (signX &amp; ~signY) | (!(signX ^ signY) &amp; !signXSubY);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-logicalnegint-x"><a class="markdownIt-Anchor" href="#9-logicalnegint-x"></a> 9 logicalNeg(int x)</h3><p><strong>要求:</strong> implement the ! operator, using all of the legal operators except !</p><p><strong>运算符:</strong> ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />当 x≠0 时，x|(−x) 的符号位必然为 1</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-keyword">return</span> ~(x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>&amp;<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-howmanybitsint-x"><a class="markdownIt-Anchor" href="#10-howmanybitsint-x"></a> 10 howManyBits(int x)</h3><p><strong>要求:</strong> return the minimum number of bits required to represent x in two’s complement</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x≥0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，位数取决于 1 的最高位数；当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，位数则取决于 0 的最高位数（根据补码表示的定义，符号位起连续的 1 可合并起来用一个位表示）。</p><p>首先考虑将负数取反，将问题统一成计算 1 的最高位，利用算术右移即可完成， 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&gt;</mo><mo>&gt;</mo><mn>31</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x=x⊕(x&gt;&gt;31)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><p>然后使用二分法计算 1 的最高位：判断高 16 位是否大于 0，若大于 0 说明高 16 位中存在 1，否则 1 在低 16 位中。使用 conditional 函数更新 x（取出高 16 位或低 16 位）。迭代判断 8 位、4 位等等。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-type">int</span> bit;<br>  <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>  x = x ^ (x &gt;&gt; <span class="hljs-number">31</span>); <span class="hljs-comment">// 将负数取反</span><br><br>  bit = !!(x &gt;&gt; <span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-number">4</span>;<br>  res = res + bit;<br>  x = x &gt;&gt; bit;<br><br>  bit = !!(x &gt;&gt; <span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-number">3</span>;<br>  res = res + bit;<br>  x = x &gt;&gt; bit;<br><br>  bit = !!(x &gt;&gt; <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">2</span>;<br>  res = res + bit;<br>  x = x &gt;&gt; bit;<br><br>  bit = !!(x &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">1</span>;<br>  res = res + bit;<br>  x = x &gt;&gt; bit;<br><br>  bit = !!(x &gt;&gt; <span class="hljs-number">1</span>);<br>  res = res + bit;<br>  x = x &gt;&gt; bit;<br><br>  <span class="hljs-keyword">return</span> x + res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-floatscale2unsigned-uf"><a class="markdownIt-Anchor" href="#11-floatscale2unsigned-uf"></a> 11 floatScale2(unsigned uf)</h3><p><strong>要求:</strong> Return bit-level equivalent of expression <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">2 \times f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> for floating point argument f. Both the argument and result are passed as unsigned int’s, but they are to be interpreted as the bit-level representation of single-precision floating point values. When argument is NaN, return argument.</p><p><strong>运算符:</strong> Any integer/unsigned operations incl.  ||, &amp;&amp;. also if, while</p><p><strong>解析:</strong></p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h3 id="12-floatfloat2intunsigned-uf"><a class="markdownIt-Anchor" href="#12-floatfloat2intunsigned-uf"></a> 12 floatFloat2Int(unsigned uf)</h3><p><strong>要求:</strong> Return bit-level equivalent of expression (int) f for floating point argument f.</p><p><strong>运算符:</strong> Any integer/unsigned operations incl.  ||, &amp;&amp;. also if, while</p><p><strong>解析:</strong></p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h3 id="13-floatpower2int-x"><a class="markdownIt-Anchor" href="#13-floatpower2int-x"></a> 13 floatPower2(int x)</h3><p><strong>要求:</strong> Return bit-level equivalent of the expression <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.</mn><msup><mn>0</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2.0^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span> (2.0 raised to the power x) for any 32-bit integer x.</p><p><strong>运算符:</strong> Any integer/unsigned operations incl.  ||, &amp;&amp;. also if, while</p><p><strong>解析:</strong></p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
      <category>csapp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲</title>
    <link href="/2022/05/04/Suanfa2/"/>
    <url>/2022/05/04/Suanfa2/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>随缘更新</p><h2 id="1-01背包问题"><a class="markdownIt-Anchor" href="#1-01背包问题"></a> 1、01背包问题</h2><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 件物品和一个容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的背包。放入第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>件物品花费的费用是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> ，得到的价值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> ，求将哪些物品装入背包可使价值总和最大。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。<br />用子问题定义状态：即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品恰放入一个容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的背包可以获得的最大价值（这里原文中使用了“恰”，但实际并不需要正好装满，在初始化可以区分开这两种情况，下文有提及）。则其<strong>状态转移方程</strong>便是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mi mathvariant="normal">−</mi><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i][j]=max(f[i−1][j] , f[i−1][j−c[i]] + w[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">−</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>“将前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品放入容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的背包中”这个<strong>子问题</strong>，若只考虑第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品的策略（放或不放），那么就可以转化为一个只牵扯前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">i−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 件物品的问题。</p><p>如果<strong>不放</strong>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品，那么问题就转化为“ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">i−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 件物品放入容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的背包中”，最大价值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i−1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> ；如果<strong>放</strong>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品，那么问题就转化为“前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">i−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 件物品放入剩下的容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi mathvariant="normal">−</mi><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j−c[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">−</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 的背包中”，此时能获得的最大价值就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mi mathvariant="normal">−</mi><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i−1][j−c[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">−</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span> 再加上通过放入第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品获得的价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>。</p><h3 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h3><p>后续再更</p><h2 id="2-完全背包问题"><a class="markdownIt-Anchor" href="#2-完全背包问题"></a> 2、完全背包问题</h2><h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3><p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 种物品和一个容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的背包，每种物品都有<strong>无限</strong>件可用。第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 种物品的费用是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>  ，价值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>本题相比于01背包增加了每件物品有无限件这一条件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 件、取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 件、取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> 等很多种。如果仍然按照解01背包时的思路，令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 种物品恰放入一个容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的背包的最大权值。仍然可以按照每种物品不同的策略写出<strong>状态转移方程</strong>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mi mathvariant="normal">−</mi><mi>k</mi><mo>×</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>×</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>∣</mo><mn>0</mn><mo>≤</mo><mi>k</mi><mo>×</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">f[i][j]=max(f[i−1][j−k \times c[i]]+k \times w[i])∣0≤k \times c[i]≤j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03：运输层</title>
    <link href="/2022/04/03/Cn3/"/>
    <url>/2022/04/03/Cn3/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="一-概述和运输层服务"><a class="markdownIt-Anchor" href="#一-概述和运输层服务"></a> 一、概述和运输层服务</h1><p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信</strong>（logic communication）功能。<br /><img src="/img/cn3.1.png" alt="逻辑通信" /><br /><img src="/img/cn3.2.png" alt="概览" /></p><h2 id="11-运输层和网络层的关系"><a class="markdownIt-Anchor" href="#11-运输层和网络层的关系"></a> 1.1 运输层和网络层的关系</h2><p>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。<br /><img src="/img/cn3.3.png" alt="运输层和网络层的逻辑通信" /></p><h2 id="12-因特网运输层概述"><a class="markdownIt-Anchor" href="#12-因特网运输层概述"></a> 1.2 因特网运输层概述</h2><p>因特网网络层协议有一个名字叫<strong>IP</strong>，即国际协议。IP尽最大努力交付报文段，但不做任何确保，因此它是<strong>不可靠服务</strong>。每台主机至少有一个IP地址。</p><p>UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务，这种服务被称为运输层的<strong>多路运输</strong>与<strong>多路分解</strong>。其次，UDP和TCP还可以通过在其报文段首部中包括差错检查字段而提供<strong>完整性检查</strong>。UDP仅能提供这两种服务，TCP还有附加服务（可靠数据传输、拥塞控制等）。</p><h1 id="二-多路复用与多路分解"><a class="markdownIt-Anchor" href="#二-多路复用与多路分解"></a> 二、多路复用与多路分解</h1><blockquote><p><strong>多路分解</strong>：将运输层报文段中的数据交付到正确的套接字。<br /><strong>多路复用</strong>：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（用于多路分解）从而生成报文段，然后将报文段传递给网络层。</p></blockquote><p>每个报文段使用<strong>源端口号字段</strong>（sourse port number field）和<strong>目的端口号字段</strong>（destination port number field）来指示该报文段所要交付到的套接字。端口号是一个16比特的数，其大小在0-65535之间。0-1023范围的端口号称为<strong>周知端口号</strong>（well-known port number），它们保留给注入HTTP和FTP之类的周知应用层协议。<br /><img src="/img/cn3.4.png" alt="运输层报文段中的源与目的端口字段" /></p><h2 id="21-无连接的多路复用与多路分解"><a class="markdownIt-Anchor" href="#21-无连接的多路复用与多路分解"></a> 2.1 无连接的多路复用与多路分解</h2><p>在运输层，无连接的网络传输是通过UDP来实现的。<strong>UDP报文中只有源端口号和目的端口号</strong>，一个UDP套接字是由一个含有目的IP地址和目的端口号的<strong>二元组</strong>来全面标识的。</p><p>例如主机A产生了一个UDP报文段，报文段中就会包括源端口号（11111）、目的端口号（22222）、程序数据（还有两个其他的值，在这里我们不关心）。然后，运输层将生成的报文段交给网络层。网络层将其放到一个IP数据报中，并提供尽力而为的交付，将其发送到主机B中。如果该报文到达主机B，主机B运输层就会检查该报文的端口号，并将该报文段传递给套接字的端口号为接收到的报文段的目的端口号（22222）的套接字。从而实现了进程间的网络通信。而源端口号的作用是为了让主机B能向主机A发送信息的，也就是说，当主机B在接收到主机A的数据后，要向主机A发送一个回应时，主机B发送的报文段的目的端口号就是11111.</p><h2 id="22-面向连接的多路复用与多路分解"><a class="markdownIt-Anchor" href="#22-面向连接的多路复用与多路分解"></a> 2.2 面向连接的多路复用与多路分解</h2><p>在运输层中面向连接的网络传输多使用TCP，而TCP套接字和UDP套接字之间有一个细微的差别，就是，TCP套接字是由一个<strong>四元组</strong>（源IP地址、源端口号，目的IP地址，目的端口号）来标识的。这样，当一个TCP报文段从网络到达一台主机时，主机会使用全部4个值来将报文段定向，即多路分解到相应的套接字。</p><p>与UDP不同的是，两个具有不同源IP或源端口号的到达的TCP报文段将被重定向到两个不同的套接字。</p><p>尽管如此，而TCP的多路利用和多路分解的工作原理与无连接的UDP的多路复用和多路分解的原理还是大致一样的。</p><h2 id="23-web服务器与tcp"><a class="markdownIt-Anchor" href="#23-web服务器与tcp"></a> 2.3 Web服务器与TCP</h2><ul><li>连接套接字与进程之间并非总是有着一一对应的关系 。</li><li>当今的高性能 Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。（线程可被看作是一个轻量级的子进程。）</li><li>如果客户与服务器使用持续 HTTP ，则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换 HTTP 报文 。然而，如果客户与服务器使用非持续连接，则对每一对请求/响应都创建一个新的 TCP连接并在随后关闭，因此对每一对请求/响应创建一个新的套接字并在随后关闭 。 这种套接字的频繁创建与关闭会严重地影响一个繁忙的Web服务器的性能(虽然有许多操作系统技巧可用来减轻这个问题的影响) 。</li></ul><h1 id="三-无连接运输udp"><a class="markdownIt-Anchor" href="#三-无连接运输udp"></a> 三、无连接运输：UDP</h1><p>UDP只提供复用和分解，它有如下优点：</p><ul><li><strong>关于何时、发送什么数据的应用层控制更为精细</strong>：这是因为一旦应用程序将数据交给UDP，UDP就会打包将其发送给网络层，不会受到传输层的调节，这在一些实时应用中比较实用；当然，应用程序还可以通过UDP+自主开发一些功能的模式来扩展UDP。</li><li><strong>无需建立连接</strong>：所以就不会引入额外的时延。这也可能是DNS使用UDP而不是TCP的主要原因，如果使用TCP的话，DNS服务将会慢很多；HTTP使用TCP的主要原因是对TCP的可靠性的依赖超过对速度的要求；</li><li><strong>无需维护连接状态</strong>：TCP为了实现可靠数据传输和拥塞控制需要在端系统中维护一些参数，这些参数包括：接收和发送的缓存、拥塞控制参数、确认号和序号；这些参数信息都是必须的；而UDP因为不建立连接，所以自然也就不需要维护这些状态，这就减少了时空开销；</li><li><strong>分组首部更小</strong>：TCP有20字节的首部开销，而UDP只有8字节；</li></ul><h2 id="31-udp报文段结构"><a class="markdownIt-Anchor" href="#31-udp报文段结构"></a> 3.1 UDP报文段结构</h2><p><img src="/img/cn3.5.png" alt="UDP报文段结构" /></p><h2 id="32-udp检验和"><a class="markdownIt-Anchor" href="#32-udp检验和"></a> 3.2 UDP检验和</h2><p>UDP检验和的需要计算UDP头部（计算的时候校验和部分的16位需要置0）加数据部分，还需要加上UDP伪头部。计算步骤如下：</p><ol><li>将UDP伪头部、UDP头部和数据部分全部用16进制数表示。</li><li>将第一个16进制数与第二个16进制数相加，得到一个32位的数，如果32位数的高16位大于0，需要将高16位与低16位再相加，得到一个32位的数，直到高16位为0，得到这一次相加的结果。</li><li>将上一步得到的16位数与第三个数16进制的数相加，重复第二步，直到累加完所有的16进制数，并且得到的结果为16进制数。</li><li>将累加最后得到的16进制数取反，得到校验和。</li></ol><h1 id="四-可靠数据传输原理"><a class="markdownIt-Anchor" href="#四-可靠数据传输原理"></a> 四、可靠数据传输原理</h1><p><img src="/img/cn3.6.png" alt="提供的服务" /><br /><img src="/img/cn3.7.png" alt="服务实现" /></p><h2 id="41-构造可靠数据传输协议"><a class="markdownIt-Anchor" href="#41-构造可靠数据传输协议"></a> 4.1 构造可靠数据传输协议</h2><h3 id="411-rdt-10"><a class="markdownIt-Anchor" href="#411-rdt-10"></a> 4.1.1 rdt 1.0</h3><p>rdt1.0是基于<strong>理想情况</strong>下的协议，假设所有信道都是可靠的，没有比特位的翻转，没有数据包的丢失与超时，所以rdt1.0的传输功能就是发送方发送数据，接收方接受数据。<br /><img src="/img/cn3.8.png" alt="用于完全可靠信道的协议" /></p><h3 id="412-rdt-20"><a class="markdownIt-Anchor" href="#412-rdt-20"></a> 4.1.2 rdt 2.0</h3><p>rdt2.0在rdt1.0的基础上解决了比特位差错的问题，这里的比特位差错发生在运输层下面的不可信信道中数据包中的1可能会变0，0可能会变成1。</p><p>rdt2.0增加了3种新机制：</p><ul><li>差错检测</li><li>接收者反馈接受信息（ACK,NAK）</li><li>重传</li></ul><p>在运输层对应用层的数据进行打包处理时，新增checksum（校验和），从而接收端可以对其数据包进行检验，如果正确，返回ACK，发送者继续发送下一个数据包；如果不正确，返回NAK，发送者重传数据。</p><p><img src="/img/cn3.9.png" alt="" /><br /><img src="/img/cn3.10.png" alt="" /></p><p>但是rdt2.0有着一个致命的缺点，只考虑了发送方到接收方的数据传输，如果反馈信息ACK、NAK传输时发生比特位翻转会出现什么情况？如果ACK发生翻转，那么发送方会再次重复的发送相同的数据包；如果NAK发生翻转，那么发送方会认为数据传输情况很好，但是接收方却已经收到了一个错误的数据包。</p><h3 id="413-rdt-21"><a class="markdownIt-Anchor" href="#413-rdt-21"></a> 4.1.3 rdt 2.1</h3><p>在rdt2.0的基础之上，发送方在打包数据包时添加了0或者1编号，同样ACK,NAK字段上也添加了0、1字段，表示0、1号字段的确认或者否定。发送方就有了2种状态发送0号数据包，1号数据包，接收方也有了2种状态等待0号数据包和等待1号数据包。</p><blockquote><p>现在假设情景发送方向接收方发送0号数据包，如果接收方接收到0号数据包，返回ACK，但是ACK出现翻转，接收方处于等待1号数据状态，发送方重复发送0号数据，接收方会拒绝0号数据，避免重复。如果接收方接收到0号数据包出现错误，返回NAK，但是NAK出现翻转，接收方处于等待0号数据状态，发送方继续发送1号数据，接收方会拒绝1号数据，避免错序。</p></blockquote><h3 id="414-rdt-22"><a class="markdownIt-Anchor" href="#414-rdt-22"></a> 4.1.4 rdt 2.2</h3><p>dt2.2是在rdt2.1上的基础之上做了小小的改善，摒弃了NAK，只需采用ACK。我们在ACK的信息上加上了期望的顺序号。</p><blockquote><p>现在假设情景发送方向接收方发送0号数据包，如果接收方接收到0号数据包，返回（ACK，1），发送方接着发送1号数据包。如果接收方接收到0号数据包出现错误，返回（ACK，0），发送方重传0号数据包。</p></blockquote><p>rdt2.2之前的版本都重在处理数据包的<strong>比特位翻转</strong>情况，却没有考虑到数据包在传输过程中出现的<strong>数据包丢失</strong>问题，这样数据包丢失会使得网络处于拥塞状态。</p><h3 id="415-rdt-30"><a class="markdownIt-Anchor" href="#415-rdt-30"></a> 4.1.5 rdt 3.0</h3><p>rdt3.0在rdt2.2的基础之上处理了<strong>数据包丢失</strong>的情况，增加了<strong>计时器</strong>的机制，如果在RTT时间段内，发送方没有接收到反馈信息，那么发送方默认数据包已经丢失了，会自动重传。<br /><img src="/img/cn3.11.png" alt="" /><br /><img src="/img/cn3.12.png" alt="" /></p><h2 id="42-流水线可靠数据传输协议"><a class="markdownIt-Anchor" href="#42-流水线可靠数据传输协议"></a> 4.2 流水线可靠数据传输协议</h2><p>rdt 3.0性能不够，它的利用率很低：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mrow><mi>s</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>r</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">U_{sender}=\frac{L/R}{RTT+L/R} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>流水线可靠数据传输协议</strong> ：不使用停等方式，允许发送方发送多个分组而无需确认等待，这样会大大提升发送方信道的利用率。</p><p><img src="/img/cn3.13.png" alt="流水线可靠数据传输协议" /></p><ul><li><strong>必须增加序号范围</strong>，每个分组（不包含重传的）必须有唯一的序号<br />我们知道<strong>一个分组的序号存储在分组首部的固定长度字段</strong>中，序号字段长度为kbit,则该序号范围是[0,2^k-1].</li><li>发送方和接收方也需要能够<strong>缓存多个分组</strong><br />发送方：至少能够缓存那些已被发送但未被确认的分组</li><li>所需序号范围和缓存大小取决于协议是<strong>如何处理丢失、损坏及时延过大的分组</strong>，这里这类分组有两种方法：<strong>回退N步</strong>协议和<strong>选择重传</strong>协议</li></ul><h2 id="43-回退n步gbn或滑动窗口"><a class="markdownIt-Anchor" href="#43-回退n步gbn或滑动窗口"></a> 4.3 回退N步（GBN或滑动窗口）</h2><p>在GBN协议中，允许发送方发送多个分组而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p><p><img src="/img/cn3.14.png" alt="GBN中发送方看到的序号" /></p><p>通过基于ACK、无NAK的GBN协议的FSM图来了解GBN的原理：</p><p><img src="/img/cn3.15.png" alt="GBN发送方的扩展FSM描述" /><br /><img src="/img/cn3.16.png" alt="GBN接收方的扩展FSM描述" /></p><h2 id="44-选择重传sr协议"><a class="markdownIt-Anchor" href="#44-选择重传sr协议"></a> 4.4 选择重传（SR协议）</h2><p>GBN协议虽然实现了<strong>流水线式传输</strong>数据，提高了发送方信道的利用率,但是GBN有一个很大的缺陷就是一旦超时，会有许多<strong>不必要重传的分组</strong>被重新传送。尤其是当窗口长度N很大时，随着差错率的提升，信道中会充斥着不必要重传的分组。</p><p>SR协议原理：</p><ul><li><strong>发送方</strong>：<br />为每一个分组设置一个定时器，这样可以在某一个分组超时时对其单独进行重传。</li><li><strong>接收方</strong>：<br />SR接收方将确认一个正确接收的分组而不管其是否按序。在未出现分组丢失之前，正确接收到的分组都会被交付给上层。一旦出现分组丢失，失序的分组将被接收方<strong>缓存</strong>起来，直到所有丢失分组（即序号更小的分组）皆被接收为止，这时将缓存中的分组一起交付给上层。</li></ul><h1 id="五-面向连接的运输tcp"><a class="markdownIt-Anchor" href="#五-面向连接的运输tcp"></a> 五、面向连接的运输：TCP</h1><h2 id="51-tcp连接"><a class="markdownIt-Anchor" href="#51-tcp连接"></a> 5.1 TCP连接</h2><h3 id="511-tcp连接的特点"><a class="markdownIt-Anchor" href="#511-tcp连接的特点"></a> 5.1.1 TCP连接的特点</h3><ul><li><strong>面向连接</strong>：在一个应用进程可以开始向另一个应用进程发送数据之前，两个进程必须相互“握手”。</li><li><strong>全双工服务</strong>：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可在进程B流向进程A的同时，也从进程A流向进程B。</li><li><strong>点对点</strong>：在单个发送方与单个接收方之间的连接。</li></ul><h3 id="512-三次握手"><a class="markdownIt-Anchor" href="#512-三次握手"></a> 5.1.2 三次握手</h3><p>TCP是面向连接的，所以每次传输数据之前，必须要建立TCP连接，在TCP建立连接时主要解决三个层面问题：</p><ul><li>使连接的每一方都能确认对方的存在</li><li>协商连接中参数，比如各方窗口值，时间戳等</li><li>各方对运输资源如缓存大小、连接表等进行分配</li></ul><p><a href="/img/cn3.17.png">三次握手</a><br />默认情况下客户端client和服务端sever的TCP进程都处于<strong>CLOSED（关闭）状态</strong>。<br />服务端TCP服务进程先建立传输控制块TCB，然后服务端进入<strong>LISTEN状态</strong>，等待客户端连接请求。</p><ul><li><strong>第一次握手</strong>：客户端TCP进程也先建立传输控制块TCB，然后向服务端发送连接请求报文段，此时SYN=1,随机选定一个初始序号seq=x,，此报文不能携带数据，但是要消耗掉一个序号，发送完毕后，客户端进入SYN-SENT（同步已发送）状态</li><li><strong>第二次握手</strong>：服务端收到客户端请求连接报文段后，若同意建立连接，则发送确认报文，确认报文中SYN=1、ACK=1,确认号ack=x+1,同时随机选定一个自己序号seq=y,确认报文段同样不能携带数据，但是也要消耗掉一个序号，发送完毕后服务端进入SYN-RCVD（同步收到）状态</li><li><strong>第三次握手</strong>：客户端收到确认报文后，检查ACK=1，ack=x+1是否正确，若正确，则向服务端发送确认报文，确认报文中ACK=1,ack=y+1,seq=x+1,发送后进入ESTAB-LISHED状态，服务端收到确认报文后，也进入ESTAB-LISHED状态，此时双方TCP连接正式建立。</li></ul><p>上面的连接建立过程就是<strong>TCP三次握手</strong>。</p><h2 id="52-tcp报文段结构"><a class="markdownIt-Anchor" href="#52-tcp报文段结构"></a> 5.2 TCP报文段结构</h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用算法模板</title>
    <link href="/2022/03/31/Suanfa1/"/>
    <url>/2022/03/31/Suanfa1/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">DFS:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该DFS 框架以2D 坐标范围为例，来体现DFS 算法的实现思想。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100</span>;<br><span class="hljs-type">bool</span> vst[maxn][maxn]; <span class="hljs-comment">// 访问标记</span><br><span class="hljs-type">int</span> map[maxn][maxn]; <span class="hljs-comment">// 坐标范围</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 方向向量，(x,y)周围的四个方向</span><br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> <span class="hljs-comment">// 边界条件和约束条件的判断</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(!vst[x][y] &amp;&amp; ...) <span class="hljs-comment">// 满足条件</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">// 与约束条件冲突</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>vst[x][y]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 标记该节点被访问过</span><br><span class="hljs-keyword">if</span>(map[x][y]==G) <span class="hljs-comment">// 出现目标态G</span><br>&#123;<br>...... <span class="hljs-comment">// 做相应处理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">CheckEdge</span>(x+dir[i][<span class="hljs-number">0</span>],y+dir[i][<span class="hljs-number">1</span>])) <span class="hljs-comment">// 按照规则生成下一个节点</span><br><span class="hljs-built_in">dfs</span>(x+dir[i][<span class="hljs-number">0</span>],y+dir[i][<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有下层搜索节点，回溯</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>......<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100</span>;<br><span class="hljs-type">bool</span> vst[maxn][maxn]; <span class="hljs-comment">// 访问标记</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 方向向量</span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">State</span> <span class="hljs-comment">// BFS 队列中的状态数据结构</span><br>&#123;<br><span class="hljs-type">int</span> x,y; <span class="hljs-comment">// 坐标位置</span><br><span class="hljs-type">int</span> Step_Counter; <span class="hljs-comment">// 搜索步数统计器</span><br>&#125;;<br> <br>State a[maxn];<br> <br><span class="hljs-built_in">boolCheckState</span>(State s) <span class="hljs-comment">// 约束条件检验</span><br>&#123;<br><span class="hljs-keyword">if</span>(!vst[s.x][s.y] &amp;&amp; ...) <span class="hljs-comment">// 满足条件</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">// 约束条件冲突</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State st)</span></span><br><span class="hljs-function"></span>&#123;<br>queue &lt;State&gt; q; <span class="hljs-comment">// BFS 队列</span><br>State now,next; <span class="hljs-comment">// 定义2 个状态，当前和下一个</span><br>st.Step_Counter=<span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器清零</span><br>q.<span class="hljs-built_in">push</span>(st); <span class="hljs-comment">// 入队</span><br>vst[st.x][st.y]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 访问标记</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>now=q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取队首元素进行扩展</span><br><span class="hljs-keyword">if</span>(now==G) <span class="hljs-comment">// 出现目标态，此时为Step_Counter 的最小值，可以退出即可</span><br>&#123;<br>...... <span class="hljs-comment">// 做相关处理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br>next.x=now.x+dir[i][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 按照规则生成下一个状态</span><br>next.y=now.y+dir[i][<span class="hljs-number">1</span>];<br>next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>; <span class="hljs-comment">// 计数器加1</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">CheckState</span>(next)) <span class="hljs-comment">// 如果状态满足约束条件则入队</span><br>&#123;<br>q.<span class="hljs-built_in">push</span>(next);<br>vst[next.x][next.y]=<span class="hljs-number">1</span>; <span class="hljs-comment">//访问标记</span><br>&#125;<br>&#125;<br>q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 队首元素出队</span><br>&#125;<br> <span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>......<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02：应用层</title>
    <link href="/2022/03/28/Cn2/"/>
    <url>/2022/03/28/Cn2/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><blockquote><p><em><strong>纸上得来终觉浅，绝知此事要躬行。</strong></em></p></blockquote><h1 id="一-应用层协议原理"><a class="markdownIt-Anchor" href="#一-应用层协议原理"></a> 一、应用层协议原理</h1><p>研发网络应用程序的<strong>核心</strong>是写出能够运行在不同的端系统和通过网络彼此通信的程序。因此研发新应用时需要编写将在<strong>多台端系统</strong>上运行的软件。</p><h2 id="11-网络应用程序体系结构"><a class="markdownIt-Anchor" href="#11-网络应用程序体系结构"></a> 1.1 网络应用程序体系结构</h2><p><strong>应用程序体系结构</strong>（application architecture）明显不同于网络体系结构。网络体系结构是固定的，而应用程序体系结构由应用程序研发者设计。<br />应用程序体系结构目前有两种主流体系结构：<strong>客户-服务器体系结构</strong>或<strong>对等（P2P）体系结构</strong>。</p><h3 id="111-客户-服务器体系结构"><a class="markdownIt-Anchor" href="#111-客户-服务器体系结构"></a> 1.1.1 客户-服务器体系结构</h3><p>在客户-服务器体系结构中，有一个总是打开的主机称为<strong>服务器</strong>，它服务于来自许多其他称为<strong>客户</strong>的主机的请求。客户相互之间<strong>不直接通信</strong>。另一方面，该服务器具有固定的、周知的地址，该地址称为<strong>IP地址</strong>。</p><p><img src="/img/cn2.1.png" alt="客户-服务器体系结构" /></p><p>在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。为此，配备大量主机的<strong>数据中心</strong>常被用于创建强大的虚拟服务器。如谷歌在全球拥有30~50个数据中心。一个数据中心能够有数十万台服务器，它们必须要供电和维护。</p><h3 id="112-p2p体系结构"><a class="markdownIt-Anchor" href="#112-p2p体系结构"></a> 1.1.2 P2P体系结构</h3><p>在一个P2P体系结构中，对位于数据中心的专用服务器有最小的（或者没有）依赖。应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为<strong>对等方</strong>。因为这些对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的。<br /><img src="/img/cn2.2.png" alt="P2P体系结构" /></p><p>P2P最引人入胜的特性之一时自扩展性（self-scalability）。例如，在一个P2P共享文件中，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加服务能力。P2P体系结构也是成本有效的，因为它们通常不需要庞大的服务器基础设施和服务器带宽。</p><p>未来P2P应用面临三个主要挑战：<br />1 ISP友好。<br />2 安全性。<br />3 激励。</p><p>需要提及的是，某些应用具有<strong>混合</strong>的体系结构，它结合了客户-服务器和P2P的元素。例如，对于许多即时通信应用而言，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间（无需通过中间服务器）直接发送。</p><h2 id="12-进程通信"><a class="markdownIt-Anchor" href="#12-进程通信"></a> 1.2 进程通信</h2><p>在构建网络应用程序前，还需要对运行在多个端系统上的程序是如何互相通信有所了解。进行通信的实际上是<strong>进程</strong>（process）而不是程序。一个进程可以被认为是运行在端系统中的一个程序。</p><p>当进程运行在<strong>相同</strong>的端系统上时，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定。</p><p>在两个<strong>不同</strong>端系统上的进程，通过跨越计算机网络交换<strong>报文</strong>（message）而相互通信。<strong>发送进程</strong>生成并向网络中发送报文；<strong>接收进程</strong>接收这些报文并可能通过将报文发送回去进行响应。</p><h3 id="121-客户和服务器进程"><a class="markdownIt-Anchor" href="#121-客户和服务器进程"></a> 1.2.1 客户和服务器进程</h3><p>网络应用程序由成对的进程组成，这些进程通过网络相互发送报文。对每对通信进程，我i们通常将这两个进程之一标识为客户（client），而另一个进程标识为服务器（server）。</p><blockquote><p>在给定的一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程被标识为<strong>客户</strong>，在绘画开始时等待联系的进程是<strong>服务器</strong>。</p></blockquote><h3 id="122-进程与计算机网络之间的接口"><a class="markdownIt-Anchor" href="#122-进程与计算机网络之间的接口"></a> 1.2.2 进程与计算机网络之间的接口</h3><p>从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为<strong>套接字</strong>（socket）的软件接口向网络发送报文和从网络接收报文。</p><p>类比说明，进程类比为房子，套接字类比为门。一个进程向另一个房子发送报文就要将报文从门送出去，到另一个房子时再从门进去。</p><p><strong>套接字</strong>是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的<strong>应用程序编程接口</strong>（API）。应用程序开发者可以控制套接字在应用端的一切，但是对套接字在运输层端几乎没有控制权（仅限于①选择运输层协议；②也许能设定几个参数，如最大缓存和最大报文长度等）。<br /><img src="/img/cn2.3.png" alt="应用程序、套接字和下面的运输层协议" /></p><h3 id="123-进程寻址"><a class="markdownIt-Anchor" href="#123-进程寻址"></a> 1.2.3 进程寻址</h3><p>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个<strong>地址</strong>。为了标识该接收进程，需要定义两种信息：<br />——主机的地址；<br />——定义在目的主机中的接收进程的标识符。</p><p>在因特网中，主机由其IP地址标识。除此之外，发送进程还必须指定运行在接收主机上的接收进程（接收套接字）。目的地<strong>端口号</strong>（port number）用于这里，已经给流行的应用分配了特定的端口号。</p><h2 id="13-可供应用程序使用的运输服务"><a class="markdownIt-Anchor" href="#13-可供应用程序使用的运输服务"></a> 1.3 可供应用程序使用的运输服务</h2><p>在发送端的应用程序将报文推进给该套接字，在该套接字的另一侧，<strong>运输层协议</strong>负责使该报文进入接收进程的套接字。</p><p>包括因特网在内的很多网络提供了<strong>不止一种</strong>运输层协议。当开发一个应用时，必须要<strong>选择一种</strong>最能为你的应用需求提供恰当服务的协议。一个运输层协议能够为应用程序提供的服务可大体由四个方面进行分类：<strong>可靠数据传输</strong>、<strong>吞吐量</strong>、<strong>定时</strong>和<strong>安全性</strong>。</p><h3 id="131-可靠数据传输"><a class="markdownIt-Anchor" href="#131-可靠数据传输"></a> 1.3.1 可靠数据传输</h3><p>如果一个协议提供了确保数据交付的服务，就认为提供了<strong>可靠数据传输</strong>（reliable data transfer）。当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据能无差错地到达接收进程。</p><p>当一个运输层协议不提供可靠数据传输时，由发送进程发送地某些数据可能不能够到达接收进程。这可能被<strong>容忍丢失的应用</strong>（loss-tolerant application）所接受，如一些多媒体应用。</p><h3 id="132-吞吐量"><a class="markdownIt-Anchor" href="#132-吞吐量"></a> 1.3.2 吞吐量</h3><p>在沿着一条网络路径上的两个进程之间的通信会话场景中，<strong>可用吞吐量</strong>就是发送进程能够向接收进程交付比特的速率。因为其他会话将共享沿着该网络路径的带宽，并且因为这些会话将会到达和离开，该可用吞吐量将随时间波动。由此衍生出一种服务，即运输层协议能够以某种特定的速率提供<strong>确保</strong>的可用吞吐量。使用这种服务，应用程序能够请求r比特/秒的确保吞吐量，并且该运输协议能够确保可用吞吐量总是为至少r比特/秒。</p><p>具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong>（bandwidth-sensitive application），例如许多多媒体应用。<strong>弹性应用</strong>（elastic application）能够根据情况或多或少地利用可供使用的吞吐量，例如电子邮件、文件传输等。</p><h3 id="133-定时"><a class="markdownIt-Anchor" href="#133-定时"></a> 1.3.3 定时</h3><p>运输层协议也能够提供<strong>定时保证</strong>。如同具有吞吐量保证那样，定时保证能够以多种形式实现，咯如，发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。</p><p>这种服务对<strong>交互式实时应用程序</strong>有很大吸引力。对于非实时的应用，较低的时延总比较高的时延好，但对端到端的时延没有严格的约束。</p><h3 id="134-安全性"><a class="markdownIt-Anchor" href="#134-安全性"></a> 1.3.4 安全性</h3><p>运输层协议能够为应用程序提供一种或多种<strong>安全性服务</strong>。这种服务将在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。<br />例如，在<strong>发送主机</strong>中，运输协议能够<strong>加密</strong>由发送进程传输的所有数据；<br />在<strong>接受主机</strong>中，运输层协议能够在将数据交付给接收进程之前<strong>解密</strong>这些数据。</p><p>此外，运输协议还能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别。</p><h2 id="14-因特网提供的运输服务"><a class="markdownIt-Anchor" href="#14-因特网提供的运输服务"></a> 1.4 因特网提供的运输服务</h2><p>因特网（更一般的是TCP/IP网络）为应用程序提供两个运输层协议，即<strong>UDP</strong>和<strong>TCP</strong>。软件开发者为因特网创建新的应用时，首先要选择<strong>UDP</strong>或者<strong>TCP</strong>。每个协议为调用它们的应用程序提供了不同的服务集合。</p><h3 id="141-tcp服务"><a class="markdownIt-Anchor" href="#141-tcp服务"></a> 1.4.1 TCP服务</h3><p>TCP服务模型包括面向连接服务和可靠数据传输服务。</p><p>1 <strong>面向连接的服务</strong><br />在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的<strong>握手</strong>过程提示客户和服务器，使它们为大量分组的到来做好准备。</p><p>在握手阶段后。一个<strong>TCP连接</strong>（TCP connection）就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。</p><p>当应用程序结束报文发送时，必须拆除该连接。</p><p>2 <strong>可靠的数据传送服务</strong><br />通信进程能够依靠TCP，<strong>无差错、按适当顺序</strong>交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而<strong>没有字节的冗余和丢失</strong>。</p><p>除此之外，TCP协议还具有<strong>拥塞控制机制</strong>。当发送方和接收方之间的网络出现拥塞时，它会抑制发送进程（客户或服务器）。这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。TCP拥塞控制也试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。</p><h3 id="142-udp服务"><a class="markdownIt-Anchor" href="#142-udp服务"></a> 1.4.2 UDP服务</h3><p>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无线连接的，因此在两个进程通信前没有握手过程。UDP服务提供一种不可靠数据传送服务，并且没有拥塞控制机制。</p><h3 id="143-因特网运输协议所不提供的服务"><a class="markdownIt-Anchor" href="#143-因特网运输协议所不提供的服务"></a> 1.4.3 因特网运输协议所不提供的服务</h3><p>TCP提供了可靠的端到端数据传送，在应用层也可以很容易地用SSL来加强以提供安全服务。今天的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证。</p><h2 id="15-应用层协议"><a class="markdownIt-Anchor" href="#15-应用层协议"></a> 1.5 应用层协议</h2><p><strong>应用层协议</strong>（application-layer protrol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p><blockquote><p>特别是应用层协议定义了：<br />1 交换的报文<strong>类型</strong>，例如请求报文和响应报文<br />2 各种报文类型的<strong>语法</strong>，如报文中的各个字段及这些字段是如何描述的。<br />3 字段的<strong>语义</strong>，即这些字段中包含的信息的含义。<br />4 一个进程何时以及如何发送报文，对报文进行相应的<strong>规则</strong>。</p></blockquote><p>有些应用层协议是由RFC文档定义的，因此它们位于<strong>公共域</strong>中，例如HTTP。还有很多应用层协议是<strong>专用</strong>的，有意不为公共域使用。</p><p>应用层协议是网络应用的<strong>一部分</strong>。</p><h1 id="二-web和http"><a class="markdownIt-Anchor" href="#二-web和http"></a> 二、Web和HTTP</h1><p>在20世纪90年代初期，一个主要的新型应用即<strong>万维网</strong>（World Wide Web）登上舞台，它极大地改变了人们与工作环境内外交流的方式。对大多数用户而言，Web最具吸引力的是它的<strong>按需操作</strong>，即用户能看到想看的内容。</p><h2 id="21-http概况"><a class="markdownIt-Anchor" href="#21-http概况"></a> 2.1 HTTP概况</h2><p>Web的应用层协议是<strong>超文本运输协议</strong>（HTTP),它是Web的核心。HTTP由两个程序实现：一个客户和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p><p><strong>Web页面</strong>（也叫文档）是由<strong>对象</strong>组成的。一个<strong>对象</strong>（object）只是一个文件，诸如一个HTML文件、一个JPEG图形、一个Java小程序或一个视频片段这样的文件，且它们可通过一个URL地址寻址。每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。</p><blockquote><p>例如，URL地址http://www.someSchool.edu/someDepartment/picture.gif中www.someSchool.edu就是主机名，/someDepartment/picture.gif就是路径名。</p></blockquote><p>Web<strong>浏览器</strong>实现了HTTP的客户端，所以被称为浏览器或客户；<br />Web<strong>服务器</strong>实现了HTTP的服务器端，它用于存储Web对象，每个对象由URL寻址。</p><p>HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。当用户请求一个Web页面时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。<br /><img src="/img/cn2.4.png" alt="HTTP的请求-响应行为" /></p><p>HTTP使用<strong>TCP</strong>作为它的支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制。</p><p>HTTP是一个<strong>无状态协议</strong>（stateless protrol），即不保存关于客户的任何信息。Web是一个<strong>客户-服务器体系结构</strong>。</p><h2 id="22-非持续连接和持续连接"><a class="markdownIt-Anchor" href="#22-非持续连接和持续连接"></a> 2.2 非持续连接和持续连接</h2><p>在许多因特网应用程序中，客户发出一系列请求并且服务器对每个请求进行响应。<strong>非持续连接</strong>是指每个请求/响应经一个单独的TCP发送，<strong>持续连接</strong>指所有的请求/响应经相同的TCP发送。</p><p>以<strong>HTTP</strong>举例研究持续连接和非持续连接的<strong>优缺点</strong>。</p><h3 id="221-采用非持续连接的http"><a class="markdownIt-Anchor" href="#221-采用非持续连接的http"></a> 2.2.1 采用非持续连接的HTTP</h3><p>在<strong>非持续连接</strong>的情况下，从服务器向客户传送一个Web页面的<strong>步骤</strong>，假设该页面含有一个HTML基本页面和10个JPEG图形，并且这11个对象位于同一台服务器上。该HTML文件的URL为：</p><blockquote><p><a href="http://www.someSchool.edu/someDepartment/home.index">http://www.someSchool.edu/someDepartment/home.index</a></p></blockquote><ol><li>HTTP<strong>客户进程</strong>在端口号80发起一个到服务器www.someSchool.edu的TCP连接，该端口号是HTTP的默认端口。</li><li>HTTP<strong>客户</strong>经它的<strong>套接字</strong>向该服务器发送一个HTTP请求报文。请求报文中包含了<strong>路径名</strong>/someDepartment/home.index</li><li>HTTP<strong>服务器进程</strong>经它的<strong>套接字</strong>向该服务器发送一个HTTP请求报文。从其<strong>存储器</strong>（RAM或磁盘）<a href="http://xn--www-u68dv7oy4rf8uyi1byx2a.someSchool.edu/someDepartment/home.index%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AAHTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E4%B8%AD">中检索出对象www.someSchool.edu/someDepartment/home.index，在一个HTTP响应报文中</a><strong>封装</strong>对象，并通过其套接字向客户发送<strong>响应</strong>报文。</li><li>HTTP<strong>服务器进程</strong>通知TCP断开该TCP连接。</li><li>HTTP<strong>客户</strong>接收响应报文，TCP连接关闭。该报文指出封装的对象是一个HTML文件，客户从响应报文中提取出该文件，检查该HTML文件，得到对10个JPEG图形的<strong>引用</strong>。</li><li>对每个引用的JPEG图形对象<strong>重复</strong>前4个步骤。</li></ol><p>其中每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。每个TCP连接只传输一个请求报文和一个响应报文，因此在本例中要产生11个TCP连接。</p><p>其中这10个JPEG图形对象是使用10个串行的TCP连接，还是某些JPEG对象使用了一些并行的TCP连接，这可以由用户通过配置浏览器进行控制。</p><p><strong>往返时间</strong>（RTT）是指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p><p>当浏览器和Web服务器之间发起一个TCP连接时，会涉及一次”<strong>三次握手</strong>“过程：</p><ol><li>客户向服务器发送一个小TCP报文段</li><li>服务器用一个小TCP报文段做出确认和响应</li><li>客户向服务器返回确认</li></ol><p>三次握手中前两个部分占用了一个RTT。完成前两个部分后，客户结合三次握手的第三部分向该TCP连接发送一个HTTP请求报文，一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。该HTTP请求/响应占用了一个RTT。因此，总的响应时间就是<strong>两个RTT加上服务器传输HTML文件的时间</strong>。<br /><img src="/img/cn2.5.png" alt="三次握手过程" /></p><h3 id="222-采用持续连接的http"><a class="markdownIt-Anchor" href="#222-采用持续连接的http"></a> 2.2.2 采用持续连接的HTTP</h3><p>非持续连接有两个缺点：</p><ol><li><p>必须为每一个请求的对象建立和维护一个全新的TCP连接。对于每个连接，客户和服务器都要分配TCP的缓冲区和保持TCP变量。</p></li><li><p>每一个对象要经受两倍RTT的交付时延。</p><p>在采用持续连接时，服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。一般来说，如果一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，HTTP服务器就关闭该连接。</p></li></ol><h2 id="23-http报文格式"><a class="markdownIt-Anchor" href="#23-http报文格式"></a> 2.3 HTTP报文格式</h2><p>HTTP规范包含了对HTTP报文格式的定义。HTTP报文有两种：请求报文和响应报文。</p><h3 id="231-http请求报文"><a class="markdownIt-Anchor" href="#231-http请求报文"></a> 2.3.1 HTTP请求报文</h3><blockquote><p>下面提供一个<strong>典型</strong>的HTTP请求报文：<br />GET /somedir/page.html HTTP/1.1<br />Host: <a href="http://www.someschool.edu">www.someschool.edu</a><br />Connection: close<br />User-agent: Mozilla/5.0<br />Accept-language: fr</p></blockquote><p>HTTP请求报文的第一行叫做<strong>请求行</strong>（request line），其后继的行叫做<strong>首部行</strong>（header line）。</p><p>1 <strong>请求行</strong><br />有3个字段：<strong>方法字段</strong>、<strong>URL字段</strong>和<strong>HTTP版本字段</strong>。方法字段可以取几种不同的值，包括GET、POST、HEAD、PUT和DELETE，绝大部分采用GET方法。</p><p>2 <strong>首部行</strong><br /><strong>Host: <a href="http://www.someschool.edu">www.someschool.edu</a></strong>，指明了对象所在的主机。<br /><strong>Connection: close</strong>，浏览器告诉服务器不使用持续连接。<br /><strong>User-agent</strong>，用来指明用户代理，即向服务器发送请求的浏览器的类型。<br /><strong>Accept-language</strong>，表示用户想得到该对象的法语版本（如果服务器中有），否则发送默认版本。</p><p>在首部行后有一个“<strong>实体体</strong>”（entire body）。使用GET方法时实体体为空，在使用<strong>POST方法</strong>时使用。例如当用户在搜索引擎搜索关键词时，实体体包含的就是用户在表单字段的输入值。</p><p><img src="/img/cn2.6.png" alt="一个HTTP请求报文的通用格式" /></p><p>用表单生成的请求报文不是必须使用<strong>POST方法</strong>，HTML表单经常使用GET方法，并在所请求的URL中包括输入的数据。<a href="http://xn--www-uc0ep96b.somesite.com/animalsearch?monkeys&amp;bananas%E3%80%82">例如www.somesite.com/animalsearch?monkeys&amp;bananas。</a></p><p><strong>HEAD方法</strong>类似于GET方法，当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但不返回对象。应用程序开发者经常使用HEAD方法进行调试跟踪。</p><p><strong>PUT方法</strong>常与Web发行工具联合使用，它允许用户上传对象到指定的Web服务器上指定的路径（目录）。同时，它也被那些需要向Web服务器上传对象的应用程序使用。</p><p><strong>DELETE方法</strong>允许用户或者应用程序删除Web服务器上的对象。</p><h3 id="232-http响应报文"><a class="markdownIt-Anchor" href="#232-http响应报文"></a> 2.3.2 HTTP响应报文</h3><blockquote><p>下面提供一条典型的HTTP响应报文，它是对上面请求报文的响应<br />HTTP:/1.1 200 OK<br />Connection: close<br />Data: Tue, 09 Aug 2011 15:44:04 GMT<br />Server: Apache/2.2.3 (CentOS)<br />Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT<br />Content-Length: 6821<br />Content-Type: text/html<br />(空行）<br />(data data data data…)</p></blockquote><p>1 <strong>状态行</strong>（第1行）<br />状态行有3个字段：<strong>协议版本字段</strong>、<strong>状态码</strong>和<strong>相应状态信息</strong>。这里指示服务器正在使用HTTP/1.1，并且一切正常。</p><p>2 <strong>首部行</strong>（2~7行）<br /><strong>Connection: close</strong> 告诉客户发送完报文后将关闭该TCP连接；<br /><strong>Date</strong> 指示服务器产生并发送该响应报文的日期和时间；<br /><strong>Server</strong> 指示该报文是由一台Apache Web服务器产生的，类似于请求报文中的User-agent；<br /><strong>Last-Modified</strong> 指示了对象创建或者最后修改的日期和时间，它对对象缓存（既可能在本地客户也可能在网络缓存服务器上）非常重要；<br /><strong>Content-Length</strong> 指示了被发送对象中的字节数；<br /><strong>Content-Type</strong> 指示了实体体中的对象是HTML文本。</p><p>3 <strong>实体体</strong>：报文的主要部分（data data data…）。</p><p><img src="/img/cn2.7.png" alt="一个HTTP响应报文的通用格式" /></p><h2 id="24-用户与服务器的交互cookie"><a class="markdownIt-Anchor" href="#24-用户与服务器的交互cookie"></a> 2.4 用户与服务器的交互：cookie</h2><p>cookie在[RFC 6265]中定义，它允许站点对用户进行跟踪。</p><p>cookie技术有4个组件：</p><ol><li>在HTTP响应报文中的一个cookie首部行；</li><li>在HTTP请求报文中的一个cookie首部行；</li><li>在用户端系统中保留有一个cookie文件，由用户的浏览器进行管理；</li><li>位于Web站点的一个后端数据库。</li></ol><p><img src="/img/cn2.8.png" alt="cookie跟踪用户状态" /></p><p>cookie可以用于<strong>标识</strong>一个用户。用户首次访问一个站点时，可能需要提供一个用户标识。在后继会话中，浏览器向服务器传递一个cookie首部，从而向该服务器标识了用户。因此cookie可以在无状态的HTTP之上建立一个用户<strong>会话层</strong>。</p><h2 id="25-web缓存"><a class="markdownIt-Anchor" href="#25-web缓存"></a> 2.5 Web缓存</h2><p><strong>Web缓存器</strong>（Web cache）也叫<strong>代理服务器</strong>（proxy server），它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘<strong>存储空间</strong>，并在存储空间中保存最近请求过的对象的<strong>副本</strong>。</p><p>假设浏览器正在请求一个对象，将会发生如下情况：</p><ol><li>浏览器<strong>建立</strong>一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。</li><li>Web缓存器进行<strong>检查</strong>，看看本地是否存储了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象。</li><li>如果Web缓存器中没有该对象，它就打开一个与该对象的<strong>初始服务器</strong>的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应。</li><li>当Web缓存器接收到该对象时，它在本地存储空间存储一份<strong>副本</strong>，并向客户的浏览器用HTTP<strong>响应报文</strong>发送该副本（通过已有的TCP连接）。</li></ol><p>所以Web缓存器是<strong>服务器</strong>同时又是<strong>客户</strong>。它通常由<strong>ISP</strong>购买并安装。</p><p>部署Web缓存器的<strong>原因</strong>：</p><ul><li>它可以大大减少对客户请求的响应时间。</li><li>它能够大大减少一个机构的接入链路到因特网的通信量。</li><li>它从整体上大大减低因特网上的Web流量，从而改善了所有应用的性能。</li></ul><p>通过使用<strong>内容分发网络</strong>（CDN），Web缓存器正在因特网中发挥着越来越重要的作用。CDN公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。</p><h2 id="26-条件get方法"><a class="markdownIt-Anchor" href="#26-条件get方法"></a> 2.6 条件GET方法</h2><p>为了解决存放在缓存器中的对象副本可能已经<strong>陈旧</strong>的问题，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。它就是<strong>条件GET方法</strong>。</p><p>如果</p><ul><li>请求报文使用GET方法</li><li>请求报文中包含一个&quot;if-Modified-Since:&quot;首部行</li></ul><p>那么，这个HTTP请求报文就是一个条件GET请求报文。</p><h1 id="三-文件传输协议ftp"><a class="markdownIt-Anchor" href="#三-文件传输协议ftp"></a> 三、文件传输协议：FTP</h1><h2 id="31-ftp传输的过程"><a class="markdownIt-Anchor" href="#31-ftp传输的过程"></a> 3.1 FTP传输的过程</h2><p>在一个典型的FTP会话中，用户坐在一台主机前面，向一台远程主机传输文件。为使用户能访问它的远程账户，用户必须提供一个<strong>用户标识和口令</strong>。用户通过一个<strong>FTP用户代理</strong>与<strong>FTP</strong>交互。</p><p>具体步骤如下：</p><ol><li>用户首先提供远程主机的<strong>主机名</strong>，使本地主机的FTP客户进程建立一个到远程主机FTP服务器进程的<strong>TCP连接</strong>。</li><li>用户接着提供<strong>用户标识和口令</strong>，作为FTP命令的一部分在该TCP连接上传送。</li><li>一旦该服务器向该用户<strong>授权</strong>，用户可以将存放在本地文件系统中的一个或多个文件复制到远程文件系统（反之亦然）。</li></ol><h2 id="32-http和ftp的对比"><a class="markdownIt-Anchor" href="#32-http和ftp的对比"></a> 3.2 HTTP和FTP的对比</h2><h3 id="321-共同点"><a class="markdownIt-Anchor" href="#321-共同点"></a> 3.2.1 共同点</h3><ul><li>都是文件传输协议</li><li>都运行在TCP上</li></ul><h3 id="322-不同点"><a class="markdownIt-Anchor" href="#322-不同点"></a> 3.2.2 不同点</h3><ul><li>FTP使用了两个并行的TCP连接来传输文件，一个是<strong>控制连接</strong>（control connection），一个是<strong>数据连接</strong>（data connection）。<strong>控制连接</strong>用于在主机之间传输控制信息，如用户标识、口令、文件命令等。<strong>数据连接</strong>用于实际发送一个文件。我们称FTP是<strong>带外连接</strong>（独立的控制连接）的。HTTP是在传输文件的同一个TCP连接中发送请求和响应首部行的。因此，HTTP是<strong>带内连接</strong>的。</li><li>FTP服务器必须在整个会话期间保留用户的<strong>状态</strong>（state）。服务器必须把特定的用户账户与控制连接联系起来，大大限制了FTP同时维持的会话总数。HTTP是<strong>无状态</strong>的，它不必对任何用户状态进行跟踪。</li></ul><p>对FTP而言，<strong>控制连接</strong>贯穿了整个用户会话期间，但是对会话中的每一次文件传输都需要建立一个新的<strong>数据连接</strong>（即数据连接是非持续的）。</p><h2 id="33-ftp命令和回答"><a class="markdownIt-Anchor" href="#33-ftp命令和回答"></a> 3.3 FTP命令和回答</h2><p>详见 RFC959</p><h1 id="四-因特网中的电子邮件"><a class="markdownIt-Anchor" href="#四-因特网中的电子邮件"></a> 四、因特网中的电子邮件</h1><h2 id="41-因特网电子邮件系统和它的关键组件"><a class="markdownIt-Anchor" href="#41-因特网电子邮件系统和它的关键组件"></a> 4.1 因特网电子邮件系统和它的关键组件</h2><p>因特网电子邮件系统有3个主要组成部分：<strong>用户代理</strong>（user agent）、<strong>邮件服务器</strong>（mail server）和<strong>简单邮件传输协议</strong>（SMTP）。</p><p>1 <strong>用户代理</strong>允许用户阅读、回复、转发、保存和撰写报文。当发送方完成邮件撰写时，<strong>邮件代理</strong>向其<strong>邮件服务器</strong>发送邮件，此时邮件放在<strong>邮件服务器</strong>的外出报文队列中。</p><p>2 <strong>邮件服务器</strong>形成了电子邮件体系结构的核心。每个接收方在其中的某个<strong>邮件服务器</strong>上有一个<strong>邮箱</strong>（mailbox），<strong>邮箱</strong>管理和维护着发送给用户的报文。当用户要在他的<strong>邮箱</strong>中读取该报文时，包含他邮箱的<strong>邮件服务器</strong>要鉴别用户。</p><p>如果发送方的服务器不能将邮件交付给接收方的服务器，发送方的邮件服务器在一个<strong>报文队列</strong>（message queue）中保持该报文并在以后尝试再次发送。通常每30分钟进行一次尝试，如果几天后仍不能成功，服务器就删除该报文并以电子邮件的形式通知发送方。</p><p>3 <strong>SMTP</strong>是因特网电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。SMTF也有两个部分：运行在发送方邮件服务器的<strong>客户端</strong>和接收方邮件服务器的<strong>服务器端</strong>。</p><h2 id="42-smtp"><a class="markdownIt-Anchor" href="#42-smtp"></a> 4.2 SMTP</h2><p>SMTP是因特网电子邮件应用的核心，用于从发送方的邮件服务器发送报文到接收方的邮件服务器。</p><p>假设Alice想给Bob发送一封简单的ASCII报文：</p><ol><li>Alice调用她的<strong>邮件代理</strong>程序并提供Bob的邮件地址，撰写报文，然后指示<strong>用户代理</strong>发送该报文。</li><li>Alice的<strong>用户代理</strong>把报文发给他的<strong>邮件服务器</strong>，在那里该报文被放在<strong>报文队列</strong>中。</li><li>运行在Alice的<strong>邮件服务器</strong>上的<strong>SMTP客户端</strong>发现了<strong>报文队列</strong>中的这个报文，它就创建一个到运行在Bob的邮件服务器上的<strong>SMTP服务器</strong>的<strong>TCP连接</strong>。</li><li>在经过一些初始SMTF握手后，SMTP客户通过该<strong>TCP连接</strong>发送Alice的报文。</li><li>在Bob的<strong>邮件服务器</strong>上，SMTP的服务器端接收该报文。Bob的<strong>邮件服务器</strong>将该报文放入Bob的<strong>邮箱</strong>中。</li><li>在Bob方便的时候，他调用<strong>用户代理</strong>阅读该报文。</li></ol><p>SMTP一般不使用中间服务器发送邮件。而且它用的是持续连接，通过同一个TCP连接发送所有报文。</p><h2 id="43-http和smtp的对比"><a class="markdownIt-Anchor" href="#43-http和smtp的对比"></a> 4.3 HTTP和SMTP的对比</h2><h3 id="431-共同点"><a class="markdownIt-Anchor" href="#431-共同点"></a> 4.3.1 共同点</h3><ul><li>都用于从一台主机向另一台主机传送文件。</li><li>进行文件发送时，二者都使用<strong>持续连接</strong>。</li></ul><h3 id="432-不同点"><a class="markdownIt-Anchor" href="#432-不同点"></a> 4.3.2 不同点</h3><p><strong>一、</strong></p><ul><li>HTTP主要是一个<strong>拉协议</strong>（pull protocol），即在方便的时候，用户使用HTTP从服务器拉取这些信息。TCP由想接收文件的机器发起的。</li><li>SMTP基本是一个<strong>推协议</strong>（push protocol），即发送邮件服务器把文件推向接收邮件服务器。TCP由要发送该文件的机器发起。</li></ul><p><strong>二、</strong></p><ul><li>SMTP要求每个报文使用<strong>7比特ASCII码</strong>格式。如果文件包含非7比特ASCII字符，则必须要按照7比特ASCII码进行编码。</li><li>HTTP没有格式限制。</li></ul><p><strong>三、</strong></p><ul><li>在处理一个既包含文本又包含图形（或其他）的文档时，HTTP把每个对象<strong>封装</strong>到响应报文中。</li><li>SMTP把所有报文对象放在一个报文之中。</li></ul><h2 id="44-邮件报文格式和mime"><a class="markdownIt-Anchor" href="#44-邮件报文格式和mime"></a> 4.4 邮件报文格式和MIME</h2><p>当发送电子邮件时，一个包含<strong>环境信息</strong>的首部位于报文体前面。这些<strong>环境信息</strong>包括在一系列<strong>首部行</strong>中，这些行由RFC 5322定义。注意这里的首部行不同于SMTP命令，SMTP命令是握手协议的一部分。</p><blockquote><p>一个典型的报文首部如下：<br />From: <a href="mailto:alice@crepes.fr">alice@crepes.fr</a><br />To: <a href="mailto:bob@hamburger.edu">bob@hamburger.edu</a><br />Subject: Searching for the meaning of life</p></blockquote><h2 id="45-邮件访问协议"><a class="markdownIt-Anchor" href="#45-邮件访问协议"></a> 4.5 邮件访问协议</h2><p>目前用户是通过在用户端系统上运行的客户程序来阅读电子邮件。用户通常在本地PC上运行一个<strong>用户代理程序</strong>，它访问存储在总是保持开机的<strong>共享邮件服务器</strong>（由用户的ISP维护）上的邮箱。</p><p>为了接收方能够通过<strong>用户代理</strong>获得<strong>某ISP</strong>上的<strong>邮件服务器</strong>上的邮件，目前有一些流行的邮件访问协议，包括<strong>第三版的邮局协议</strong>（POP3）、<strong>因特网邮件访问协议</strong>（IMAP）和<strong>HTTP</strong>。</p><p><img src="/img/cn2.9.png" alt="电子邮件协议及其通信实体" /></p><h3 id="451-pop3"><a class="markdownIt-Anchor" href="#451-pop3"></a> 4.5.1 POP3</h3><p>POP3是一个<strong>极为简单、功能相当有限</strong>的邮件访问协议，由RFC1939定义。随着建立TCP连接，POP3按照三个阶段进行工作：</p><ol><li><strong>特许</strong>（authorization）<br />用户代理发送（以明文形式）用户名和口令以鉴别用户。</li><li><strong>事务处理</strong><br />用户代理取回报文，还能对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。</li><li><strong>更新</strong><br />出现在客户发出quit命令之后，结束该POP3会话。同时，该邮件服务器删除哪些被标记为删除的报文。</li></ol><h3 id="452-imap"><a class="markdownIt-Anchor" href="#452-imap"></a> 4.5.2 IMAP</h3><p>略</p><h3 id="453基于web的电子邮件"><a class="markdownIt-Anchor" href="#453基于web的电子邮件"></a> 4.5.3基于Web的电子邮件</h3><p>略</p><h1 id="五-dns因特网的目录服务"><a class="markdownIt-Anchor" href="#五-dns因特网的目录服务"></a> 五、DNS：因特网的目录服务</h1><p>因特网上的主机可以使用多种方式进行标识，其中的一种标识方法是<strong>主机名</strong>（hostname）。然而，主机名几乎没有提供关于主机在因特网中位置的信息，而且以不定长的字母数字组成，路由器难以处理。由于这些原因，主机也使用<strong>IP地址</strong>（IP address）进行标识。</p><blockquote><p>一个IP地址由四个字节组成，并有着严格的层次结构，如121.7.106.83，其中的每个字节都被句点分隔开，表示了0~255的十进制数字。当从左至右扫描它时，会得到越来越具体的关于主机位于因特网何处的信息。</p></blockquote><h2 id="51-dns提供的服务"><a class="markdownIt-Anchor" href="#51-dns提供的服务"></a> 5.1 DNS提供的服务</h2><p><strong>域名系统</strong>（DNS）的主要任务是进行主机名到IP地址转换的<strong>目录服务</strong>。</p><blockquote><p>DNS是：<br />①一个由分层的DNS服务器（DNS server）实现的分布式数据库<br />②一个使得主机能够查询分布式数据库的应用层协议。</p></blockquote><p>DNS通常是由其他应用层协议所使用的（不直接面向用户），包括HTTP、SMTP和FTP，将用户提供的主机名解析为IP地址。例如，当用户要将一个HTTP请求报文发送到Web服务器时，必须要获得该网页的IP地址：</p><ul><li>同一台用户主机上运行着DNS应用的客户端。</li><li>浏览器从URL抽取出主机名，并将主机名传给DNS应用的客户端。</li><li>DNS客户向DNS服务器发送一个包含主机名的请求。</li><li>DNS客户最终会收到一份回答报文，其中含有对应于该主机名的IP地址。</li><li>一旦浏览器接收到该IP地址，它能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接。</li></ul><p>DNS将会为因特网应用带来大量<strong>时延</strong>。目前想获得的IP地址通常就<strong>缓存</strong>在“附近的”DNS服务器中，这有助于减少DNS的网络流量和平均时延。</p><p>除了上述的主机名到IP地址的转换，DNS还提供了一些重要的服务：</p><ul><li>主机别名</li><li>邮件服务器别名</li><li>负债分配</li><li>……</li></ul><p>DNS由RFC定义，它是一个复杂的系统，这里不再详述。</p><h2 id="52-dns工作机理概述"><a class="markdownIt-Anchor" href="#52-dns工作机理概述"></a> 5.2 DNS工作机理概述</h2><p>从用户之际上调用应用程序的角度看，DNS是一个提供简单、直接的转换服务的黑盒子，事实上它的构造非常复杂。<strong>DNS由分布于全球的大量DNS服务器以及定义了DNS服务器与查询主机通信方式的应用层协议组成</strong>。</p><p>采用单一DNS服务器（集中式设计）会有如下问题：</p><ul><li><strong>单点故障</strong>（a single point of failure）</li><li><strong>通信容量</strong>（traffic volume）</li><li><strong>远距离的集中式数据库</strong>（distant centralized database）</li><li><strong>维护</strong>（maintenance）</li></ul><p>因此，DNS采用了分布式的设计方案。</p><h3 id="521-分布式-层次数据库"><a class="markdownIt-Anchor" href="#521-分布式-层次数据库"></a> 5.2.1 分布式、层次数据库</h3><p>DNS使用了大量DNS服务器，它们以<strong>层次</strong>方式组织，并且分布在全世界范围内。<strong>没有一台DNS服务器拥有因特网上所有主机的映射，该映射分布在所有的DNS服务器上</strong>。</p><p>大致说来，有三种类型的DNS服务器：</p><ul><li><strong>根DNS服务器</strong><br />在因特网上有<strong>13</strong>个根DNS服务器（标号从A到M），大部分位于北美洲。为了提高安全性和可靠性，每台“服务器”实际上是一个<strong>服务器网络</strong>。</li><li><strong>顶级域（TLD）DNS服务器</strong><br />这些服务器负责<strong>顶级域名</strong>，如com、org、net、edu等以及所有<strong>国家的顶级域名</strong>。</li><li><strong>权威DNS服务器</strong><br />在因特网上具有<strong>公共可访问主机</strong>（如Web服务器和邮件服务器）的组织（机构）必须提供公共可访问的<strong>DNS记录</strong>，这些记录将这些主机的名字映射为IP地址。这个组织（机构）能够选择实现<strong>自己的</strong>权威DNS服务器收藏这些DNS记录，也可以选择将这些记录存储在<strong>第三方的</strong>权威DNS服务器中。</li></ul><p><img src="/img/cn2.10.png" alt="DNS服务器的部分层次结构" /></p><p>除了在层次结构中的三种DNS服务器，还有一类，叫做<strong>本地DNS服务器</strong>，它起到一个<strong>代理</strong>的作用。对于某居民区ISP，本地DNS服务器通常与主机相隔很近。</p><p><img src="/img/cn2.11.png" alt="各种DNS服务器的交互" /></p><p>主机、服务器之间的查询有两种形式：</p><ul><li><strong>递归查询</strong>。在该模式下DNS 服务器接收到客户机请求，必须使用一个<strong>准确的查询结果</strong>回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。客户机和服务器之间的查询是递归查询。<br /><strong>递归查询告诉客户机IP地址</strong></li><li><strong>迭代查询</strong>。DNS 服务器会向客户机提供其他能够解析查询请求的<strong>DNS 服务器地址</strong>，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果为止。<br /><strong>服务器之间的查询是迭代查询</strong></li></ul><h3 id="522-dns缓存"><a class="markdownIt-Anchor" href="#522-dns缓存"></a> 5.2.2 DNS缓存</h3><p>为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了<strong>缓存</strong>技术。在一个请求链中，当某DNS服务器接收一个DNS回答时，它能将该回答中的信息缓存在本地存储器中。由于主机和和主机名与IP地址的映射不是永久的，DNS服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。</p><h2 id="53-dns记录和报文"><a class="markdownIt-Anchor" href="#53-dns记录和报文"></a> 5.3 DNS记录和报文</h2><p>共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录</strong>（RR），RR提供了主机名到IP地址的映射。每个DNS回答报文包含了<strong>一条或多条</strong>RR。</p><p>RR是一个包含了下列字段的4元组：<br />（Name，Value，Type，TTL）</p><p>关于RR的详细内容以后再补。</p><h3 id="531-dns报文"><a class="markdownIt-Anchor" href="#531-dns报文"></a> 5.3.1 DNS报文</h3><p>DNS报文中各字段的语义如下：</p><p><img src="/img/cn2.12.png" alt="DNS报文格式" /></p><ul><li>前12个字节是<strong>首部区域</strong>。<br /><strong>1</strong> <strong>标识符</strong>是一个<em>16比特的数</em>。用于标识该查询，它会被复制到回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。<br /><strong>2</strong> <strong>标志字段</strong>中含有<em>若干标志</em>。<br />1比特的“<em>查询/回答</em>”标志位指出报文是查询报文（0）还是回答报文（1）；<br />当某DNS服务器是所请求名字的权威DNS服务器时，1比特的“<em>权威的</em>”标志位被置入；<br />如果客户在该DNS服务器没有某记录时希望它执行递归查询，将设置1比特的“<em>希望递归</em>”标志位；<br />如果该DNS服务器支持递归查询，在它的回答报文中会显示1比特的“递归可用”标志位。<br /><strong>3</strong> 除此之外，首部区域还有4个<strong>有关数量的字段</strong>，它们分别指出了4类数据区域出现的数量。<ul><li><strong>问题区域</strong>包含着正在进行的查询信息。该区域包括：<br /><strong>1 名字字段</strong>，指出正在被查询的主机名字。<br /><strong>2 类型字段</strong>，指出有关该名字的正被询问的问题类型。</li><li><strong>回答区域</strong>包含了对最初请求的名字的<strong>资源记录</strong>。</li><li><strong>权威区域</strong>包含了其他权威服务器的记录。</li><li><strong>附加区域</strong>包含了其他有帮助的记录。</li></ul></li></ul><h3 id="532-在dns数据库中插入记录"><a class="markdownIt-Anchor" href="#532-在dns数据库中插入记录"></a> 5.3.2 在DNS数据库中插入记录</h3><p>如果你想注册域名，需要向注册登记机构（register）提供基本和辅助权威DNS服务器的名字和IP地址。对这两个权威DNS服务器，该注册登记机构确保将一个类型NS和一个类型A的记录输入TLD com服务器。</p><blockquote><p>例如，输入如下信息：<br />(<a href="http://networkutopia.com">networkutopia.com</a>, <a href="http://dnsl.networkutopia.com">dnsl.networkutopia.com</a>, NS)<br />(<a href="http://dnsl.networkutopia.com">dnsl.networkutopia.com</a>,  212.212.212.1, A)</p></blockquote><p>除此之外，你还需要确保用于Web服务器的类型A资源记录和用于邮件服务器的类型MX资源记录被输入到你的权威DNS服务器中。</p><h1 id="六-p2p应用"><a class="markdownIt-Anchor" href="#六-p2p应用"></a> 六、P2P应用</h1><p>P2P体系结构不同于客户-服务器体系结构，成对间歇地主机（称为对等方）彼此直接通信。有两种特别适合于P2P设计的应用。</p><ul><li>文件分发，其中应用程序从单个源向大量的对等方分发一个文件。</li><li>分布在大型对等方社区中的数据库。</li></ul><h2 id="61-p2p文件分发"><a class="markdownIt-Anchor" href="#61-p2p文件分发"></a> 6.1 P2P文件分发</h2><h3 id="611-p2p体系结构的扩展"><a class="markdownIt-Anchor" href="#611-p2p体系结构的扩展"></a> 6.1.1 P2P体系结构的扩展</h3><blockquote><p>假设，<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold-italic">u</mi><mi mathvariant="bold-italic">s</mi></msub></mrow><annotation encoding="application/x-tex">\bm{u_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.59444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.161108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span>表示服务器接入链路的上载速率；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold-italic">u</mi><mi mathvariant="bold-italic">i</mi></msub></mrow><annotation encoding="application/x-tex">\bm{u_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.59444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33528199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span>表示第i个对等方接入链路的上载速率；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold-italic">d</mi><mi mathvariant="bold-italic">i</mi></msub></mrow><annotation encoding="application/x-tex">\bm{d_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33528199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span>表示第i个对等方接入链路的上载速率；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">F</mi></mrow><annotation encoding="application/x-tex">\bm{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.15972em;">F</span></span></span></span></span></span>表示被分发的文件长度（以比特计）；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">N</mi></mrow><annotation encoding="application/x-tex">\bm{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.11424em;">N</span></span></span></span></span></span>表示要获得的该文件副本的对等方的数量；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">D</mi></mrow><annotation encoding="application/x-tex">\bm{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03194em;">D</span></span></span></span></span></span>是所有N个对等方得到该文件的副本所需要的时间。</p></blockquote><p>对于客户-服务器体系结构，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>≥</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mfrac><mrow><mi>N</mi><mi>F</mi></mrow><msub><mi>u</mi><mi>s</mi></msub></mfrac><mo separator="true">,</mo><mfrac><mi>F</mi><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mfrac><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D \ge max \{  \frac {NF}{u_s},  \frac {F}{d_{min}}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">}</span></span></span></span></span></p><p>对于P2P体系结构，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>≥</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mfrac><mi>F</mi><msub><mi>u</mi><mi>s</mi></msub></mfrac><mo separator="true">,</mo><mfrac><mi>F</mi><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>N</mi><mi>F</mi></mrow><mrow><msub><mi>u</mi><mi>s</mi></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>u</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D \ge max \{  \frac {F}{u_s}, \frac {F}{d_{min}}, \frac {NF}{u_s+\sum_{i=1}^N u_i}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5312710000000003em;vertical-align:-1.170941em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.128769em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.170941em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">}</span></span></span></span></span></p><p>二者分发时间对比如下图，</p><p><img src="/img/cn2.13.png" alt="P2P和客户-服务器体系结构的分发时间" /></p><h3 id="612-bittorrent"><a class="markdownIt-Anchor" href="#612-bittorrent"></a> 6.1.2 BitTorrent</h3><p>BitTorrent是一种用于文件分发的流行<strong>P2P协议</strong>。在BitTorrent中，参与一个特定文件分发的所有对等方的集合被称为一个<strong>洪流</strong>（torrent）。在一个洪流中的对等方彼此下载等长度的<strong>文件块</strong>（chunk），一般块长度为256KB。当一个对等方首次加入一个洪流时，它没有块。随着时间流逝，它累积了越来越多的块，当它<strong>下载</strong>块时，也为其他对等方<strong>上载</strong>了多个块。<strong>任何对等方可能在任何时候仅具有块的子集就离开洪流，并可以重新加入洪流。</strong></p><p>每个洪流有一个基础设施结点，称为<strong>追踪器</strong>（tracker）。当一个对等方加入该洪流中时，它向追踪器注册自己，并周期性地通知追踪器它仍然在该洪流中。以这种方式，追踪器跟踪正参与在洪流中的对等方。</p><p>当一个新的对等方A加入该洪流时，追踪器随机地从参与对等方的集合中选择对等方的一个子集，并将这些对等方的IP地址发给A。A会尝试与它们<strong>创建并行的TCP连接</strong>，所有成功与A创建连接的对等方称为**“邻近对等方**”。随着时间流逝，它们中有些可能离开，而其余的对等方可能加入，因此，<strong>一个对等方的邻近对等方将随时间波动。</strong><br /><img src="/img/cn2.14.png" alt="BitTorrent分发文件" /></p><p>在任何给定的时间，每个对等方将具有来自该文件的块子集，并且不同对等方具有不同的子集。A周期性地询问  每个邻近对等方具有的块列表，之后A可以对它还没有的块发出请求（TCP）。</p><p>A将做出两个重要决定：-请求哪些块？-为哪些邻近对等方发送块？</p><ul><li>在决定请求哪些块的过程中，A会使用一种称为最<strong>稀缺优先</strong>的技术。思路是，针对它没有的块在它的邻居中决定最稀缺的块，并首先请求最稀缺的块。这样，最稀缺的块得到更为迅速地分发，其目标是均衡每个块在洪流中地副本数量。</li><li>为了决定响应哪个请求，A根据当前能够以最高速率向它提供数据的邻居给出优先权。</li></ul><h2 id="62-分布式散列表"><a class="markdownIt-Anchor" href="#62-分布式散列表"></a> 6.2 分布式散列表</h2><p>在P2P系统中，每个P2P对等方将保持（键，值）对仅占总体的一个小子集，并且允许任何一个对等方用一个特别的键来查询该分布式数据库。分布式数据库则将定位拥有该相应（键，值）对的对等方，然后向查询的对等方返回该（键，值）对。任何对等方也将允许在数据库中插入新键-值对。这样一种分布式数据库被称为<strong>分布式散列表</strong>（DHT）。</p><p>详细内容以后需要再补</p><h1 id="七-tcp套接字编程"><a class="markdownIt-Anchor" href="#七-tcp套接字编程"></a> 七、TCP套接字编程</h1><h2 id="71-udp套接字编程"><a class="markdownIt-Anchor" href="#71-udp套接字编程"></a> 7.1 UDP套接字编程</h2><p><img src="/img/cn2.15.png" alt="UDP 客户 / 服务器程序使用的套接字函数" /></p><p>以下代码演示客户如何使用UDP套接字向服务器发送消息：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## UDPClient.py</span><br><span class="hljs-comment"># socket模块形成了在Python中所有网络通信的基础</span><br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># 提供服务器的IP地址或主机名</span><br>serverName = <span class="hljs-string">&#x27;hostname&#x27;</span><br><span class="hljs-comment"># 置入端口号</span><br>serverPort = <span class="hljs-number">12000</span><br><span class="hljs-comment"># 创建客户的套接字，第一个参数指示了地址簇，第二个参数指示它是一个UDP套接字</span><br>clientSocket = socket(AF_INET, SOCK_DGRAM)<br><span class="hljs-comment"># 提示用户输入报文</span><br>message = raw_input(<span class="hljs-string">&#x27;Input lowercase sentence:&#x27;</span>)<br><span class="hljs-comment"># 经一个UDP套接字发送报文</span><br>clientSocket.sendto(message,(serverName, serverPort))<br><span class="hljs-comment"># 将服务器传回的报文置入到变量中</span><br>modifiedMessage, serverAddress = clientSocket, recvfrom(<span class="hljs-number">2048</span>)<br><span class="hljs-comment"># 打印输出报文</span><br><span class="hljs-built_in">print</span> modifiedMessage<br><span class="hljs-comment"># 关闭套接字，关闭进程</span><br>clientSocket.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## UDPServer.py</span><br><span class="hljs-comment"># socket模块形成了在Python中所有网络通信的基础</span><br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># 置入端口号</span><br>serverPort = <span class="hljs-number">12000</span><br><span class="hljs-comment"># 创建服务器的套接字，第一个参数指示了地址簇，第二个参数指示它是一个UDP套接字</span><br>serverSocket = socket(AF_INET, SOCK_DGRAM)<br><span class="hljs-comment"># 将端口号与套接字绑定在一起</span><br>serverSocket.bind((<span class="hljs-string">&quot;, serverPort))</span><br><span class="hljs-string">print &quot;</span>The server <span class="hljs-keyword">is</span> ready to receive<span class="hljs-string">&quot;</span><br><span class="hljs-string"># 该循环允许UDPServer无限期地接收并处理来自客户的分组</span><br><span class="hljs-string">while true:</span><br><span class="hljs-string"># 将分组数据和客户地址置入</span><br><span class="hljs-string">message, clientAddress = serverSocket.recvfrom(2048)</span><br><span class="hljs-string"># 将数据小写转换为大写</span><br><span class="hljs-string">modifiedMessage = message.upper()</span><br><span class="hljs-string"># 将所得分组发送给服务器的套接字</span><br><span class="hljs-string">serverSocket.sendto(modifiedMessage, clientAddress)</span><br></code></pre></td></tr></table></figure><h2 id="72-tcp套接字编程"><a class="markdownIt-Anchor" href="#72-tcp套接字编程"></a> 7.2 TCP套接字编程</h2><p>TCP是一个面向连接的协议。在客户和服务器能够开始互相发送数据之前，它们先要握手和创建一个TCP连接（客户套接字和服务器套接字）。</p><p><img src="/img/cn2.16.png" alt="TCP 客户 / 服务器程序使用的套接字函数" /></p><p>以下代码演示客户如何使用TCP套接字向服务器发送消息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>serverName = <span class="hljs-string">&#x27;servername&#x27;</span><br>serverPort = <span class="hljs-number">12000</span><br><span class="hljs-comment"># 创建客户的套接字，第一个参数指示了地址簇，第二个参数指示它是一个TCP套接字</span><br>clientSocket = socket(AF_INET, SOCK_STREAM)<br><span class="hljs-comment"># 执行三次握手，并创建起一条TCP连接</span><br>clientSocket.connect((serverName, serverPort))<br><span class="hljs-comment"># 提示用户输入报文</span><br>sentence = raw_input(<span class="hljs-string">&#x27;Input lowercase sentence&#x27;</span>)<br><span class="hljs-comment"># 通过套接字进入TCP连接发送报文</span><br>clientSocket.send(sentence)<br><span class="hljs-comment"># 将服务器传回的报文置入到变量中</span><br>modifiedSentence = clientSocket.recv(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;From Server:&#x27;</span>, modifiedSentence<br>clientSocket.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## TCPServer.py</span><br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>serverPort = <span class="hljs-number">12000</span><br><span class="hljs-comment"># 创建服务器的套接字，第一个参数指示了地址簇，第二个参数指示它是一个UDP套接字</span><br>serverSocket = socket(AF_INET, SOCK_DGRAM)<br><span class="hljs-comment"># 将端口号与套接字绑定在一起</span><br>serverSocket.bind((<span class="hljs-string">&quot;, serverPort))</span><br><span class="hljs-string"># 等待并聆听某个客户敲门，参数定义了请求连接的最大数（至少为1）</span><br><span class="hljs-string">serverSocket.listen(1)</span><br><span class="hljs-string">print &quot;</span>The server <span class="hljs-keyword">is</span> ready to receive<span class="hljs-string">&quot;</span><br><span class="hljs-string"># 该循环允许TCPServer无限期地接收并处理来自客户的分组</span><br><span class="hljs-string">while true:</span><br><span class="hljs-string"># 创建一个新套接字，由这个特定用户专用</span><br><span class="hljs-string">connectionSocket, addr = serverSocket.accept()</span><br><span class="hljs-string"># 将分组数据和客户地址置入</span><br><span class="hljs-string">sentence = connectionSocket.recv(1024)</span><br><span class="hljs-string"># 将数据小写转换为大写</span><br><span class="hljs-string">capitalizedSentence = sentence.upper()</span><br><span class="hljs-string"># 将所得分组发送给服务器的套接字</span><br><span class="hljs-string">connectionSocket.send(capitalizedSentence)</span><br><span class="hljs-string">connectionSocket.close()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++基础语法</title>
    <link href="/2022/03/23/Cpp2/"/>
    <url>/2022/03/23/Cpp2/</url>
    
    <content type="html"><![CDATA[<h1 id="c基础语法"><a class="markdownIt-Anchor" href="#c基础语法"></a> C++基础语法</h1><h2 id="1-输入输出"><a class="markdownIt-Anchor" href="#1-输入输出"></a> 1、输入输出</h2><h3 id="11-使用cout进行输出"><a class="markdownIt-Anchor" href="#11-使用cout进行输出"></a> 1.1 使用cout进行输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;Come up and C++ me some time.&quot;</span>；<br></code></pre></td></tr></table></figure><p>双括号引起的部分是要打印的字符串，&lt;&lt;符号表示该语句把整个字符串发送给cout，它将一个字符串插入到了输出流中。<br />cout在头文件iostream中定义。</p><h3 id="12-控制符endl"><a class="markdownIt-Anchor" href="#12-控制符endl"></a> 1.2 控制符endl</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>endl表示重起一行，在输出流中插入endl将导致光标移到下一行开头。<br />endl在头文件iostream中定义。</p><h3 id="13-换行符"><a class="markdownIt-Anchor" href="#13-换行符"></a> 1.3 换行符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;Pluto is a dwarf planet.\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Pluto is a dwarf planet.&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>endl确保程序继续运行前刷新输出（将其立即显示在屏幕上），使用\n在某些系统中可能在输入信息后才能出现提示。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python的一些常用函数</title>
    <link href="/2022/03/23/python1/"/>
    <url>/2022/03/23/python1/</url>
    
    <content type="html"><![CDATA[<h1 id="python的一些常用函数"><a class="markdownIt-Anchor" href="#python的一些常用函数"></a> python的一些常用函数</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>因为最近在准备蓝桥杯python组的比赛，特罗列总结出python的一些常用函数。后续随着使用也会陆续整理。</p><h2 id="内置函数"><a class="markdownIt-Anchor" href="#内置函数"></a> 内置函数</h2><h3 id="1-数学函数"><a class="markdownIt-Anchor" href="#1-数学函数"></a> 1 数学函数</h3><p>1.1 abs()：取绝对值</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>(-<span class="hljs-number">10</span>))  <span class="hljs-comment">##10</span><br></code></pre></td></tr></table></figure><p>1.2 divmod()：同时取商和余数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">divmod</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment">##(3, 1)</span><br></code></pre></td></tr></table></figure><p>1.3 sum()：求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment">##6</span><br></code></pre></td></tr></table></figure><p>1.4 round()：四舍五入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">5.1</span>))  <span class="hljs-comment">##5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">5.5</span>))  <span class="hljs-comment">##6</span><br></code></pre></td></tr></table></figure><p>1.5 pow(m, n)：计算m的n次方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment">##8</span><br></code></pre></td></tr></table></figure><p>1.6 min()/max()：最小(大)值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">min</span>(<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment">##2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment">##9</span><br></code></pre></td></tr></table></figure><h3 id="2-数据转换函数"><a class="markdownIt-Anchor" href="#2-数据转换函数"></a> 2 数据转换函数</h3><p>2.1 hex()：十进制转换成十六进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-number">100</span>))  <span class="hljs-comment">##0x64</span><br></code></pre></td></tr></table></figure><p>2.2 oct()：十进制转换成八进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">oct</span>(<span class="hljs-number">100</span>))  <span class="hljs-comment">##0o144</span><br></code></pre></td></tr></table></figure><p>2.3 bin()：十进制转换成二进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-number">100</span>))  <span class="hljs-comment">##0b1100100</span><br></code></pre></td></tr></table></figure><p>2.4 bool()：将指定参数类型转换成布尔类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>))  <span class="hljs-comment">##True</span><br></code></pre></td></tr></table></figure><p>2.5 ord()：获取单个字符的ASCII数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;A&quot;</span>))  <span class="hljs-comment">##65</span><br></code></pre></td></tr></table></figure><p>2.6 float()：转换成浮点数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(<span class="hljs-number">10</span>))  <span class="hljs-comment">##10.0</span><br></code></pre></td></tr></table></figure><p>2.7 chr() ：转换一个整数并返回所对应的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(<span class="hljs-number">65</span>))  <span class="hljs-comment">##A</span><br></code></pre></td></tr></table></figure><p>2.8 list()： 将可迭代对象转换为列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)))  <span class="hljs-comment">##[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><p>2.9 upper()/lower()：大小写转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hELLO world!&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>.upper())<br>HELLO WORLD!<br></code></pre></td></tr></table></figure><h3 id="3-对象创建函数"><a class="markdownIt-Anchor" href="#3-对象创建函数"></a> 3 对象创建函数</h3><h3 id="4-迭代器操作函数"><a class="markdownIt-Anchor" href="#4-迭代器操作函数"></a> 4 迭代器操作函数</h3><h2 id="基本常用函数"><a class="markdownIt-Anchor" href="#基本常用函数"></a> 基本常用函数</h2><h2 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h2><h3 id="1-最基本的文件操作"><a class="markdownIt-Anchor" href="#1-最基本的文件操作"></a> 1 最基本的文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;E:\hello.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>res = []<br>s = fp.readlines()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>    res.append(i.strip(<span class="hljs-string">&#x27;\n&#x27;</span>)) <span class="hljs-comment">#使用strip()去掉换行符，如果不去的话会把‘\n’也读进来</span><br>fp.close() <span class="hljs-comment">#记得要关闭连接，养成良好习惯</span><br><br><span class="hljs-built_in">print</span>(res[:])<br></code></pre></td></tr></table></figure><h3 id="2-字符串操作"><a class="markdownIt-Anchor" href="#2-字符串操作"></a> 2 字符串操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">fp =  <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;E:\hello.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>res = [s.strip(<span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> fp.readlines()]<br>fp.close()<br><span class="hljs-built_in">print</span>(res[:])<br></code></pre></td></tr></table></figure><h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2><h3 id="1-datetime模块"><a class="markdownIt-Anchor" href="#1-datetime模块"></a> 1 datetime模块</h3><p>1.1 日期对象——date类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetimee<br><br>d = datetime.date(<span class="hljs-number">2019</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)<span class="hljs-comment"># 年，月，日</span><br><span class="hljs-built_in">print</span>(d)  <span class="hljs-comment">## 2019-01-11</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br>a1 = datetime.date(<span class="hljs-number">2019</span>,<span class="hljs-number">8</span>,<span class="hljs-number">26</span>)<br><span class="hljs-built_in">print</span>(a1.isocalendar())<br><span class="hljs-built_in">print</span>(a1.isoformat())<br><span class="hljs-built_in">print</span>(a1.isoweekday())<br><span class="hljs-built_in">print</span>(a1.weekday())<br><span class="hljs-built_in">print</span>(a1.replace(<span class="hljs-number">2018</span>,<span class="hljs-number">4</span>,<span class="hljs-number">30</span>))<br><span class="hljs-comment">#(2019, 35, 1)</span><br><span class="hljs-comment">#2019-08-26</span><br><span class="hljs-comment">#1</span><br><span class="hljs-comment">#0</span><br><span class="hljs-comment">#2018-04-30</span><br></code></pre></td></tr></table></figure><p>1.2 时间对象——time类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br>t = datetime.time(<span class="hljs-number">20</span>, <span class="hljs-number">36</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>)<span class="hljs-comment"># 时，分，秒，毫秒</span><br><span class="hljs-built_in">print</span>(t)  <span class="hljs-comment">## 20：36：15.000001</span><br></code></pre></td></tr></table></figure><p>1.3 日期时间对象——datetime类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>now = datetime.now()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前日期时间是：&#x27;</span>,now)  <span class="hljs-comment">## 2022-03-27 13:45:53.536404</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前日期是：&#x27;</span>,now.date())  <span class="hljs-comment">## 2022-03-27</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前时间是：&#x27;</span>,now.time())  <span class="hljs-comment">## 13:45:53.536404</span><br>```e<br>日期时间转化为时间戳<br>```python<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-built_in">print</span>(datetime.now().timestamp())  <span class="hljs-comment">##1627700208.446621</span><br></code></pre></td></tr></table></figure><p>时间戳转化为日期时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-built_in">print</span>(datetime.fromtimestamp(<span class="hljs-number">1627700208.446621</span>))  <span class="hljs-comment">## 2022-03-27 13:45:53.536404</span><br></code></pre></td></tr></table></figure><p>日期时间对象转字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-built_in">print</span>(datetime.now().strftime(<span class="hljs-string">&quot;%Y+%m+%d&quot;</span>))  <span class="hljs-comment">## 2022+03+27</span><br></code></pre></td></tr></table></figure><p>字符串转日期时间对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>a = datetime.strptime(<span class="hljs-string">&#x27;2022-5-22  15:23:38&#x27;</span>, <span class="hljs-string">&#x27;%Y-%m-%d  %H:%M:%S&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))  <span class="hljs-comment">## &lt;class &#x27;datatime.datatime&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment">## 2022-5-22  15:23:38</span><br></code></pre></td></tr></table></figure><p>1.4 时间间隔对象——timedelta类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br>now = datetime.datetime.now()<br>a = datetime.timedelta(hours=<span class="hljs-number">8</span>,minutes=<span class="hljs-number">20</span>,seconds=<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))  <span class="hljs-comment">## &lt;class &#x27;datatime.timedelta&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(now - a)  <span class="hljs-comment">## 2021-07-31 02:58:29.424161</span><br><span class="hljs-built_in">print</span>(now + a)  <span class="hljs-comment">## 2021-07-31 19:38:49.424161</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++的一些特点</title>
    <link href="/2022/03/22/Cpp1/"/>
    <url>/2022/03/22/Cpp1/</url>
    
    <content type="html"><![CDATA[<h1 id="c的一些特点"><a class="markdownIt-Anchor" href="#c的一些特点"></a> C++的一些特点</h1><h2 id="1-main函数"><a class="markdownIt-Anchor" href="#1-main函数"></a> 1 main()函数</h2><p><strong>1.1</strong> 主函数必须是int main()或int main(void)<br /><em>原因</em>：运行cpp程序时，通常从main()函数开始执行。因此，如果没有main()，程序将不完整，编译器将指出未定义main()函数。</p><p><strong>1.2</strong> main()最后可以不返回0<br /><em>原因</em>：ANSI/ISO C++标准为，如果编译器到达main()函数末尾时没有遇到返回语句，则认为main()函数以return 0结尾。</p><h2 id="2-注释"><a class="markdownIt-Anchor" href="#2-注释"></a> 2 注释</h2><p><strong>2.1</strong> 注释以“//”打头，到行尾结束<br /><strong>2.2</strong> 注释可以位于单独一行，也可和代码位于同一行</p><h2 id="3-预处理器和头文件名"><a class="markdownIt-Anchor" href="#3-预处理器和头文件名"></a> 3 预处理器和头文件名</h2><p><strong>3.1</strong> 如果程序要使用某些工具，要在前几行标明#include…<br /><em>原因</em>：C++和C一样，使用一个预处理器，在主编译之前对源文件进行处理，例如在源代码被编译之前，替换或添加文本。</p><p><strong>3.2</strong> 头文件名没有扩展名</p><h2 id="4-名称空间"><a class="markdownIt-Anchor" href="#4-名称空间"></a> 4 名称空间</h2><p><strong>4.1</strong> using namespace std;<br />原因：有助于组织程序，在调用同名函数时可以指定哪个名称空间的函数,如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">Microflop::<span class="hljs-built_in">wanda</span>(<span class="hljs-string">&quot;go dancing?&quot;</span>);<br>Piscine::<span class="hljs-built_in">wanda</span>(<span class="hljs-string">&quot;a fish named Desire&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果省略了这条语句，那么就要使用如下语句编码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;Come up and C++ me some time.&quot;</span>;<br>std::cout &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>更好的办法是，只是通过using声明使所需名称可用，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::cin;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01：计算机网络和因特网</title>
    <link href="/2022/03/21/Cn1/"/>
    <url>/2022/03/21/Cn1/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><blockquote><p><em><strong>纸上得来终觉浅，绝知此事要躬行。</strong></em></p></blockquote><div class="code-wrapper"><pre><code class="hljs">在本专栏中，我们将使用*公共因特网*（一种特定的计算机网络）作为讨论计算机网络机器协议的主要载体。</code></pre></div><h1 id="一-因特网网络的网络"><a class="markdownIt-Anchor" href="#一-因特网网络的网络"></a> 一、因特网：网络的网络</h1><blockquote><p>何为因特网？可以有两种解释：<br />——构成因特网的基本硬件和软件组件<br />——为分布式应用提供服务的联网基础设施</p></blockquote><p>下面我们分别以这两方面作为切入点，剖析因特网</p><h2 id="11-具体构成描述"><a class="markdownIt-Anchor" href="#11-具体构成描述"></a> 1.1 具体构成描述</h2><h3 id="111-端系统-通信链路-分组交换机-分组简介"><a class="markdownIt-Anchor" href="#111-端系统-通信链路-分组交换机-分组简介"></a> 1.1.1 端系统、通信链路、分组交换机、分组简介</h3><p>用因特网术语来说，所有与它相联系的设备统称为<strong>主机</strong>（host）或<strong>端系统</strong>（end system）。</p><blockquote><p>端系统通过<strong>通信链路</strong>（communication link）和<strong>分组交换机</strong>（packet switch）连接到一起。</p></blockquote><p><em>通信链路</em>。它们由不同类型的物理媒体（同轴电缆、铜线、光纤和无线电频谱）组成。不同的链路有不同的传输速率（以bit/s或bps度量）。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包我们将其称为<strong>分组</strong>（packet）。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。</p><p><em>分组交换机</em>。分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。在当今的因特网中，两种最著名的类型是<strong>路由器</strong>（router）和<strong>链路层交换机</strong>（link-layer switch）。</p><blockquote><p><strong>路由器</strong>通常用于网络核心中<br /><strong>链路层交换机</strong>通常用于接入网中</p></blockquote><p>从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径</strong>（route或path）。</p><p>用于传送分组的分组交换网络在许多方面类似于承载运输车辆的运输网络，该网络包括了高速公路、公路和立交桥。当工厂需要将大量货物搬运至远方的仓库时，工厂就要将货物分开装上卡车车队，通过高速公路、公路和立交桥将货物搬运至仓库。在这一过程中，各个环节扮演的角色如下表所示：</p><table><thead><tr><th>角色</th><th>环节</th></tr></thead><tbody><tr><td>分组</td><td>卡车</td></tr><tr><td>通信链路</td><td>高速公路、公路</td></tr><tr><td>分组交换机</td><td>立交桥</td></tr><tr><td>端系统</td><td>工厂、仓库</td></tr></tbody></table><h3 id="112-isp简介"><a class="markdownIt-Anchor" href="#112-isp简介"></a> 1.1.2 ISP简介</h3><p>端系统通过<strong>因特网服务提供商</strong>（ISP）接入因特网。每个ISP是一个由多个分组交换机和多段通信链路组成的网络。各ISP为端系统提供各种不同类型的网络接入（线缆调制解调器或如DSL的住宅宽带接入、高速局域网接入、无线接入和56kbps拨号调制解调器接入）。</p><p>因特网将端系统彼此互联，因此ISP也必须互联。</p><blockquote><p><strong>低层ISP</strong>通过国家、国际的高层ISP（Level 3 Communications、AT&amp;T、Sprint和NTT）互联；<br /><strong>高层ISP</strong>是由通过高速光纤链路互联的高速路由器组成的</p></blockquote><h3 id="113-协议简介"><a class="markdownIt-Anchor" href="#113-协议简介"></a> 1.1.3 协议简介</h3><p>端系统、分组交换机和其他因特网部件都要运行一系列协议（protocol），这些协议控制因特网中信息的接收和发送。<strong>传输控制协议</strong>（TCP）和<strong>网络协议</strong>（IP）是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为TCP/IP。</p><p>鉴于因特网协议的重要性，每个人就各个协议及其作用取得一致认识很重要，这样人们就能创造协同工作的系统和产品。自然而然，我们引入了因特网<strong>标准</strong>（Internet standard），它由因特网工程任务组（IETF）研发。IETF的标准文档称为<strong>请求评论</strong>（RFC），它们定义了TCP、IP、HTTP（用于Web）和SMTP（用于电子邮件）等协议。当然，其他组织也在制定用于网络组件的标准。</p><h2 id="12-服务描述"><a class="markdownIt-Anchor" href="#12-服务描述"></a> 1.2 服务描述</h2><blockquote><p>何为因特网？可以有两种解释：<br />——构成因特网的基本硬件和软件组件<br />——为分布式应用提供服务的联网基础设施</p></blockquote><p>上文以前者作为切入点，现在我们从<em>应用程序提供服务的基础设施</em>的角度来描述因特网。</p><p>我们平时接触到的大部分应用程序，例如电子邮件、Web冲浪、即时讯息等等，它们称为<strong>分布式应用程序</strong>（distributed application），因为它们涉及多台相互交换数据的端系统。</p><p>与因特网相连的端系统提供了一个<strong>应用程序编程接口</strong>（API）。API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。</p><p>举个例子，Alice要向Bob寄一封信，Alice不能写完信后就将信丢出窗外，邮政服务要求Alice将信放入 信封并贴上邮票，还要投进邮箱中。对应到因特网中，就有如下类比：</p><table><thead><tr><th>角色</th><th>环节</th></tr></thead><tbody><tr><td>软件A</td><td>Alice</td></tr><tr><td>软件B</td><td>Bob</td></tr><tr><td>API</td><td>邮政服务规定</td></tr></tbody></table><h2 id="13-什么是协议"><a class="markdownIt-Anchor" href="#13-什么是协议"></a> 1.3 什么是协议</h2><h3 id="131-人类活动类比"><a class="markdownIt-Anchor" href="#131-人类活动类比"></a> 1.3.1 人类活动类比</h3><blockquote><p>我们用一张图生动形象的表达协议的含义</p></blockquote><p><a href="https://img-blog.csdnimg.cn/86635908c0e14a5aa3909b7848af7ccb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTI3NTUwNTk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center">图为人类协议和计算机网络协议</a></p><p>如果人们使用不同的协议（例如，一个人讲礼貌而另一个人不讲礼貌），该协议就不能互动，因而不能完成有用的工作。在网络中这个道理同样成立。即为了完成一项工作，要求两个（或多个）通信实体运行相同协议。</p><h3 id="132-网络协议"><a class="markdownIt-Anchor" href="#132-网络协议"></a> 1.3.2 网络协议</h3><blockquote><p>在因特网中，凡是涉及两个或多个远程通信实体的所有活动都受<strong>协议</strong>的制约。</p></blockquote><p>例如，在两台物理上连接的计算机中，硬件实现的协议控制了在两块网络接口卡间的“线上”的比特流；在端系统中，拥塞控制协议控制了在发送方和接收方之间传输的分组发送的速率。</p><p>从上述的人类活动和网络的例子中可见，报文的交换以及发送和接收这些报文时所采取的动作是定义一个协议的关键元素：</p><blockquote><p>一个<strong>协议</strong>定义了在两个或多个通信实体之间交换的<strong>报文格式和次序</strong>，以及报文发送和（或）接收一条报文或其他事件所采取的<strong>动作</strong>。</p></blockquote><h1 id="二-网络边缘"><a class="markdownIt-Anchor" href="#二-网络边缘"></a> 二、网络边缘</h1><p>我们通常把与因特网相连的计算机和其他设备称为端系统，因为它们位于<strong>互联网的边缘</strong>，故而被称为端系统。端系统也称为<strong>主机</strong>，因为它们容纳（即运行）应用程序，如Web浏览器程序、Web服务器程序、电子邮件阅读程序或电子邮件服务器程序等。端系统有时又被进一步划分为两类：<strong>客户</strong>（client）和<strong>服务器</strong>（server）。</p><blockquote><p><strong>客户</strong>相当于是桌面PC、移动PC和智能手机等，<br /><strong>服务器</strong>相当于是更为强大的机器，用于存储和发布Web页面、流视频、中继电子邮件等。</p></blockquote><h2 id="21-接入网"><a class="markdownIt-Anchor" href="#21-接入网"></a> 2.1 接入网</h2><blockquote><p><strong>接入网</strong>是指将端系统连接到其<strong>边缘路由器</strong>的<strong>物理链路</strong></p></blockquote><p>边缘路由器是端系统到任何其他远程端系统的路径上的<strong>第一台路由器</strong>。</p><p><a href="https://img-blog.csdnimg.cn/0adfe3517b9f4caaad181ea94136954e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTI3NTUwNTk=,size_20,color_FFFFFF,t_70,g_se,x_16">图为端系统交互的大致组成部分</a></p><h3 id="211-家庭接入dsl-电缆-ftth-拨号和卫星"><a class="markdownIt-Anchor" href="#211-家庭接入dsl-电缆-ftth-拨号和卫星"></a> 2.1.1 家庭接入：DSL、电缆、FTTH、拨号和卫星</h3><p>以前，宽带住宅接入有两种类型：<strong>数字用户线</strong>（DSL）和<strong>电缆</strong>。</p><p><a href="https://img-blog.csdnimg.cn/c9e80d89bf684f809beca1e20b49e770.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTI3NTUwNTk=,size_20,color_FFFFFF,t_70,g_se,x_16">图为DSL因特网接入</a></p><p>除了DSL电话接入，还有利用有线电视公司现有有线电视基础设施的电缆因特网接入，这里不再赘述，读者可自行查阅。目前主流的上网方式是<strong>光纤到户</strong>（FTTH），即从本地中心局直接到家庭提供一条光纤路径。</p><p><a href="/img/cn1.4.png">图为FTTH因特网接入</a></p><h3 id="212-企业和家庭接入以太网和wifi"><a class="markdownIt-Anchor" href="#212-企业和家庭接入以太网和wifi"></a> 2.1.2 企业（和家庭）接入：以太网和WIFI</h3><p>在公司和大学校园以及在越来越多的家庭环境中，通常是用局域网（LAN）将端用户连接到边缘路由器，以太网是目前最为流行的接入技术。使用以太网接入，用户通常以100Mbps速率接入以太网交换机，而服务器可能具有1Gbps甚至10Gbps的接入速率。</p><p><a href="/img/cn1.5.png">图为以太网因特网接入</a></p><p>在无线LAN环境中，无线用户从/到一个接入点发送/接收分组，该接入点与企业网连接，该企业网再与有线因特网相连。基于IEEE 802.11的技术的无线LAN称为WiFi。</p><h2 id="22-物理媒体"><a class="markdownIt-Anchor" href="#22-物理媒体"></a> 2.2 物理媒体</h2><p>物理媒体划分为两类：<strong>导引型媒体</strong>（guided media）和<strong>非导引型媒体</strong>（unguided meidia）。</p><blockquote><p>导引型媒体，电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。<br />非导引型媒体，电波在空气或外层空间中传播，如无线局域网或数字卫星频道。</p></blockquote><p>具体物理媒体介绍暂且不更，有兴趣者可自行查阅。</p><h1 id="三-网络核心"><a class="markdownIt-Anchor" href="#三-网络核心"></a> 三、网络核心</h1><p><strong>网络核心</strong>指互联因特网端系统的分组交换机和链路构成的网状网络。</p><h2 id="31-分组交换"><a class="markdownIt-Anchor" href="#31-分组交换"></a> 3.1 分组交换</h2><p>源端系统向目的端系统发送报文，源将长报文划分为一个个<strong>分组</strong>，每个分组都通过<strong>通信链路</strong>和<strong>分组交换机</strong>传送，分组以等于该链路<strong>最大传输速率</strong>的速度传输通过通信链路。因此，如果某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R比特/秒，则传输该分组的时间为L/R秒。</p><h3 id="311-存储转发运输"><a class="markdownIt-Anchor" href="#311-存储转发运输"></a> 3.1.1 存储转发运输</h3><blockquote><p><strong>存储转发运输</strong>，是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p></blockquote><p>多数分组交换机在链路的输入端使用<strong>存储转发运输</strong>（store-and-forward transmission）机制。</p><p>为了深刻理解存储转发运输，特举例说明（这里忽略传播时延），</p><blockquote><p>发送一个分组：<br />源在时刻0开始传输；<br />在时刻L/R，路由器接收到整个分组；<br />在时刻2L/R，路由器传输了整个分组，并已被目的地接收。<br />总时延为2L/R。</p></blockquote><blockquote><p>发送三个分组：<br />源在时刻0开始传输；<br />在时刻L/R，路由器开始转发第一个分组，源开始发送第二个分组；<br />在时刻2L/R，目的地收到第一个分组，路由器收到第二个分组；<br />在时刻3L/R，目的地收到前两个分组，路由器收到第三个分组；<br />在时刻4L/R，目的地接收全部分组。<br />总时延为4L/R。</p></blockquote><p>综上所诉，我们可以考虑N条速率均为R的链路组成的路径（所以，源和目的地之间有N-1台路由器），d（端时延）=N*L/R</p><h3 id="312-排队时延和分组丢失"><a class="markdownIt-Anchor" href="#312-排队时延和分组丢失"></a> 3.1.2 排队时延和分组丢失</h3><p>每个分组交换机有多条链路与之相连，对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>（output buffer）（也称为<strong>输出队列</strong>output queue），它用于存储路由器准备发往那条链路的分组。</p><p>如果到达的分组需要传输到的那条链路正在传输其他分组，到达的分组就要在输出缓存中等待，由此引起的时延叫做<strong>排队时延</strong>（queue delay）。这些时延是变化的，变化的程度取决于网络中的拥塞程度，如果分组到达时缓存空间已经满了，就会发生**分组丢失（丢包）（packet lost）**的情况，到达的分组或在排队的分组将被丢弃。</p><h3 id="313-转发表和路由选择协议"><a class="markdownIt-Anchor" href="#313-转发表和路由选择协议"></a> 3.1.3 转发表和路由选择协议</h3><p>在因特网中，每个端系统具有一个称为<strong>IP地址</strong>的地址。当源主机向目的端系统发送一个分组时，源在该分组的首部包含了目的地的IP地址。当一个分组到达路由器时，路由器检查该分组的目的地IP地址的<strong>一部分</strong>，再朝着目的地方向发送分组到达相邻的路由器，循环往复。每台路由器具有一个<strong>转发表</strong>（forwarding table），用于将目的地的一部分映射成为输出链路。</p><p>因特网具有一些特殊的<strong>路由选择协议</strong>（routing protocol），用于自动设置转发表。例如，一个路由选择协议可以决定每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器中的转发表。</p><h2 id="32-电路交换"><a class="markdownIt-Anchor" href="#32-电路交换"></a> 3.2 电路交换</h2><blockquote><p>通过网络链路和交换机移动数据有两种基本方法：<strong>分组交换</strong>（packet switching）和<strong>电路交换</strong>（circuit switching）。</p></blockquote><p><strong>电路交换</strong>网络，预留了端系统间通信沿路径所需的资源（缓存，链路传输速率）；  例如需要顾客预定的餐馆。<br /><strong>分组交换</strong>网络，不预留。例如不需要预定但是要等号的餐馆。</p><p>举例说明电路交换网络。在一个网络中，用4条链路互联了4台电路交换机。每条链路有4条电路，因此每条链路能够支持4条并行连接。当两台主机要通信时，该网络在两台主机之间创建一条专用的端到端连接（end-to-end connection），该连接在连接期间获得该链路带宽的1/4部分。</p><h3 id="321-电路交换网中的复用"><a class="markdownIt-Anchor" href="#321-电路交换网中的复用"></a> 3.2.1 电路交换网中的复用</h3><blockquote><p>链路中的电路是通过<strong>频分复用</strong>（FDM）或<strong>时分复用</strong>（TDM）来实现的。</p></blockquote><p>对于FDM，链路的频谱由跨越链路创建的所有连接所共享，在连接期间链路为每条连接专用一个频段。在电话网络中，这个频段通常具有4kHZ的宽度，该频段的宽度叫做<strong>带宽</strong>（bandwidth）。</p><p>对于TDM，时间被划分为固定区间的<strong>帧</strong>，每帧被划分为固定数量的<strong>时隙</strong>。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，一个时隙（在每个帧内）可用于传输该连接的数据。一条电路的传输速率等于帧速率乘以一个时隙中的比特数量。</p><p>电路交换因为在<strong>静默期</strong>（silent period）专用电路空间而效率较低。</p><h3 id="322-分组交换与电路交换的对比"><a class="markdownIt-Anchor" href="#322-分组交换与电路交换的对比"></a> 3.2.2 分组交换与电路交换的对比</h3><p><strong>电路交换</strong>不考虑需求，而预先分配了传输链路的使用，这使得已分配而并不需要的链路时间未被利用。</p><p><strong>分组交换</strong>按需分配链路使用。链路传输能力将在所有用户之间逐分组地被共享，这些用户有分组需要在链路上传输。</p><p>分组交换是趋势。</p><h2 id="33-网络的网络"><a class="markdownIt-Anchor" href="#33-网络的网络"></a> 3.3 网络的网络</h2><p>端系统通过ISP与因特网相连，而ISP自身也必须互联，通过创建网络的网络解决这一问题。</p><p><a href="/img/cn1.6.png">图为ISP互联的等级结构</a></p><p>存在点（PoP）存在于等级结构的所有层次，但底层（接入ISP）除外。一个PoP只是提供商网络中的一台或多台路由器（在相同位置）群组，其中客户ISP能够与提供商ISP连接，客户网络能够从第三方通信提供商租用高速链路直接将路由器之一连接到位于该PoP的一台路由器。</p><p>任何ISP（除了第一层ISP）可以选择为多宿（multi-home），即可以与两个或更多提供商ISP连接。当一个ISP多宿时，即使它的提供商之一出现故障，它仍然能够继续发送和接收分组。</p><p>为了减少客户ISP支付给提供商ISP的费用，位于相同等级结构层次的邻近一对ISP能够对等（peer），使它们之间的所有流量经直接连接而不是通过上游的中间ISP传输。沿着这些相同路线，第三方公司创建一个因特网交换点（IXP），IXP是一个汇合点，多个ISP能够在这里共同对等。</p><p>内容提供商（如谷歌）通过创建自己的网络，不仅减少了向顶层ISP支付的费用，而且对其服务最终如何交付给端用户有了更多的控制。</p><h1 id="四-分组交换中的时延-丢包和吞吐量"><a class="markdownIt-Anchor" href="#四-分组交换中的时延-丢包和吞吐量"></a> 四、分组交换中的时延、丢包和吞吐量</h1><h2 id="41-分组交换网中的时延概述"><a class="markdownIt-Anchor" href="#41-分组交换网中的时延概述"></a> 4.1 分组交换网中的时延概述</h2><p>当分组从一个结点（端系统或路由器）沿着这条路径到后继结点，该分组在沿途的每个结点经受了几种不同类型的时延。其中最为重要的是<strong>结点处理时延</strong>（nodel processing delay）、<strong>排队时延</strong>（queueing delay）、<strong>传输时延</strong>（transmission delay）和<strong>传播时延</strong>（propagation delay），这些时延总体累加起来是<strong>结点总时延</strong>（total nodal delay）。</p><p><strong>时延的类型</strong></p><p>1 <strong>处理时延</strong><br />检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。它还包括其他因素，如检查比特级别差错所需要的时间。<br />通常是<em>微秒或更低</em>量级。</p><p>2 <strong>排队时延</strong><br />在队列中当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。<br />通常是<em>毫秒到微秒</em>量级。</p><p>3 <strong>传输时延</strong><br />用L（比特）表示该分组的长度，用R（bps）表示从路由器A到B的链路传输速率，则传输时延为L/R。注意是路由器A将分组推向链路所需要的时间。<br />通常是<em>毫秒到微秒</em>量级。</p><p>4 <strong>传播时延</strong><br />当一个比特被推向链路，送往目标路由器时，从该链路的起点到目标路由器传播所需要的时间是传播时延。该传播速率取决于该链路的物理媒体（光纤、双绞铜线等），速率范围略小于光速。该传播时延等于两台路由器之间的距离除以传播速率，即d/s。<br />广域网中，通常是<em>毫秒</em>量级。</p><p>5 <strong>传输时延</strong>和<strong>传播时延</strong>的<strong>比较</strong><br />传输时延是分组长度和链路传输速率的函数；<br />传播时延是两台路由器之间距离的函数。</p><blockquote><p><strong>总时延</strong>由上述四种时延相加，在实际生活中每种时延可能变化很大。</p></blockquote><h2 id="42-排队时延和丢包"><a class="markdownIt-Anchor" href="#42-排队时延和丢包"></a> 4.2 排队时延和丢包</h2><p>令a表示分组到达队列的平均速率（a的单位是分组/秒，即pkt/s），R是传输速率，假定所有分组都是由L比特组成的，则比特到达分组的平均速率是La（bps）。比率La/R被称为<strong>流量强度</strong>。如果La/R&gt;1，则该队列将趋于无限增大。因此，<em>设计系统时流量强度不能大于1</em>。</p><p>如果<strong>流量强度</strong>接近于0，则几乎没有分组到达并且到达间隔很大，随着流量强度接近1，平均排队长度将变得越来越长。随着流量强度接近1，平均排队时延迅速增加。该强度的少量增加将导致时延大得多的增加。<br /><a href="/img/cn1.7.png">图为平均排队时延与流量强度的关系</a></p><p>在实际使用中，一条链路前的队列是有限的，其容量受限于路由器设计和使用成本，当分组到达满的队列时，路由器将丢弃这个分组，即<strong>丢包</strong>。丢包的份额随着流量强度的增加而增加，一个结点的性能不仅根据时延度量，还与丢包的概率度量。丢失的分组可能基于端到端的原则重传，以确保所有的数据最终传到目的地。</p><h2 id="43-端到端时延"><a class="markdownIt-Anchor" href="#43-端到端时延"></a> 4.3 端到端时延</h2><p>上一节研究了结点间的时延，还需要研究端到端的时延，这里不再赘述。除了上文介绍的几种时延，端系统中还存在着其他一些重要时延，例如，作为它的协议的一部分，希望向共享媒体传输分组的端系统可以有意地延迟它的传输以与其他端系统共享媒体。另一个重要的时延是<strong>媒体分组化时延</strong>。</p><h2 id="44-计算机网络中的吞吐量"><a class="markdownIt-Anchor" href="#44-计算机网络中的吞吐量"></a> 4.4 计算机网络中的吞吐量</h2><p>除了时延和丢包，计算机网络中另一个必不可少的性能测度是<strong>端到端吞吐量</strong>。在任何时间瞬间的<strong>瞬时吞吐量</strong>是端系统B接收到该文件的速率。在下载期间，如果文件由F比特组成，端系统B接收到所有文件用时T秒，则<strong>平均吞吐量</strong>是F/T（bps）。</p><p>对于简单的两链路的网络，其吞吐量是min|R1, R2|，这叫做瓶颈链路（bottleneck link）的传输速率。n条链路同理。<br /><a href="/img/cn1.8.png">图为两链路网络</a></p><p>吞吐量取决于数据流过的链路的传输速率，当没有其他干扰流量时，其吞吐量能够近似为沿着源和目的地之间路径的<strong>最小传输速率</strong>。</p><h1 id="五-协议层次及其服务模型"><a class="markdownIt-Anchor" href="#五-协议层次及其服务模型"></a> 五、协议层次及其服务模型</h1><h2 id="51-分层的体系结构"><a class="markdownIt-Anchor" href="#51-分层的体系结构"></a> 5.1 分层的体系结构</h2><h3 id="511-协议分层"><a class="markdownIt-Anchor" href="#511-协议分层"></a> 5.1.1 协议分层</h3><p>为了给网络协议的设计提供一个结构，网络设计者以<strong>分层</strong>（layer）的方式组织协议以及实现这些协议的网络硬件。每个协议属于这些层次之一，就像航线体系结构中的每种功能属于某一层一样。<br /><a href="/img/cn1.9.png">图为航线功能的水平分层</a></p><p>每层通过在该层中执行某些动作或使用直接下层的服务来提供<strong>服务</strong>（service），即<strong>服务模型</strong>（service model）。例如，由第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送，这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送服务，加上第n层的检测和重传丢失报文的功能来实现的。</p><p>一个协议层能够用软件、硬件或两者的结合来实现。一个第n层协议也<strong>分布</strong>在构成该网络的端系统、分组交换机和其他组件中，第n层协议的不同部分常常位于这些网络组件的各部分中。</p><blockquote><p>协议分层<br />优点：<strong>概念化</strong>和<strong>结构化</strong>。<br />潜在的缺点：<br />1 一层可能冗余较低层的功能<br />2 某层的功能可能需要仅在其他某层才出现的信息，违反了层次分离的目标。</p></blockquote><p>各层的所有协议称为协议栈（protocol stack），因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。</p><p>1 <strong>应用层</strong><br />应用层是网络应用程序及它们的应用层协议存留的地方。因特网的应用层包含许多协议，例如HTTP（Web文档的请求和传送）、SMTP（电子邮件报文的传输）和FTP（两个端系统之间的文件传送）。应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，这种位于应用层的信息分组称为<strong>报文</strong>（message）。</p><p>2 <strong>运输层</strong><br />因特网的运输层在应用程序端点之间传送应用层报文。在因特网中，运输层包含TCP和UDP两个运输协议，利用其中任一个都能运输应用层报文。我们把运输层报文称作<strong>报文段</strong>（segment）。<br />——<strong>TCP</strong>提供连接服务，包括了应用层报文向目的地的确保传递和流量控制（即发送方/接收方速率匹配）。<br />——<strong>UDP</strong>提供无连接服务，它不提供不必要服务的服务（没有可靠性、流量控制、拥塞控制等）。</p><p>3 <strong>网络层</strong><br />因特网的网络层负责将称为<strong>数据报</strong>（datagram）的网络层分组从一台主机移动到另一台主机。在一台源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址。</p><p>因特网的网络层包括内容如下：<br />1、著名的<strong>IP协议</strong>，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。IP协议是唯一的，所有具有网络层的因特网组件必须运行IP协议。<br />2、决定路由的<strong>路由选择协议</strong>，它使得数据报根据该路由从源传输到目的地。路由选择协议不唯一。</p><p>网络层包含了IP协议和一些路由选择协议，通常把它称为<strong>IP层</strong>。</p><p>4 <strong>链路层</strong><br />在每个结点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层。由链路层提供的服务取决于应用于该链路的特定链路层协议。网络层将受到来自每个不同的链路层协议的不同服务。我们把链路层分组称为帧（frame）。</p><p>5 <strong>物理层</strong><br />链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的<em>一个一个比特</em>从一个结点移动到下一个结点。在这一层的协议仍然是链路相关的，并且进一步与该链路的<strong>传输媒体相关</strong>（以太网关于双铜绞线、关于同轴电缆、关于光纤的协议等等）。在每种场合中，跨越这些链路移动一个比特是以不同的方式进行的。</p><h3 id="512-osi模型"><a class="markdownIt-Anchor" href="#512-osi模型"></a> 5.1.2 OSI模型</h3><p>因特网协议栈不是唯一的协议栈。国际标准化组织（ISO）提出计算机网络应组织为大约7层，称为开放系统互连（OSI）模型[ISO 2012]。这7层分别是：应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。相比于因特网协议栈，它新增了表示层和会话层。</p><p>1 <strong>表示层</strong><br />表示层的作用是使通信的应用程序能够解释交换数据的含义。这些服务包括数据压缩和数据加密以及数据描述（使应用程序不必担心在各台计算机中表示/存储的内部格式不同的问题）。</p><p>2 <strong>会话层</strong><br />会话层提供了数据交换定界和同步功能，包括了建立检查点和恢复方案的方法。</p><p>应用开发者决定这两个层次提供的服务是否重要，如果该服务重要，应用开发者就在应用程序中构建该功能。</p><h2 id="52-封装"><a class="markdownIt-Anchor" href="#52-封装"></a> 5.2 封装</h2><p>数据从发送端系统的协议栈向下，向上和向下经过中间的链路层交换机和路由器的协议栈，进而向上到达接收端系统的协议栈。链路层交换机实现第一层和第二层，路由器实现了第一层到第三层。<br /><a href="/img/cn1.10.png">图为主机、路由器和链路层交换机，每个包含了不同的层，反映了不同的功能</a></p><p>在发送主机端，一个<strong>应用层报文</strong>被传送给运输层。在最简单的情况下，运输层收取到报文并附上附加信息，应用层报文和运输层首部信息构成了<strong>运输层报文段</strong>。运输层由此<strong>封装</strong>（encapsulation）了应用层报文。运输层再向网络层传递该报文段，网络层增加了如源和目的地端系统地址等网络层首部信息，产生了<strong>网络层数据报</strong>。数据报接下来传递给链路层，链路层增加它自己的链路层首部信息并创建<strong>链路层帧</strong>（link-layer frame）。</p><p>由此可见，在每一层，一个分组具有两种类型的字段：首部字段和<strong>有效载荷字段</strong>（payload field）。有效载荷通常是来自上一层的分组。</p><p>封装的过程在实际中会更加复杂。例如，一个大报文可能被划分为多个运输层的报文段（可能被划分为多个网络层数据报），在接收端则必须从其连续的数据报中重构这样一个报文段。</p><h1 id="六-面对攻击的网络"><a class="markdownIt-Anchor" href="#六-面对攻击的网络"></a> 六、面对攻击的网络</h1><p><strong>网络安全</strong>领域主要探讨以下问题：攻击者如何攻击网络以及如何防御攻击，或者更好的设计能够事先免除这样的攻击的新型体系结构。</p><h2 id="61-有害程序能经过因特网放入到计算机中"><a class="markdownIt-Anchor" href="#61-有害程序能经过因特网放入到计算机中"></a> 6.1 有害程序能经过因特网放入到计算机中</h2><p>一旦恶意软件感染设备，就能够窃取隐私信息，然后发送给攻击者。这些受害设备网络被称为<strong>僵尸网络</strong>（botnet），坏人能够利用僵尸网络控制并有效地对目标主机展开垃圾邮件分发或分布式拒绝服务攻击。</p><p>今天的多数恶意软件是<strong>自我复制</strong>（self-replicating）的：一旦感染了一台主机，就会从那台主机寻求进入更多的主机。恶意软件能够以<strong>病毒</strong>或<strong>蠕虫</strong>的方式进行扩散，<br />——<strong>病毒</strong>（virus）是一种需要某种形式的用户交互来感染用户设备的恶意软件。<br />——<strong>蠕虫</strong>（worm）是一种无需任何明显用户交互就能进入设备的恶意软件。</p><h2 id="62-攻击者能够攻击服务器和网络基础设施"><a class="markdownIt-Anchor" href="#62-攻击者能够攻击服务器和网络基础设施"></a> 6.2 攻击者能够攻击服务器和网络基础设施</h2><p>还有一种宽泛类型的安全性威胁称为拒绝服务攻击（DoS攻击）。Dos攻击能够使得网络、主机或其他基础设施部分不能由合法用户使用。大多数因特网DoS攻击属于下列三种类型之一：</p><p>——<strong>弱点攻击</strong>。如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，或者更糟糕的是主机可能崩溃。<br />——<strong>带宽洪泛</strong>。攻击者向目标主机发送大量分组，分组数量之多使得目标的接入链路变得拥塞，使得合法的分组无法到达服务器。<br />——<strong>连接洪泛</strong>。攻击者在目标主机中创建大量的半开或全开TCP连接。该主机因这些伪造的连接而陷入困境，并停止接受合法的连接。</p><p>对于带宽洪泛攻击，如果某服务器的接入速率为R bps，则攻击者需要以大约R bps的速率来产生危害。当R非常大时，单一攻击源可能无法产生足够大的流量来伤害该服务器，而且如果从单一源发出所有流量的话，上游路由器就能够检测出该攻击并在该流量靠近服务器前就能将其阻挡下来。所以攻击者会采用<strong>分布式DoS</strong>（DDoS，控制多个源并让每个源向目标猛烈发送流量）的方式削弱或损坏服务器，所有受控源的聚合流量速率需要大约R的能力）。相比于DoS，DDoS更加难以检测和防范。</p><p><a href="/img/cn1.11.png">图为DDoS攻击</a></p><h2 id="63-攻击者能够嗅探分组"><a class="markdownIt-Anchor" href="#63-攻击者能够嗅探分组"></a> 6.3 攻击者能够嗅探分组</h2><p>在无线传输设备的附近放置一台被动的接收机，该接收机就能得到传输的每个分组的副本。记录每个流经的分组副本的被动接收机被称为<strong>分组嗅探机</strong>（packet sniffer）。</p><p>嗅探器也能够部署在有线环境中。在有线的广播环境中，如在许多以太网LAN中，分组嗅探器能够获得经该LAN发送的所有分组。此外，获得某机构与因特网连接的接入路由器或接入链路访问权的攻击者能够放置一台嗅探器以产生从该机构出入的每个分组的副本，再对嗅探到的分组进行离线分析，就能得出敏感信息。</p><p>因为分组嗅探器是被动的，所以难以检测出它们的存在。最好的防御嗅探的方法基本上都与<strong>密码学</strong>有关。</p><h2 id="64-攻击者能够伪装成你信任的人"><a class="markdownIt-Anchor" href="#64-攻击者能够伪装成你信任的人"></a> 6.4 攻击者能够伪装成你信任的人</h2><p>生成具有任意源地址、分组内容和目的地址的分组，然后将这个人工制作的分组传输到互联网中极为容易，这种将具有虚假源地址的分组注入因特网的能力被称为<strong>IP哄骗</strong>（IP spoofing），而它只是一个用户能够冒充另一个用户的许多方式的一种。</p><p>应对这种问题，我们需要采用<strong>端点鉴别</strong>。即一种使我们能够确信一个报文源自我们认为它应当来自的地方的机制。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/21/hello-world/"/>
    <url>/2022/03/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
