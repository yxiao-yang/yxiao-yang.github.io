<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>02：应用层</title>
    <link href="/2022/03/28/Cn2/"/>
    <url>/2022/03/28/Cn2/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote><p><em><strong>纸上得来终觉浅，绝知此事要躬行。</strong></em></p></blockquote><h1 id="一、应用层协议原理"><a href="#一、应用层协议原理" class="headerlink" title="一、应用层协议原理"></a>一、应用层协议原理</h1><p>研发网络应用程序的<strong>核心</strong>是写出能够运行在不同的端系统和通过网络彼此通信的程序。因此研发新应用时需要编写将在<strong>多台端系统</strong>上运行的软件。</p><h2 id="1-1-网络应用程序体系结构"><a href="#1-1-网络应用程序体系结构" class="headerlink" title="1.1 网络应用程序体系结构"></a>1.1 网络应用程序体系结构</h2><p><strong>应用程序体系结构</strong>（application architecture）明显不同于网络体系结构。网络体系结构是固定的，而应用程序体系结构由应用程序研发者设计。<br>应用程序体系结构目前有两种主流体系结构：<strong>客户-服务器体系结构</strong>或<strong>对等（P2P）体系结构</strong>。</p><h3 id="1-1-1-客户-服务器体系结构"><a href="#1-1-1-客户-服务器体系结构" class="headerlink" title="1.1.1 客户-服务器体系结构"></a>1.1.1 客户-服务器体系结构</h3><p>在客户-服务器体系结构中，有一个总是打开的主机称为<strong>服务器</strong>，它服务于来自许多其他称为<strong>客户</strong>的主机的请求。客户相互之间<strong>不直接通信</strong>。另一方面，该服务器具有固定的、周知的地址，该地址称为<strong>IP地址</strong>。</p><p><a href="/img/cn2.1.png">图为客户-服务器体系结构</a></p><p>在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。为此，配备大量主机的<strong>数据中心</strong>常被用于创建强大的虚拟服务器。如谷歌在全球拥有30~50个数据中心。一个数据中心能够有数十万台服务器，它们必须要供电和维护。</p><h3 id="1-1-2-P2P体系结构"><a href="#1-1-2-P2P体系结构" class="headerlink" title="1.1.2 P2P体系结构"></a>1.1.2 P2P体系结构</h3><p>在一个P2P体系结构中，对位于数据中心的专用服务器有最小的（或者没有）依赖。应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为<strong>对等方</strong>。因为这些对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的。<br><a href="/img/cn2.2.png">图为P2P体系结构</a></p><p>P2P最引人入胜的特性之一时自扩展性（self-scalability）。例如，在一个P2P共享文件中，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加服务能力。P2P体系结构也是成本有效的，因为它们通常不需要庞大的服务器基础设施和服务器带宽。</p><p>未来P2P应用面临三个主要挑战：<br>1 ISP友好。<br>2 安全性。<br>3 激励。</p><p>需要提及的是，某些应用具有<strong>混合</strong>的体系结构，它结合了客户-服务器和P2P的元素。例如，对于许多即时通信应用而言，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间（无需通过中间服务器）直接发送。</p><h2 id="1-2-进程通信"><a href="#1-2-进程通信" class="headerlink" title="1.2 进程通信"></a>1.2 进程通信</h2><p>在构建网络应用程序前，还需要对运行在多个端系统上的程序是如何互相通信有所了解。进行通信的实际上是<strong>进程</strong>（process）而不是程序。一个进程可以被认为是运行在端系统中的一个程序。</p><p>当进程运行在<strong>相同</strong>的端系统上时，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定。</p><p>在两个<strong>不同</strong>端系统上的进程，通过跨越计算机网络交换<strong>报文</strong>（message）而相互通信。<strong>发送进程</strong>生成并向网络中发送报文；<strong>接收进程</strong>接收这些报文并可能通过将报文发送回去进行响应。</p><h3 id="1-2-1-客户和服务器进程"><a href="#1-2-1-客户和服务器进程" class="headerlink" title="1.2.1 客户和服务器进程"></a>1.2.1 客户和服务器进程</h3><p>网络应用程序由成对的进程组成，这些进程通过网络相互发送报文。对每对通信进程，我i们通常将这两个进程之一标识为客户（client），而另一个进程标识为服务器（server）。</p><blockquote><p>在给定的一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程被标识为<strong>客户</strong>，在绘画开始时等待联系的进程是<strong>服务器</strong>。</p></blockquote><h3 id="1-2-2-进程与计算机网络之间的接口"><a href="#1-2-2-进程与计算机网络之间的接口" class="headerlink" title="1.2.2 进程与计算机网络之间的接口"></a>1.2.2 进程与计算机网络之间的接口</h3><p>从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为<strong>套接字</strong>（socket）的软件接口向网络发送报文和从网络接收报文。</p><p>类比说明，进程类比为房子，套接字类比为门。一个进程向另一个房子发送报文就要将报文从门送出去，到另一个房子时再从门进去。</p><p><strong>套接字</strong>是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的<strong>应用程序编程接口</strong>（API）。应用程序开发者可以控制套接字在应用端的一切，但是对套接字在运输层端几乎没有控制权（仅限于①选择运输层协议；②也许能设定几个参数，如最大缓存和最大报文长度等）。<br><a href="/img/cn2.3.png">图为应用程序、套接字和下面的运输层协议</a></p><h3 id="1-2-3-进程寻址"><a href="#1-2-3-进程寻址" class="headerlink" title="1.2.3 进程寻址"></a>1.2.3 进程寻址</h3><p>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个<strong>地址</strong>。为了标识该接收进程，需要定义两种信息：<br>——主机的地址；<br>——定义在目的主机中的接收进程的标识符。</p><p>在因特网中，主机由其IP地址标识。除此之外，发送进程还必须指定运行在接收主机上的接收进程（接收套接字）。目的地<strong>端口号</strong>（port number）用于这里，已经给流行的应用分配了特定的端口号。</p><h2 id="1-3-可供应用程序使用的运输服务"><a href="#1-3-可供应用程序使用的运输服务" class="headerlink" title="1.3 可供应用程序使用的运输服务"></a>1.3 可供应用程序使用的运输服务</h2><p>在发送端的应用程序将报文推进给该套接字，在该套接字的另一侧，<strong>运输层协议</strong>负责使该报文进入接收进程的套接字。</p><p>包括因特网在内的很多网络提供了<strong>不止一种</strong>运输层协议。当开发一个应用时，必须要<strong>选择一种</strong>最能为你的应用需求提供恰当服务的协议。一个运输层协议能够为应用程序提供的服务可大体由四个方面进行分类：<strong>可靠数据传输</strong>、<strong>吞吐量</strong>、<strong>定时</strong>和<strong>安全性</strong>。</p><h3 id="1-3-1-可靠数据传输"><a href="#1-3-1-可靠数据传输" class="headerlink" title="1.3.1 可靠数据传输"></a>1.3.1 可靠数据传输</h3><p>如果一个协议提供了确保数据交付的服务，就认为提供了<strong>可靠数据传输</strong>（reliable data transfer）。当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据能无差错地到达接收进程。</p><p>当一个运输层协议不提供可靠数据传输时，由发送进程发送地某些数据可能不能够到达接收进程。这可能被<strong>容忍丢失的应用</strong>（loss-tolerant application）所接受，如一些多媒体应用。</p><h3 id="1-3-2-吞吐量"><a href="#1-3-2-吞吐量" class="headerlink" title="1.3.2 吞吐量"></a>1.3.2 吞吐量</h3><p>在沿着一条网络路径上的两个进程之间的通信会话场景中，<strong>可用吞吐量</strong>就是发送进程能够向接收进程交付比特的速率。因为其他会话将共享沿着该网络路径的带宽，并且因为这些会话将会到达和离开，该可用吞吐量将随时间波动。由此衍生出一种服务，即运输层协议能够以某种特定的速率提供<strong>确保</strong>的可用吞吐量。使用这种服务，应用程序能够请求r比特/秒的确保吞吐量，并且该运输协议能够确保可用吞吐量总是为至少r比特/秒。</p><p>具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong>（bandwidth-sensitive application），例如许多多媒体应用。<strong>弹性应用</strong>（elastic application）能够根据情况或多或少地利用可供使用的吞吐量，例如电子邮件、文件传输等。</p><h3 id="1-3-3-定时"><a href="#1-3-3-定时" class="headerlink" title="1.3.3 定时"></a>1.3.3 定时</h3><p>运输层协议也能够提供<strong>定时保证</strong>。如同具有吞吐量保证那样，定时保证能够以多种形式实现，咯如，发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。</p><p>这种服务对<strong>交互式实时应用程序</strong>有很大吸引力。对于非实时的应用，较低的时延总比较高的时延好，但对端到端的时延没有严格的约束。</p><h3 id="1-3-4-安全性"><a href="#1-3-4-安全性" class="headerlink" title="1.3.4 安全性"></a>1.3.4 安全性</h3><p>运输层协议能够为应用程序提供一种或多种<strong>安全性服务</strong>。这种服务将在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。<br>例如，在<strong>发送主机</strong>中，运输协议能够<strong>加密</strong>由发送进程传输的所有数据；<br>在<strong>接受主机</strong>中，运输层协议能够在将数据交付给接收进程之前<strong>解密</strong>这些数据。</p><p>此外，运输协议还能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别。</p><h2 id="1-4-因特网提供的运输服务"><a href="#1-4-因特网提供的运输服务" class="headerlink" title="1.4 因特网提供的运输服务"></a>1.4 因特网提供的运输服务</h2><p>因特网（更一般的是TCP/IP网络）为应用程序提供两个运输层协议，即<strong>UDP</strong>和<strong>TCP</strong>。软件开发者为因特网创建新的应用时，首先要选择<strong>UDP</strong>或者<strong>TCP</strong>。每个协议为调用它们的应用程序提供了不同的服务集合。</p><h3 id="1-4-1-TCP服务"><a href="#1-4-1-TCP服务" class="headerlink" title="1.4.1 TCP服务"></a>1.4.1 TCP服务</h3><p>TCP服务模型包括面向连接服务和可靠数据传输服务。</p><p>1 <strong>面向连接的服务</strong><br>在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的<strong>握手</strong>过程提示客户和服务器，使它们为大量分组的到来做好准备。</p><p>在握手阶段后。一个<strong>TCP连接</strong>（TCP connection）就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。</p><p>当应用程序结束报文发送时，必须拆除该连接。</p><p>2 <strong>可靠的数据传送服务</strong><br>通信进程能够依靠TCP，<strong>无差错、按适当顺序</strong>交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而<strong>没有字节的冗余和丢失</strong>。</p><p>除此之外，TCP协议还具有<strong>拥塞控制机制</strong>。当发送方和接收方之间的网络出现拥塞时，它会抑制发送进程（客户或服务器）。这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。TCP拥塞控制也试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。</p><h3 id="1-4-2-UDP服务"><a href="#1-4-2-UDP服务" class="headerlink" title="1.4.2 UDP服务"></a>1.4.2 UDP服务</h3><p>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无线连接的，因此在两个进程通信前没有握手过程。UDP服务提供一种不可靠数据传送服务，并且没有拥塞控制机制。</p><h3 id="1-4-3-因特网运输协议所不提供的服务"><a href="#1-4-3-因特网运输协议所不提供的服务" class="headerlink" title="1.4.3 因特网运输协议所不提供的服务"></a>1.4.3 因特网运输协议所不提供的服务</h3><p>TCP提供了可靠的端到端数据传送，在应用层也可以很容易地用SSL来加强以提供安全服务。今天的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证。</p><h2 id="1-5-应用层协议"><a href="#1-5-应用层协议" class="headerlink" title="1.5 应用层协议"></a>1.5 应用层协议</h2><p><strong>应用层协议</strong>（application-layer protrol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p><blockquote><p>特别是应用层协议定义了：<br>1 交换的报文<strong>类型</strong>，例如请求报文和响应报文<br>2 各种报文类型的<strong>语法</strong>，如报文中的各个字段及这些字段是如何描述的。<br>3 字段的<strong>语义</strong>，即这些字段中包含的信息的含义。<br>4 一个进程何时以及如何发送报文，对报文进行相应的<strong>规则</strong>。</p></blockquote><p>有些应用层协议是由RFC文档定义的，因此它们位于<strong>公共域</strong>中，例如HTTP。还有很多应用层协议是<strong>专用</strong>的，有意不为公共域使用。</p><p>应用层协议是网络应用的<strong>一部分</strong>。</p><h1 id="二、Web和HTTP"><a href="#二、Web和HTTP" class="headerlink" title="二、Web和HTTP"></a>二、Web和HTTP</h1><p>在20世纪90年代初期，一个主要的新型应用即<strong>万维网</strong>（World Wide Web）登上舞台，它极大地改变了人们与工作环境内外交流的方式。对大多数用户而言，Web最具吸引力的是它的<strong>按需操作</strong>，即用户能看到想看的内容。</p><h2 id="2-1-HTTP概况"><a href="#2-1-HTTP概况" class="headerlink" title="2.1 HTTP概况"></a>2.1 HTTP概况</h2><p> Web的应用层协议是<strong>超文本运输协议</strong>（HTTP),它是Web的核心。HTTP由两个程序实现：一个客户和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p><p><strong>Web页面</strong>（也叫文档）是由<strong>对象</strong>组成的。一个<strong>对象</strong>（object）只是一个文件，诸如一个HTML文件、一个JPEG图形、一个Java小程序或一个视频片段这样的文件，且它们可通过一个URL地址寻址。每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。</p><blockquote><p>例如，URL地址<a href="http://www.someschool.edu/someDepartment/picture.gif%E4%B8%ADwww.someSchool.edu%E5%B0%B1%E6%98%AF%E4%B8%BB%E6%9C%BA%E5%90%8D%EF%BC%8C/someDepartment/picture.gif%E5%B0%B1%E6%98%AF%E8%B7%AF%E5%BE%84%E5%90%8D%E3%80%82">http://www.someSchool.edu/someDepartment/picture.gif中www.someSchool.edu就是主机名，/someDepartment/picture.gif就是路径名。</a></p></blockquote><p>Web<strong>浏览器</strong>实现了HTTP的客户端，所以被称为浏览器或客户；<br>Web<strong>服务器</strong>实现了HTTP的服务器端，它用于存储Web对象，每个对象由URL寻址。</p><p>HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。当用户请求一个Web页面时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。<br><a href="/img/cn2.4.png">图为HTTP的请求-响应行为</a></p><p>HTTP使用<strong>TCP</strong>作为它的支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制。</p><p>HTTP是一个<strong>无状态协议</strong>（stateless protrol），即不保存关于客户的任何信息。Web是一个<strong>客户-服务器体系结构</strong>。</p><h2 id="2-2-非持续连接和持续连接"><a href="#2-2-非持续连接和持续连接" class="headerlink" title="2.2 非持续连接和持续连接"></a>2.2 非持续连接和持续连接</h2><p>在许多因特网应用程序中，客户发出一系列请求并且服务器对每个请求进行响应。<strong>非持续连接</strong>是指每个请求/响应经一个单独的TCP发送，<strong>持续连接</strong>指所有的请求/响应经相同的TCP发送。</p><p>以<strong>HTTP</strong>举例研究持续连接和非持续连接的<strong>优缺点</strong>。</p><h3 id="2-2-1-采用非持续连接的HTTP"><a href="#2-2-1-采用非持续连接的HTTP" class="headerlink" title="2.2.1 采用非持续连接的HTTP"></a>2.2.1 采用非持续连接的HTTP</h3><p>在<strong>非持续连接</strong>的情况下，从服务器向客户传送一个Web页面的<strong>步骤</strong>，假设该页面含有一个HTML基本页面和10个JPEG图形，并且这11个对象位于同一台服务器上。该HTML文件的URL为：</p><blockquote><p><a href="http://www.someschool.edu/someDepartment/home.index">http://www.someSchool.edu/someDepartment/home.index</a></p></blockquote><ol><li>HTTP<strong>客户进程</strong>在端口号80发起一个到服务器<a href="http://www.someschool.edu的tcp连接,该端口号是http的默认端口./">www.someSchool.edu的TCP连接，该端口号是HTTP的默认端口。</a></li><li>HTTP<strong>客户</strong>经它的<strong>套接字</strong>向该服务器发送一个HTTP请求报文。请求报文中包含了<strong>路径名</strong>/someDepartment/home.index</li><li>HTTP<strong>服务器进程</strong>经它的<strong>套接字</strong>向该服务器发送一个HTTP请求报文。从其<strong>存储器</strong>（RAM或磁盘）中检索出对象<a href="http://www.someschool.edu/someDepartment/home.index%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AAHTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E4%B8%AD**%E5%B0%81%E8%A3%85**%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87%E5%85%B6%E5%A5%97%E6%8E%A5%E5%AD%97%E5%90%91%E5%AE%A2%E6%88%B7%E5%8F%91%E9%80%81**%E5%93%8D%E5%BA%94**%E6%8A%A5%E6%96%87%E3%80%82">www.someSchool.edu/someDepartment/home.index，在一个HTTP响应报文中**封装**对象，并通过其套接字向客户发送**响应**报文。</a></li><li>HTTP<strong>服务器进程</strong>通知TCP断开该TCP连接。</li><li>HTTP<strong>客户</strong>接收响应报文，TCP连接关闭。该报文指出封装的对象是一个HTML文件，客户从响应报文中提取出该文件，检查该HTML文件，得到对10个JPEG图形的<strong>引用</strong>。</li><li>对每个引用的JPEG图形对象<strong>重复</strong>前4个步骤。</li></ol><p>其中每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。每个TCP连接只传输一个请求报文和一个响应报文，因此在本例中要产生11个TCP连接。</p><p>其中这10个JPEG图形对象是使用10个串行的TCP连接，还是某些JPEG对象使用了一些并行的TCP连接，这可以由用户通过配置浏览器进行控制。</p><p><strong>往返时间</strong>（RTT）是指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p><p>当浏览器和Web服务器之间发起一个TCP连接时，会涉及一次”<strong>三次握手</strong>“过程：</p><ol><li>客户向服务器发送一个小TCP报文段</li><li>服务器用一个小TCP报文段做出确认和响应</li><li>客户向服务器返回确认</li></ol><p>三次握手中前两个部分占用了一个RTT。完成前两个部分后，客户结合三次握手的第三部分向该TCP连接发送一个HTTP请求报文，一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。该HTTP请求/响应占用了一个RTT。因此，总的响应时间就是<strong>两个RTT加上服务器传输HTML文件的时间</strong>。<br><a href="/img/cn2.5.png">图为三次握手过程</a></p><h3 id="2-2-2-采用持续连接的HTTP"><a href="#2-2-2-采用持续连接的HTTP" class="headerlink" title="2.2.2 采用持续连接的HTTP"></a>2.2.2 采用持续连接的HTTP</h3><p>非持续连接有两个缺点：</p><ol><li>必须为每一个请求的对象建立和维护一个全新的TCP连接。对于每个连接，客户和服务器都要分配TCP的缓冲区和保持TCP变量。</li><li>每一个对象要经受两倍RTT的交付时延。</li></ol><p> 在采用持续连接时，服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。一般来说，如果一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，HTTP服务器就关闭该连接。</p><h2 id="2-3-HTTP报文格式"><a href="#2-3-HTTP报文格式" class="headerlink" title="2.3 HTTP报文格式"></a>2.3 HTTP报文格式</h2><p>HTTP规范包含了对HTTP报文格式的定义。HTTP报文有两种：请求报文和响应报文。</p><h3 id="2-3-1-HTTP请求报文"><a href="#2-3-1-HTTP请求报文" class="headerlink" title="2.3.1 HTTP请求报文"></a>2.3.1 HTTP请求报文</h3><blockquote><p>下面提供一个<strong>典型</strong>的HTTP请求报文：<br>GET /somedir/page.html HTTP/1.1<br>Host: <a href="http://www.someschool.edu/">www.someschool.edu</a><br>Connection: close<br>User-agent: Mozilla/5.0<br>Accept-language: fr</p></blockquote><p>HTTP请求报文的第一行叫做<strong>请求行</strong>（request line），其后继的行叫做<strong>首部行</strong>（header line）。</p><p>1 <strong>请求行</strong><br>有3个字段：<strong>方法字段</strong>、<strong>URL字段</strong>和<strong>HTTP版本字段</strong>。方法字段可以取几种不同的值，包括GET、POST、HEAD、PUT和DELETE，绝大部分采用GET方法。</p><p>2 <strong>首部行</strong><br><strong>Host: <a href="http://www.someschool.edu/">www.someschool.edu</a></strong>，指明了对象所在的主机。<br><strong>Connection: close</strong>，浏览器告诉服务器不使用持续连接。<br><strong>User-agent</strong>，用来指明用户代理，即向服务器发送请求的浏览器的类型。<br><strong>Accept-language</strong>，表示用户想得到该对象的法语版本（如果服务器中有），否则发送默认版本。</p><p>在首部行后有一个“<strong>实体体</strong>”（entire body）。使用GET方法时实体体为空，在使用<strong>POST方法</strong>时使用。例如当用户在搜索引擎搜索关键词时，实体体包含的就是用户在表单字段的输入值。</p><p><a href="/img/cn2.6.png">图为一个HTTP请求报文的通用格式</a></p><p>用表单生成的请求报文不是必须使用<strong>POST方法</strong>，HTML表单经常使用GET方法，并在所请求的URL中包括输入的数据。例如<a href="http://www.somesite.com/animalsearch?monkeys&amp;bananas%E3%80%82">www.somesite.com/animalsearch?monkeys&amp;bananas。</a></p><p><strong>HEAD方法</strong>类似于GET方法，当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但不返回对象。应用程序开发者经常使用HEAD方法进行调试跟踪。</p><p><strong>PUT方法</strong>常与Web发行工具联合使用，它允许用户上传对象到指定的Web服务器上指定的路径（目录）。同时，它也被那些需要向Web服务器上传对象的应用程序使用。</p><p><strong>DELETE方法</strong>允许用户或者应用程序删除Web服务器上的对象。</p><h3 id="2-3-2-HTTP响应报文"><a href="#2-3-2-HTTP响应报文" class="headerlink" title="2.3.2 HTTP响应报文"></a>2.3.2 HTTP响应报文</h3><blockquote><p>下面提供一条典型的HTTP响应报文，它是对上面请求报文的响应<br>HTTP:/1.1 200 OK<br>Connection: close<br>Data: Tue, 09 Aug 2011 15:44:04 GMT<br>Server: Apache/2.2.3 (CentOS)<br>Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT<br>Content-Length: 6821<br>Content-Type: text/html<br>(空行）<br>(data data data data…)</p></blockquote><p>1 <strong>状态行</strong>（第1行）<br>状态行有3个字段：<strong>协议版本字段</strong>、<strong>状态码</strong>和<strong>相应状态信息</strong>。这里指示服务器正在使用HTTP/1.1，并且一切正常。</p><p>2 <strong>首部行</strong>（2~7行）<br><strong>Connection: close</strong> 告诉客户发送完报文后将关闭该TCP连接；<br><strong>Date</strong> 指示服务器产生并发送该响应报文的日期和时间；<br><strong>Server</strong> 指示该报文是由一台Apache Web服务器产生的，类似于请求报文中的User-agent；<br><strong>Last-Modified</strong> 指示了对象创建或者最后修改的日期和时间，它对对象缓存（既可能在本地客户也可能在网络缓存服务器上）非常重要；<br><strong>Content-Length</strong> 指示了被发送对象中的字节数；<br><strong>Content-Type</strong> 指示了实体体中的对象是HTML文本。</p><p>3 <strong>实体体</strong>：报文的主要部分（data data data…）。</p><p><a href="/img/cn2.7.png">图为一个HTTP响应报文的通用格式</a></p><h2 id="2-4-用户与服务器的交互：cookie"><a href="#2-4-用户与服务器的交互：cookie" class="headerlink" title="2.4 用户与服务器的交互：cookie"></a>2.4 用户与服务器的交互：cookie</h2><p>cookie在[RFC 6265]中定义，它允许站点对用户进行跟踪。</p><p>cookie技术有4个组件：</p><ol><li>在HTTP响应报文中的一个cookie首部行；</li><li>在HTTP请求报文中的一个cookie首部行；</li><li>在用户端系统中保留有一个cookie文件，由用户的浏览器进行管理；</li><li>位于Web站点的一个后端数据库。</li></ol><p><a href="/img/cn2.8.png">图为cookie跟踪用户状态</a></p><p>cookie可以用于<strong>标识</strong>一个用户。用户首次访问一个站点时，可能需要提供一个用户标识。在后继会话中，浏览器向服务器传递一个cookie首部，从而向该服务器标识了用户。因此cookie可以在无状态的HTTP之上建立一个用户<strong>会话层</strong>。</p><h2 id="2-5-Web缓存"><a href="#2-5-Web缓存" class="headerlink" title="2.5 Web缓存"></a>2.5 Web缓存</h2><p><strong>Web缓存器</strong>（Web cache）也叫<strong>代理服务器</strong>（proxy server），它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘<strong>存储空间</strong>，并在存储空间中保存最近请求过的对象的<strong>副本</strong>。</p><p>假设浏览器正在请求一个对象，将会发生如下情况：</p><ol><li>浏览器<strong>建立</strong>一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。</li><li>Web缓存器进行<strong>检查</strong>，看看本地是否存储了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象。</li><li>如果Web缓存器中没有该对象，它就打开一个与该对象的<strong>初始服务器</strong>的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应。</li><li>当Web缓存器接收到该对象时，它在本地存储空间存储一份<strong>副本</strong>，并向客户的浏览器用HTTP<strong>响应报文</strong>发送该副本（通过已有的TCP连接）。</li></ol><p>所以Web缓存器是<strong>服务器</strong>同时又是<strong>客户</strong>。它通常由<strong>ISP</strong>购买并安装。</p><p>部署Web缓存器的<strong>原因</strong>：</p><ul><li>它可以大大减少对客户请求的响应时间。</li><li>它能够大大减少一个机构的接入链路到因特网的通信量。</li><li>它从整体上大大减低因特网上的Web流量，从而改善了所有应用的性能。</li></ul><p>通过使用<strong>内容分发网络</strong>（CDN），Web缓存器正在因特网中发挥着越来越重要的作用。CDN公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。</p><h2 id="2-6-条件GET方法"><a href="#2-6-条件GET方法" class="headerlink" title="2.6 条件GET方法"></a>2.6 条件GET方法</h2><p>为了解决存放在缓存器中的对象副本可能已经<strong>陈旧</strong>的问题，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。它就是<strong>条件GET方法</strong>。</p><p>如果</p><ul><li>请求报文使用GET方法</li><li>请求报文中包含一个”if-Modified-Since:”首部行</li></ul><p>那么，这个HTTP请求报文就是一个条件GET请求报文。</p><h1 id="三、文件传输协议：FTP"><a href="#三、文件传输协议：FTP" class="headerlink" title="三、文件传输协议：FTP"></a>三、文件传输协议：FTP</h1><h2 id="3-1-FTP传输的过程"><a href="#3-1-FTP传输的过程" class="headerlink" title="3.1 FTP传输的过程"></a>3.1 FTP传输的过程</h2><p>在一个典型的FTP会话中，用户坐在一台主机前面，向一台远程主机传输文件。为使用户能访问它的远程账户，用户必须提供一个<strong>用户标识和口令</strong>。用户通过一个<strong>FTP用户代理</strong>与<strong>FTP</strong>交互。</p><p>具体步骤如下：</p><ol><li>用户首先提供远程主机的<strong>主机名</strong>，使本地主机的FTP客户进程建立一个到远程主机FTP服务器进程的<strong>TCP连接</strong>。</li><li>用户接着提供<strong>用户标识和口令</strong>，作为FTP命令的一部分在该TCP连接上传送。</li><li>一旦该服务器向该用户<strong>授权</strong>，用户可以将存放在本地文件系统中的一个或多个文件复制到远程文件系统（反之亦然）。</li></ol><h2 id="3-2-HTTP和FTP的对比"><a href="#3-2-HTTP和FTP的对比" class="headerlink" title="3.2 HTTP和FTP的对比"></a>3.2 HTTP和FTP的对比</h2><h3 id="3-2-1-共同点"><a href="#3-2-1-共同点" class="headerlink" title="3.2.1 共同点"></a>3.2.1 共同点</h3><ul><li>都是文件传输协议</li><li>都运行在TCP上</li></ul><h3 id="3-2-2-不同点"><a href="#3-2-2-不同点" class="headerlink" title="3.2.2 不同点"></a>3.2.2 不同点</h3><ul><li>FTP使用了两个并行的TCP连接来传输文件，一个是<strong>控制连接</strong>（control connection），一个是<strong>数据连接</strong>（data connection）。<strong>控制连接</strong>用于在主机之间传输控制信息，如用户标识、口令、文件命令等。<strong>数据连接</strong>用于实际发送一个文件。我们称FTP是<strong>带外连接</strong>（独立的控制连接）的。HTTP是在传输文件的同一个TCP连接中发送请求和响应首部行的。因此，HTTP是<strong>带内连接</strong>的。</li><li>FTP服务器必须在整个会话期间保留用户的<strong>状态</strong>（state）。服务器必须把特定的用户账户与控制连接联系起来，大大限制了FTP同时维持的会话总数。HTTP是<strong>无状态</strong>的，它不必对任何用户状态进行跟踪。</li></ul><p>对FTP而言，<strong>控制连接</strong>贯穿了整个用户会话期间，但是对会话中的每一次文件传输都需要建立一个新的<strong>数据连接</strong>（即数据连接是非持续的）。</p><h2 id="3-3-FTP命令和回答"><a href="#3-3-FTP命令和回答" class="headerlink" title="3.3 FTP命令和回答"></a>3.3 FTP命令和回答</h2><p>详见 RFC959</p><h1 id="四、因特网中的电子邮件"><a href="#四、因特网中的电子邮件" class="headerlink" title="四、因特网中的电子邮件"></a>四、因特网中的电子邮件</h1><h2 id="4-1-因特网电子邮件系统和它的关键组件"><a href="#4-1-因特网电子邮件系统和它的关键组件" class="headerlink" title="4.1 因特网电子邮件系统和它的关键组件"></a>4.1 因特网电子邮件系统和它的关键组件</h2><p>因特网电子邮件系统有3个主要组成部分：<strong>用户代理</strong>（user agent）、<strong>邮件服务器</strong>（mail server）和<strong>简单邮件传输协议</strong>（SMTP）。</p><p>1 <strong>用户代理</strong>允许用户阅读、回复、转发、保存和撰写报文。当发送方完成邮件撰写时，<strong>邮件代理</strong>向其<strong>邮件服务器</strong>发送邮件，此时邮件放在<strong>邮件服务器</strong>的外出报文队列中。</p><p>2 <strong>邮件服务器</strong>形成了电子邮件体系结构的核心。每个接收方在其中的某个<strong>邮件服务器</strong>上有一个<strong>邮箱</strong>（mailbox），<strong>邮箱</strong>管理和维护着发送给用户的报文。当用户要在他的<strong>邮箱</strong>中读取该报文时，包含他邮箱的<strong>邮件服务器</strong>要鉴别用户。</p><p>如果发送方的服务器不能将邮件交付给接收方的服务器，发送方的邮件服务器在一个<strong>报文队列</strong>（message queue）中保持该报文并在以后尝试再次发送。通常每30分钟进行一次尝试，如果几天后仍不能成功，服务器就删除该报文并以电子邮件的形式通知发送方。</p><p>3 <strong>SMTP</strong>是因特网电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。SMTF也有两个部分：运行在发送方邮件服务器的<strong>客户端</strong>和接收方邮件服务器的<strong>服务器端</strong>。</p><h2 id="4-2-SMTP"><a href="#4-2-SMTP" class="headerlink" title="4.2 SMTP"></a>4.2 SMTP</h2><p>SMTP是因特网电子邮件应用的核心，用于从发送方的邮件服务器发送报文到接收方的邮件服务器。</p><p>假设Alice想给Bob发送一封简单的ASCII报文：</p><ol><li>Alice调用她的<strong>邮件代理</strong>程序并提供Bob的邮件地址，撰写报文，然后指示<strong>用户代理</strong>发送该报文。</li><li>Alice的<strong>用户代理</strong>把报文发给他的<strong>邮件服务器</strong>，在那里该报文被放在<strong>报文队列</strong>中。</li><li>运行在Alice的<strong>邮件服务器</strong>上的<strong>SMTP客户端</strong>发现了<strong>报文队列</strong>中的这个报文，它就创建一个到运行在Bob的邮件服务器上的<strong>SMTP服务器</strong>的<strong>TCP连接</strong>。</li><li>在经过一些初始SMTF握手后，SMTP客户通过该<strong>TCP连接</strong>发送Alice的报文。</li><li>在Bob的<strong>邮件服务器</strong>上，SMTP的服务器端接收该报文。Bob的<strong>邮件服务器</strong>将该报文放入Bob的<strong>邮箱</strong>中。</li><li>在Bob方便的时候，他调用<strong>用户代理</strong>阅读该报文。</li></ol><p>SMTP一般不使用中间服务器发送邮件。而且它用的是持续连接，通过同一个TCP连接发送所有报文。</p><h2 id="4-3-HTTP和SMTP的对比"><a href="#4-3-HTTP和SMTP的对比" class="headerlink" title="4.3 HTTP和SMTP的对比"></a>4.3 HTTP和SMTP的对比</h2><h3 id="4-3-1-共同点"><a href="#4-3-1-共同点" class="headerlink" title="4.3.1 共同点"></a>4.3.1 共同点</h3><ul><li>都用于从一台主机向另一台主机传送文件。</li><li>进行文件发送时，二者都使用<strong>持续连接</strong>。</li></ul><h3 id="4-3-2-不同点"><a href="#4-3-2-不同点" class="headerlink" title="4.3.2 不同点"></a>4.3.2 不同点</h3><p><strong>一、</strong></p><ul><li>HTTP主要是一个<strong>拉协议</strong>（pull protocol），即在方便的时候，用户使用HTTP从服务器拉取这些信息。TCP由想接收文件的机器发起的。</li><li>SMTP基本是一个<strong>推协议</strong>（push protocol），即发送邮件服务器把文件推向接收邮件服务器。TCP由要发送该文件的机器发起。</li></ul><p><strong>二、</strong></p><ul><li>SMTP要求每个报文使用<strong>7比特ASCII码</strong>格式。如果文件包含非7比特ASCII字符，则必须要按照7比特ASCII码进行编码。</li><li>HTTP没有格式限制。</li></ul><p><strong>三、</strong></p><ul><li>在处理一个既包含文本又包含图形（或其他）的文档时，HTTP把每个对象<strong>封装</strong>到响应报文中。</li><li>SMTP把所有报文对象放在一个报文之中。</li></ul><h2 id="4-4-邮件报文格式和MIME"><a href="#4-4-邮件报文格式和MIME" class="headerlink" title="4.4 邮件报文格式和MIME"></a>4.4 邮件报文格式和MIME</h2><p>当发送电子邮件时，一个包含<strong>环境信息</strong>的首部位于报文体前面。这些<strong>环境信息</strong>包括在一系列<strong>首部行</strong>中，这些行由RFC 5322定义。注意这里的首部行不同于SMTP命令，SMTP命令是握手协议的一部分。</p><blockquote><p>一个典型的报文首部如下：<br>From: <a href="mailto:&#97;&#x6c;&#105;&#x63;&#101;&#64;&#x63;&#x72;&#x65;&#x70;&#101;&#115;&#46;&#x66;&#114;">&#97;&#x6c;&#105;&#x63;&#101;&#64;&#x63;&#x72;&#x65;&#x70;&#101;&#115;&#46;&#x66;&#114;</a><br>To: <a href="mailto:&#98;&#x6f;&#x62;&#x40;&#104;&#x61;&#109;&#98;&#117;&#x72;&#103;&#101;&#114;&#46;&#101;&#100;&#117;">&#98;&#x6f;&#x62;&#x40;&#104;&#x61;&#109;&#98;&#117;&#x72;&#103;&#101;&#114;&#46;&#101;&#100;&#117;</a><br>Subject: Searching for the meaning of life</p></blockquote><h2 id="4-5-邮件访问协议"><a href="#4-5-邮件访问协议" class="headerlink" title="4.5 邮件访问协议"></a>4.5 邮件访问协议</h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++基础语法</title>
    <link href="/2022/03/23/Cpp2/"/>
    <url>/2022/03/23/Cpp2/</url>
    
    <content type="html"><![CDATA[<h1 id="C-基础语法"><a href="#C-基础语法" class="headerlink" title="C++基础语法"></a>C++基础语法</h1><h2 id="1、输入输出"><a href="#1、输入输出" class="headerlink" title="1、输入输出"></a>1、输入输出</h2><h3 id="1-1-使用cout进行输出"><a href="#1-1-使用cout进行输出" class="headerlink" title="1.1 使用cout进行输出"></a>1.1 使用cout进行输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;Come up and C++ me some time.&quot;</span>；<br></code></pre></td></tr></table></figure><p>双括号引起的部分是要打印的字符串，&lt;&lt;符号表示该语句把整个字符串发送给cout，它将一个字符串插入到了输出流中。<br>cout在头文件iostream中定义。</p><h3 id="1-2-控制符endl"><a href="#1-2-控制符endl" class="headerlink" title="1.2 控制符endl"></a>1.2 控制符endl</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>endl表示重起一行，在输出流中插入endl将导致光标移到下一行开头。<br>endl在头文件iostream中定义。</p><h3 id="1-3-换行符"><a href="#1-3-换行符" class="headerlink" title="1.3 换行符"></a>1.3 换行符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;Pluto is a dwarf planet.\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Pluto is a dwarf planet.&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>endl确保程序继续运行前刷新输出（将其立即显示在屏幕上），使用\n在某些系统中可能在输入信息后才能出现提示。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python的一些常用函数</title>
    <link href="/2022/03/23/python1/"/>
    <url>/2022/03/23/python1/</url>
    
    <content type="html"><![CDATA[<h1 id="python的一些常用函数"><a href="#python的一些常用函数" class="headerlink" title="python的一些常用函数"></a>python的一些常用函数</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>因为最近在准备蓝桥杯python组的比赛，特罗列总结出python的一些常用函数。后续随着使用也会陆续整理。</p><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="1-数学函数"><a href="#1-数学函数" class="headerlink" title="1 数学函数"></a>1 数学函数</h3><p>1.1 abs()：取绝对值</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>(-<span class="hljs-number">10</span>))  <span class="hljs-comment">##10</span><br></code></pre></td></tr></table></figure><p>1.2 divmod()：同时取商和余数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">divmod</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment">##(3, 1)</span><br></code></pre></td></tr></table></figure><p>1.3 sum()：求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment">##6</span><br></code></pre></td></tr></table></figure><p>1.4 round()：四舍五入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">5.1</span>))  <span class="hljs-comment">##5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">5.5</span>))  <span class="hljs-comment">##6</span><br></code></pre></td></tr></table></figure><p>1.5 pow(m, n)：计算m的n次方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment">##8</span><br></code></pre></td></tr></table></figure><p>1.6 min()/max()：最小(大)值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">min</span>(<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment">##2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment">##9</span><br></code></pre></td></tr></table></figure><h3 id="2-数据转换函数"><a href="#2-数据转换函数" class="headerlink" title="2 数据转换函数"></a>2 数据转换函数</h3><p>2.1 hex()：十进制转换成十六进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-number">100</span>))  <span class="hljs-comment">##0x64</span><br></code></pre></td></tr></table></figure><p>2.2 oct()：十进制转换成八进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">oct</span>(<span class="hljs-number">100</span>))  <span class="hljs-comment">##0o144</span><br></code></pre></td></tr></table></figure><p>2.3 bin()：十进制转换成二进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-number">100</span>))  <span class="hljs-comment">##0b1100100</span><br></code></pre></td></tr></table></figure><p>2.4 bool()：将指定参数类型转换成布尔类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>))  <span class="hljs-comment">##True</span><br></code></pre></td></tr></table></figure><p>2.5 ord()：获取单个字符的ASCII数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;A&quot;</span>))  <span class="hljs-comment">##65</span><br></code></pre></td></tr></table></figure><p>2.6 float()：转换成浮点数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(<span class="hljs-number">10</span>))  <span class="hljs-comment">##10.0</span><br></code></pre></td></tr></table></figure><p>2.7 chr() ：转换一个整数并返回所对应的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(<span class="hljs-number">65</span>))  <span class="hljs-comment">##A</span><br></code></pre></td></tr></table></figure><p>2.8 list()： 将可迭代对象转换为列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)))  <span class="hljs-comment">##[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><h3 id="3-对象创建函数"><a href="#3-对象创建函数" class="headerlink" title="3 对象创建函数"></a>3 对象创建函数</h3><h3 id="4-迭代器操作函数"><a href="#4-迭代器操作函数" class="headerlink" title="4 迭代器操作函数"></a>4 迭代器操作函数</h3><h2 id="基本常用函数"><a href="#基本常用函数" class="headerlink" title="基本常用函数"></a>基本常用函数</h2><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="1-最基本的文件操作"><a href="#1-最基本的文件操作" class="headerlink" title="1 最基本的文件操作"></a>1 最基本的文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;E:\hello.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>res = []<br>s = fp.readlines()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>    res.append(i.strip(<span class="hljs-string">&#x27;\n&#x27;</span>)) <span class="hljs-comment">#使用strip()去掉换行符，如果不去的话会把‘\n’也读进来</span><br>fp.close() <span class="hljs-comment">#记得要关闭连接，养成良好习惯</span><br><br><span class="hljs-built_in">print</span>(res[:])<br></code></pre></td></tr></table></figure><h3 id="2-字符串操作"><a href="#2-字符串操作" class="headerlink" title="2 字符串操作"></a>2 字符串操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">fp =  <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;E:\hello.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>res = [s.strip(<span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> fp.readlines()]<br>fp.close()<br><span class="hljs-built_in">print</span>(res[:])<br></code></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="1-datetime模块"><a href="#1-datetime模块" class="headerlink" title="1 datetime模块"></a>1 datetime模块</h3><p>1.1 日期对象——date类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetimee<br><br>d = datetime.date(<span class="hljs-number">2019</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)<span class="hljs-comment"># 年，月，日</span><br><span class="hljs-built_in">print</span>(d)  <span class="hljs-comment">## 2019-01-11</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br>a1 = datetime.date(<span class="hljs-number">2019</span>,<span class="hljs-number">8</span>,<span class="hljs-number">26</span>)<br><span class="hljs-built_in">print</span>(a1.isocalendar())<br><span class="hljs-built_in">print</span>(a1.isoformat())<br><span class="hljs-built_in">print</span>(a1.isoweekday())<br><span class="hljs-built_in">print</span>(a1.weekday())<br><span class="hljs-built_in">print</span>(a1.replace(<span class="hljs-number">2018</span>,<span class="hljs-number">4</span>,<span class="hljs-number">30</span>))<br><span class="hljs-comment">#(2019, 35, 1)</span><br><span class="hljs-comment">#2019-08-26</span><br><span class="hljs-comment">#1</span><br><span class="hljs-comment">#0</span><br><span class="hljs-comment">#2018-04-30</span><br></code></pre></td></tr></table></figure><p>1.2 时间对象——time类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br>t = datetime.time(<span class="hljs-number">20</span>, <span class="hljs-number">36</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>)<span class="hljs-comment"># 时，分，秒，毫秒</span><br><span class="hljs-built_in">print</span>(t)  <span class="hljs-comment">## 20：36：15.000001</span><br></code></pre></td></tr></table></figure><p>1.3 日期时间对象——datetime类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>now = datetime.now()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前日期时间是：&#x27;</span>,now)  <span class="hljs-comment">## 2022-03-27 13:45:53.536404</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前日期是：&#x27;</span>,now.date())  <span class="hljs-comment">## 2022-03-27</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前时间是：&#x27;</span>,now.time())  <span class="hljs-comment">## 13:45:53.536404</span><br>```e<br>日期时间转化为时间戳<br>```python<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-built_in">print</span>(datetime.now().timestamp())  <span class="hljs-comment">##1627700208.446621</span><br></code></pre></td></tr></table></figure><p>时间戳转化为日期时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-built_in">print</span>(datetime.fromtimestamp(<span class="hljs-number">1627700208.446621</span>))  <span class="hljs-comment">## 2022-03-27 13:45:53.536404</span><br></code></pre></td></tr></table></figure><p>日期时间对象转字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-built_in">print</span>(datetime.now().strftime(<span class="hljs-string">&quot;%Y+%m+%d&quot;</span>))  <span class="hljs-comment">## 2022+03+27</span><br></code></pre></td></tr></table></figure><p>字符串转日期时间对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>a = datetime.strptime(<span class="hljs-string">&#x27;2022-5-22  15:23:38&#x27;</span>, <span class="hljs-string">&#x27;%Y-%m-%d  %H:%M:%S&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))  <span class="hljs-comment">## &lt;class &#x27;datatime.datatime&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment">## 2022-5-22  15:23:38</span><br></code></pre></td></tr></table></figure><p>1.4 时间间隔对象——timedelta类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br>now = datetime.datetime.now()<br>a = datetime.timedelta(hours=<span class="hljs-number">8</span>,minutes=<span class="hljs-number">20</span>,seconds=<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))  <span class="hljs-comment">## &lt;class &#x27;datatime.timedelta&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(now - a)  <span class="hljs-comment">## 2021-07-31 02:58:29.424161</span><br><span class="hljs-built_in">print</span>(now + a)  <span class="hljs-comment">## 2021-07-31 19:38:49.424161</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++的一些特点</title>
    <link href="/2022/03/22/Cpp1/"/>
    <url>/2022/03/22/Cpp1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-的一些特点"><a href="#C-的一些特点" class="headerlink" title="C++的一些特点"></a>C++的一些特点</h1><h2 id="1-main-函数"><a href="#1-main-函数" class="headerlink" title="1 main()函数"></a>1 main()函数</h2><p><strong>1.1</strong> 主函数必须是int main()或int main(void)<br><em>原因</em>：运行cpp程序时，通常从main()函数开始执行。因此，如果没有main()，程序将不完整，编译器将指出未定义main()函数。</p><p><strong>1.2</strong> main()最后可以不返回0<br><em>原因</em>：ANSI/ISO C++标准为，如果编译器到达main()函数末尾时没有遇到返回语句，则认为main()函数以return 0结尾。</p><h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2 注释"></a>2 注释</h2><p><strong>2.1</strong> 注释以“//”打头，到行尾结束<br><strong>2.2</strong> 注释可以位于单独一行，也可和代码位于同一行</p><h2 id="3-预处理器和头文件名"><a href="#3-预处理器和头文件名" class="headerlink" title="3 预处理器和头文件名"></a>3 预处理器和头文件名</h2><p><strong>3.1</strong> 如果程序要使用某些工具，要在前几行标明#include…<br><em>原因</em>：C++和C一样，使用一个预处理器，在主编译之前对源文件进行处理，例如在源代码被编译之前，替换或添加文本。</p><p><strong>3.2</strong> 头文件名没有扩展名</p><h2 id="4-名称空间"><a href="#4-名称空间" class="headerlink" title="4 名称空间"></a>4 名称空间</h2><p><strong>4.1</strong> using namespace std;<br>原因：有助于组织程序，在调用同名函数时可以指定哪个名称空间的函数,如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">Microflop::<span class="hljs-built_in">wanda</span>(<span class="hljs-string">&quot;go dancing?&quot;</span>);<br>Piscine::<span class="hljs-built_in">wanda</span>(<span class="hljs-string">&quot;a fish named Desire&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果省略了这条语句，那么就要使用如下语句编码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;Come up and C++ me some time.&quot;</span>;<br>std::cout &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>更好的办法是，只是通过using声明使所需名称可用，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::cin;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01：计算机网络和因特网</title>
    <link href="/2022/03/21/Cn1/"/>
    <url>/2022/03/21/Cn1/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote><p><em><strong>纸上得来终觉浅，绝知此事要躬行。</strong></em></p></blockquote><div class="code-wrapper"><pre><code class="hljs">在本专栏中，我们将使用*公共因特网*（一种特定的计算机网络）作为讨论计算机网络机器协议的主要载体。</code></pre></div><h1 id="一、因特网：网络的网络"><a href="#一、因特网：网络的网络" class="headerlink" title="一、因特网：网络的网络"></a>一、因特网：网络的网络</h1><blockquote><p>何为因特网？可以有两种解释：<br> ——构成因特网的基本硬件和软件组件<br>  ——为分布式应用提供服务的联网基础设施</p></blockquote><p>下面我们分别以这两方面作为切入点，剖析因特网</p><h2 id="1-1-具体构成描述"><a href="#1-1-具体构成描述" class="headerlink" title="1.1 具体构成描述"></a>1.1 具体构成描述</h2><h3 id="1-1-1-端系统、通信链路、分组交换机、分组简介"><a href="#1-1-1-端系统、通信链路、分组交换机、分组简介" class="headerlink" title="1.1.1 端系统、通信链路、分组交换机、分组简介"></a>1.1.1 端系统、通信链路、分组交换机、分组简介</h3><p>用因特网术语来说，所有与它相联系的设备统称为<strong>主机</strong>（host）或<strong>端系统</strong>（end system）。</p><blockquote><p>端系统通过<strong>通信链路</strong>（communication link）和<strong>分组交换机</strong>（packet switch）连接到一起。</p></blockquote><p><em>通信链路</em>。它们由不同类型的物理媒体（同轴电缆、铜线、光纤和无线电频谱）组成。不同的链路有不同的传输速率（以bit/s或bps度量）。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包我们将其称为<strong>分组</strong>（packet）。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。</p><p><em>分组交换机</em>。分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。在当今的因特网中，两种最著名的类型是<strong>路由器</strong>（router）和<strong>链路层交换机</strong>（link-layer switch）。</p><blockquote><p><strong>路由器</strong>通常用于网络核心中<br><strong>链路层交换机</strong>通常用于接入网中</p></blockquote><p>从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径</strong>（route或path）。</p><p>用于传送分组的分组交换网络在许多方面类似于承载运输车辆的运输网络，该网络包括了高速公路、公路和立交桥。当工厂需要将大量货物搬运至远方的仓库时，工厂就要将货物分开装上卡车车队，通过高速公路、公路和立交桥将货物搬运至仓库。在这一过程中，各个环节扮演的角色如下表所示：</p><table><thead><tr><th>角色</th><th>环节</th></tr></thead><tbody><tr><td>分组</td><td>卡车</td></tr><tr><td>通信链路</td><td>高速公路、公路</td></tr><tr><td>分组交换机</td><td>立交桥</td></tr><tr><td>端系统</td><td>工厂、仓库</td></tr></tbody></table><h3 id="1-1-2-ISP简介"><a href="#1-1-2-ISP简介" class="headerlink" title="1.1.2 ISP简介"></a>1.1.2 ISP简介</h3><p>端系统通过<strong>因特网服务提供商</strong>（ISP）接入因特网。每个ISP是一个由多个分组交换机和多段通信链路组成的网络。各ISP为端系统提供各种不同类型的网络接入（线缆调制解调器或如DSL的住宅宽带接入、高速局域网接入、无线接入和56kbps拨号调制解调器接入）。</p><p>因特网将端系统彼此互联，因此ISP也必须互联。</p><blockquote><p><strong>低层ISP</strong>通过国家、国际的高层ISP（Level 3 Communications、AT&amp;T、Sprint和NTT）互联；<br><strong>高层ISP</strong>是由通过高速光纤链路互联的高速路由器组成的</p></blockquote><h3 id="1-1-3-协议简介"><a href="#1-1-3-协议简介" class="headerlink" title="1.1.3 协议简介"></a>1.1.3 协议简介</h3><p>端系统、分组交换机和其他因特网部件都要运行一系列协议（protocol），这些协议控制因特网中信息的接收和发送。<strong>传输控制协议</strong>（TCP）和<strong>网络协议</strong>（IP）是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为TCP/IP。</p><p>鉴于因特网协议的重要性，每个人就各个协议及其作用取得一致认识很重要，这样人们就能创造协同工作的系统和产品。自然而然，我们引入了因特网<strong>标准</strong>（Internet standard），它由因特网工程任务组（IETF）研发。IETF的标准文档称为<strong>请求评论</strong>（RFC），它们定义了TCP、IP、HTTP（用于Web）和SMTP（用于电子邮件）等协议。当然，其他组织也在制定用于网络组件的标准。</p><h2 id="1-2-服务描述"><a href="#1-2-服务描述" class="headerlink" title="1.2 服务描述"></a>1.2 服务描述</h2><blockquote><p>何为因特网？可以有两种解释：<br> ——构成因特网的基本硬件和软件组件<br>  ——为分布式应用提供服务的联网基础设施</p></blockquote><p>上文以前者作为切入点，现在我们从<em>应用程序提供服务的基础设施</em>的角度来描述因特网。</p><p>我们平时接触到的大部分应用程序，例如电子邮件、Web冲浪、即时讯息等等，它们称为<strong>分布式应用程序</strong>（distributed application），因为它们涉及多台相互交换数据的端系统。</p><p>与因特网相连的端系统提供了一个<strong>应用程序编程接口</strong>（API）。API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。</p><p>举个例子，Alice要向Bob寄一封信，Alice不能写完信后就将信丢出窗外，邮政服务要求Alice将信放入 信封并贴上邮票，还要投进邮箱中。对应到因特网中，就有如下类比：</p><table><thead><tr><th>角色</th><th>环节</th></tr></thead><tbody><tr><td>软件A</td><td>Alice</td></tr><tr><td>软件B</td><td>Bob</td></tr><tr><td>API</td><td>邮政服务规定</td></tr></tbody></table><h2 id="1-3-什么是协议"><a href="#1-3-什么是协议" class="headerlink" title="1.3 什么是协议"></a>1.3 什么是协议</h2><h3 id="1-3-1-人类活动类比"><a href="#1-3-1-人类活动类比" class="headerlink" title="1.3.1 人类活动类比"></a>1.3.1 人类活动类比</h3><blockquote><p>我们用一张图生动形象的表达协议的含义</p></blockquote><p><a href="https://img-blog.csdnimg.cn/86635908c0e14a5aa3909b7848af7ccb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTI3NTUwNTk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center">图为人类协议和计算机网络协议</a> </p><p>如果人们使用不同的协议（例如，一个人讲礼貌而另一个人不讲礼貌），该协议就不能互动，因而不能完成有用的工作。在网络中这个道理同样成立。即为了完成一项工作，要求两个（或多个）通信实体运行相同协议。</p><h3 id="1-3-2-网络协议"><a href="#1-3-2-网络协议" class="headerlink" title="1.3.2 网络协议"></a>1.3.2 网络协议</h3><blockquote><p>在因特网中，凡是涉及两个或多个远程通信实体的所有活动都受<strong>协议</strong>的制约。</p></blockquote><p>例如，在两台物理上连接的计算机中，硬件实现的协议控制了在两块网络接口卡间的“线上”的比特流；在端系统中，拥塞控制协议控制了在发送方和接收方之间传输的分组发送的速率。</p><p>从上述的人类活动和网络的例子中可见，报文的交换以及发送和接收这些报文时所采取的动作是定义一个协议的关键元素：</p><blockquote><p>一个<strong>协议</strong>定义了在两个或多个通信实体之间交换的<strong>报文格式和次序</strong>，以及报文发送和（或）接收一条报文或其他事件所采取的<strong>动作</strong>。</p></blockquote><h1 id="二、网络边缘"><a href="#二、网络边缘" class="headerlink" title="二、网络边缘"></a>二、网络边缘</h1><p>我们通常把与因特网相连的计算机和其他设备称为端系统，因为它们位于<strong>互联网的边缘</strong>，故而被称为端系统。端系统也称为<strong>主机</strong>，因为它们容纳（即运行）应用程序，如Web浏览器程序、Web服务器程序、电子邮件阅读程序或电子邮件服务器程序等。端系统有时又被进一步划分为两类：<strong>客户</strong>（client）和<strong>服务器</strong>（server）。</p><blockquote><p><strong>客户</strong>相当于是桌面PC、移动PC和智能手机等，<br><strong>服务器</strong>相当于是更为强大的机器，用于存储和发布Web页面、流视频、中继电子邮件等。</p></blockquote><h2 id="2-1-接入网"><a href="#2-1-接入网" class="headerlink" title="2.1 接入网"></a>2.1 接入网</h2><blockquote><p><strong>接入网</strong>是指将端系统连接到其<strong>边缘路由器</strong>的<strong>物理链路</strong></p></blockquote><p>边缘路由器是端系统到任何其他远程端系统的路径上的<strong>第一台路由器</strong>。</p><p><a href="https://img-blog.csdnimg.cn/0adfe3517b9f4caaad181ea94136954e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTI3NTUwNTk=,size_20,color_FFFFFF,t_70,g_se,x_16">图为端系统交互的大致组成部分</a></p><h3 id="2-1-1-家庭接入：DSL、电缆、FTTH、拨号和卫星"><a href="#2-1-1-家庭接入：DSL、电缆、FTTH、拨号和卫星" class="headerlink" title="2.1.1 家庭接入：DSL、电缆、FTTH、拨号和卫星"></a>2.1.1 家庭接入：DSL、电缆、FTTH、拨号和卫星</h3><p>以前，宽带住宅接入有两种类型：<strong>数字用户线</strong>（DSL）和<strong>电缆</strong>。</p><p><a href="https://img-blog.csdnimg.cn/c9e80d89bf684f809beca1e20b49e770.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTI3NTUwNTk=,size_20,color_FFFFFF,t_70,g_se,x_16">图为DSL因特网接入</a></p><p>除了DSL电话接入，还有利用有线电视公司现有有线电视基础设施的电缆因特网接入，这里不再赘述，读者可自行查阅。目前主流的上网方式是<strong>光纤到户</strong>（FTTH），即从本地中心局直接到家庭提供一条光纤路径。</p><p><a href="/img/cn1.4.png">图为FTTH因特网接入</a></p><h3 id="2-1-2-企业（和家庭）接入：以太网和WIFI"><a href="#2-1-2-企业（和家庭）接入：以太网和WIFI" class="headerlink" title="2.1.2 企业（和家庭）接入：以太网和WIFI"></a>2.1.2 企业（和家庭）接入：以太网和WIFI</h3><p>在公司和大学校园以及在越来越多的家庭环境中，通常是用局域网（LAN）将端用户连接到边缘路由器，以太网是目前最为流行的接入技术。使用以太网接入，用户通常以100Mbps速率接入以太网交换机，而服务器可能具有1Gbps甚至10Gbps的接入速率。</p><p><a href="/img/cn1.5.png">图为以太网因特网接入</a></p><p>在无线LAN环境中，无线用户从/到一个接入点发送/接收分组，该接入点与企业网连接，该企业网再与有线因特网相连。基于IEEE 802.11的技术的无线LAN称为WiFi。</p><h2 id="2-2-物理媒体"><a href="#2-2-物理媒体" class="headerlink" title="2.2 物理媒体"></a>2.2 物理媒体</h2><p>物理媒体划分为两类：<strong>导引型媒体</strong>（guided media）和<strong>非导引型媒体</strong>（unguided meidia）。</p><blockquote><p> 导引型媒体，电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。<br> 非导引型媒体，电波在空气或外层空间中传播，如无线局域网或数字卫星频道。</p></blockquote><p>具体物理媒体介绍暂且不更，有兴趣者可自行查阅。</p><h1 id="三、网络核心"><a href="#三、网络核心" class="headerlink" title="三、网络核心"></a>三、网络核心</h1><p><strong>网络核心</strong>指互联因特网端系统的分组交换机和链路构成的网状网络。</p><h2 id="3-1-分组交换"><a href="#3-1-分组交换" class="headerlink" title="3.1 分组交换"></a>3.1 分组交换</h2><p>源端系统向目的端系统发送报文，源将长报文划分为一个个<strong>分组</strong>，每个分组都通过<strong>通信链路</strong>和<strong>分组交换机</strong>传送，分组以等于该链路<strong>最大传输速率</strong>的速度传输通过通信链路。因此，如果某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R比特/秒，则传输该分组的时间为L/R秒。</p><h3 id="3-1-1-存储转发运输"><a href="#3-1-1-存储转发运输" class="headerlink" title="3.1.1 存储转发运输"></a>3.1.1 存储转发运输</h3><blockquote><p><strong>存储转发运输</strong>，是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p></blockquote><p>多数分组交换机在链路的输入端使用<strong>存储转发运输</strong>（store-and-forward transmission）机制。</p><p>为了深刻理解存储转发运输，特举例说明（这里忽略传播时延），</p><blockquote><p>发送一个分组：<br>源在时刻0开始传输；<br>在时刻L/R，路由器接收到整个分组；<br>在时刻2L/R，路由器传输了整个分组，并已被目的地接收。<br>总时延为2L/R。</p></blockquote><blockquote><p>发送三个分组：<br>源在时刻0开始传输；<br>在时刻L/R，路由器开始转发第一个分组，源开始发送第二个分组；<br>在时刻2L/R，目的地收到第一个分组，路由器收到第二个分组；<br>在时刻3L/R，目的地收到前两个分组，路由器收到第三个分组；<br>在时刻4L/R，目的地接收全部分组。<br>总时延为4L/R。</p></blockquote><p>综上所诉，我们可以考虑N条速率均为R的链路组成的路径（所以，源和目的地之间有N-1台路由器），d（端时延）=N*L/R</p><h3 id="3-1-2-排队时延和分组丢失"><a href="#3-1-2-排队时延和分组丢失" class="headerlink" title="3.1.2 排队时延和分组丢失"></a>3.1.2 排队时延和分组丢失</h3><p>每个分组交换机有多条链路与之相连，对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>（output buffer）（也称为<strong>输出队列</strong>output queue），它用于存储路由器准备发往那条链路的分组。</p><p>如果到达的分组需要传输到的那条链路正在传输其他分组，到达的分组就要在输出缓存中等待，由此引起的时延叫做<strong>排队时延</strong>（queue delay）。这些时延是变化的，变化的程度取决于网络中的拥塞程度，如果分组到达时缓存空间已经满了，就会发生<strong>分组丢失（丢包）（packet lost）</strong>的情况，到达的分组或在排队的分组将被丢弃。</p><h3 id="3-1-3-转发表和路由选择协议"><a href="#3-1-3-转发表和路由选择协议" class="headerlink" title="3.1.3 转发表和路由选择协议"></a>3.1.3 转发表和路由选择协议</h3><p>在因特网中，每个端系统具有一个称为<strong>IP地址</strong>的地址。当源主机向目的端系统发送一个分组时，源在该分组的首部包含了目的地的IP地址。当一个分组到达路由器时，路由器检查该分组的目的地IP地址的<strong>一部分</strong>，再朝着目的地方向发送分组到达相邻的路由器，循环往复。每台路由器具有一个<strong>转发表</strong>（forwarding table），用于将目的地的一部分映射成为输出链路。</p><p>因特网具有一些特殊的<strong>路由选择协议</strong>（routing protocol），用于自动设置转发表。例如，一个路由选择协议可以决定每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器中的转发表。</p><h2 id="3-2-电路交换"><a href="#3-2-电路交换" class="headerlink" title="3.2 电路交换"></a>3.2 电路交换</h2><blockquote><p>通过网络链路和交换机移动数据有两种基本方法：<strong>分组交换</strong>（packet switching）和<strong>电路交换</strong>（circuit switching）。</p></blockquote><p><strong>电路交换</strong>网络，预留了端系统间通信沿路径所需的资源（缓存，链路传输速率）；  例如需要顾客预定的餐馆。<br><strong>分组交换</strong>网络，不预留。例如不需要预定但是要等号的餐馆。</p><p>举例说明电路交换网络。在一个网络中，用4条链路互联了4台电路交换机。每条链路有4条电路，因此每条链路能够支持4条并行连接。当两台主机要通信时，该网络在两台主机之间创建一条专用的端到端连接（end-to-end connection），该连接在连接期间获得该链路带宽的1/4部分。</p><h3 id="3-2-1-电路交换网中的复用"><a href="#3-2-1-电路交换网中的复用" class="headerlink" title="3.2.1 电路交换网中的复用"></a>3.2.1 电路交换网中的复用</h3><blockquote><p>链路中的电路是通过<strong>频分复用</strong>（FDM）或<strong>时分复用</strong>（TDM）来实现的。</p></blockquote><p>对于FDM，链路的频谱由跨越链路创建的所有连接所共享，在连接期间链路为每条连接专用一个频段。在电话网络中，这个频段通常具有4kHZ的宽度，该频段的宽度叫做<strong>带宽</strong>（bandwidth）。</p><p>对于TDM，时间被划分为固定区间的<strong>帧</strong>，每帧被划分为固定数量的<strong>时隙</strong>。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，一个时隙（在每个帧内）可用于传输该连接的数据。一条电路的传输速率等于帧速率乘以一个时隙中的比特数量。</p><p>电路交换因为在<strong>静默期</strong>（silent period）专用电路空间而效率较低。</p><h3 id="3-2-2-分组交换与电路交换的对比"><a href="#3-2-2-分组交换与电路交换的对比" class="headerlink" title="3.2.2 分组交换与电路交换的对比"></a>3.2.2 分组交换与电路交换的对比</h3><p><strong>电路交换</strong>不考虑需求，而预先分配了传输链路的使用，这使得已分配而并不需要的链路时间未被利用。</p><p><strong>分组交换</strong>按需分配链路使用。链路传输能力将在所有用户之间逐分组地被共享，这些用户有分组需要在链路上传输。</p><p>分组交换是趋势。</p><h2 id="3-3-网络的网络"><a href="#3-3-网络的网络" class="headerlink" title="3.3 网络的网络"></a>3.3 网络的网络</h2><p>端系统通过ISP与因特网相连，而ISP自身也必须互联，通过创建网络的网络解决这一问题。</p><p><a href="/img/cn1.6.png">图为ISP互联的等级结构</a></p><p>存在点（PoP）存在于等级结构的所有层次，但底层（接入ISP）除外。一个PoP只是提供商网络中的一台或多台路由器（在相同位置）群组，其中客户ISP能够与提供商ISP连接，客户网络能够从第三方通信提供商租用高速链路直接将路由器之一连接到位于该PoP的一台路由器。</p><p>任何ISP（除了第一层ISP）可以选择为多宿（multi-home），即可以与两个或更多提供商ISP连接。当一个ISP多宿时，即使它的提供商之一出现故障，它仍然能够继续发送和接收分组。</p><p>为了减少客户ISP支付给提供商ISP的费用，位于相同等级结构层次的邻近一对ISP能够对等（peer），使它们之间的所有流量经直接连接而不是通过上游的中间ISP传输。沿着这些相同路线，第三方公司创建一个因特网交换点（IXP），IXP是一个汇合点，多个ISP能够在这里共同对等。</p><p>内容提供商（如谷歌）通过创建自己的网络，不仅减少了向顶层ISP支付的费用，而且对其服务最终如何交付给端用户有了更多的控制。</p><h1 id="四、分组交换中的时延、丢包和吞吐量"><a href="#四、分组交换中的时延、丢包和吞吐量" class="headerlink" title="四、分组交换中的时延、丢包和吞吐量"></a>四、分组交换中的时延、丢包和吞吐量</h1><h2 id="4-1-分组交换网中的时延概述"><a href="#4-1-分组交换网中的时延概述" class="headerlink" title="4.1 分组交换网中的时延概述"></a>4.1 分组交换网中的时延概述</h2><p>当分组从一个结点（端系统或路由器）沿着这条路径到后继结点，该分组在沿途的每个结点经受了几种不同类型的时延。其中最为重要的是<strong>结点处理时延</strong>（nodel processing delay）、<strong>排队时延</strong>（queueing delay）、<strong>传输时延</strong>（transmission delay）和<strong>传播时延</strong>（propagation delay），这些时延总体累加起来是<strong>结点总时延</strong>（total nodal delay）。</p><p><strong>时延的类型</strong></p><p>1 <strong>处理时延</strong><br>检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。它还包括其他因素，如检查比特级别差错所需要的时间。<br>通常是<em>微秒或更低</em>量级。</p><p>2 <strong>排队时延</strong><br>在队列中当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。<br>通常是<em>毫秒到微秒</em>量级。</p><p>3 <strong>传输时延</strong><br>用L（比特）表示该分组的长度，用R（bps）表示从路由器A到B的链路传输速率，则传输时延为L/R。注意是路由器A将分组推向链路所需要的时间。<br>通常是<em>毫秒到微秒</em>量级。</p><p>4 <strong>传播时延</strong><br>当一个比特被推向链路，送往目标路由器时，从该链路的起点到目标路由器传播所需要的时间是传播时延。该传播速率取决于该链路的物理媒体（光纤、双绞铜线等），速率范围略小于光速。该传播时延等于两台路由器之间的距离除以传播速率，即d/s。<br>广域网中，通常是<em>毫秒</em>量级。</p><p>5 <strong>传输时延</strong>和<strong>传播时延</strong>的<strong>比较</strong><br>传输时延是分组长度和链路传输速率的函数；<br>传播时延是两台路由器之间距离的函数。</p><blockquote><p><strong>总时延</strong>由上述四种时延相加，在实际生活中每种时延可能变化很大。</p></blockquote><h2 id="4-2-排队时延和丢包"><a href="#4-2-排队时延和丢包" class="headerlink" title="4.2 排队时延和丢包"></a>4.2 排队时延和丢包</h2><p>令a表示分组到达队列的平均速率（a的单位是分组/秒，即pkt/s），R是传输速率，假定所有分组都是由L比特组成的，则比特到达分组的平均速率是La（bps）。比率La/R被称为<strong>流量强度</strong>。如果La/R&gt;1，则该队列将趋于无限增大。因此，<em>设计系统时流量强度不能大于1</em>。</p><p>如果<strong>流量强度</strong>接近于0，则几乎没有分组到达并且到达间隔很大，随着流量强度接近1，平均排队长度将变得越来越长。随着流量强度接近1，平均排队时延迅速增加。该强度的少量增加将导致时延大得多的增加。<br><a href="/img/cn1.7.png">图为平均排队时延与流量强度的关系</a></p><p>在实际使用中，一条链路前的队列是有限的，其容量受限于路由器设计和使用成本，当分组到达满的队列时，路由器将丢弃这个分组，即<strong>丢包</strong>。丢包的份额随着流量强度的增加而增加，一个结点的性能不仅根据时延度量，还与丢包的概率度量。丢失的分组可能基于端到端的原则重传，以确保所有的数据最终传到目的地。</p><h2 id="4-3-端到端时延"><a href="#4-3-端到端时延" class="headerlink" title="4.3 端到端时延"></a>4.3 端到端时延</h2><p>上一节研究了结点间的时延，还需要研究端到端的时延，这里不再赘述。除了上文介绍的几种时延，端系统中还存在着其他一些重要时延，例如，作为它的协议的一部分，希望向共享媒体传输分组的端系统可以有意地延迟它的传输以与其他端系统共享媒体。另一个重要的时延是<strong>媒体分组化时延</strong>。</p><h2 id="4-4-计算机网络中的吞吐量"><a href="#4-4-计算机网络中的吞吐量" class="headerlink" title="4.4 计算机网络中的吞吐量"></a>4.4 计算机网络中的吞吐量</h2><p>除了时延和丢包，计算机网络中另一个必不可少的性能测度是<strong>端到端吞吐量</strong>。在任何时间瞬间的<strong>瞬时吞吐量</strong>是端系统B接收到该文件的速率。在下载期间，如果文件由F比特组成，端系统B接收到所有文件用时T秒，则<strong>平均吞吐量</strong>是F/T（bps）。</p><p>对于简单的两链路的网络，其吞吐量是min|R1, R2|，这叫做瓶颈链路（bottleneck link）的传输速率。n条链路同理。<br><a href="/img/cn1.8.png">图为两链路网络</a></p><p>吞吐量取决于数据流过的链路的传输速率，当没有其他干扰流量时，其吞吐量能够近似为沿着源和目的地之间路径的<strong>最小传输速率</strong>。</p><h1 id="五、协议层次及其服务模型"><a href="#五、协议层次及其服务模型" class="headerlink" title="五、协议层次及其服务模型"></a>五、协议层次及其服务模型</h1><h2 id="5-1-分层的体系结构"><a href="#5-1-分层的体系结构" class="headerlink" title="5.1 分层的体系结构"></a>5.1 分层的体系结构</h2><h3 id="5-1-1-协议分层"><a href="#5-1-1-协议分层" class="headerlink" title="5.1.1 协议分层"></a>5.1.1 协议分层</h3><p>为了给网络协议的设计提供一个结构，网络设计者以<strong>分层</strong>（layer）的方式组织协议以及实现这些协议的网络硬件。每个协议属于这些层次之一，就像航线体系结构中的每种功能属于某一层一样。<br><a href="/img/cn1.9.png">图为航线功能的水平分层</a></p><p>每层通过在该层中执行某些动作或使用直接下层的服务来提供<strong>服务</strong>（service），即<strong>服务模型</strong>（service model）。例如，由第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送，这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送服务，加上第n层的检测和重传丢失报文的功能来实现的。</p><p>一个协议层能够用软件、硬件或两者的结合来实现。一个第n层协议也<strong>分布</strong>在构成该网络的端系统、分组交换机和其他组件中，第n层协议的不同部分常常位于这些网络组件的各部分中。</p><blockquote><p>协议分层<br>优点：<strong>概念化</strong>和<strong>结构化</strong>。<br>潜在的缺点：<br>1 一层可能冗余较低层的功能<br>2 某层的功能可能需要仅在其他某层才出现的信息，违反了层次分离的目标。</p></blockquote><p>各层的所有协议称为协议栈（protocol stack），因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。</p><p>1 <strong>应用层</strong><br>应用层是网络应用程序及它们的应用层协议存留的地方。因特网的应用层包含许多协议，例如HTTP（Web文档的请求和传送）、SMTF（电子邮件报文的传输）和FTP（两个端系统之间的文件传送）。应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，这种位于应用层的信息分组称为<strong>报文</strong>（message）。</p><p>2 <strong>运输层</strong><br>因特网的运输层在应用程序端点之间传送应用层报文。在因特网中，运输层包含TCP和UDP两个运输协议，利用其中任一个都能运输应用层报文。我们把运输层报文称作<strong>报文段</strong>（segment）。<br>——<strong>TCP</strong>提供连接服务，包括了应用层报文向目的地的确保传递和流量控制（即发送方/接收方速率匹配）。<br>——<strong>UDP</strong>提供无连接服务，它不提供不必要服务的服务（没有可靠性、流量控制、拥塞控制等）。</p><p>3 <strong>网络层</strong><br>因特网的网络层负责将称为<strong>数据报</strong>（datagram）的网络层分组从一台主机移动到另一台主机。在一台源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址。</p><p>因特网的网络层包括内容如下：<br>1、著名的<strong>IP协议</strong>，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。IP协议是唯一的，所有具有网络层的因特网组件必须运行IP协议。<br>2、决定路由的<strong>路由选择协议</strong>，它使得数据报根据该路由从源传输到目的地。路由选择协议不唯一。</p><p>网络层包含了IP协议和一些路由选择协议，通常把它称为<strong>IP层</strong>。</p><p>4 <strong>链路层</strong><br>在每个结点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层。由链路层提供的服务取决于应用于该链路的特定链路层协议。网络层将受到来自每个不同的链路层协议的不同服务。我们把链路层分组称为帧（frame）。</p><p>5 <strong>物理层</strong><br>链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的<em>一个一个比特</em>从一个结点移动到下一个结点。在这一层的协议仍然是链路相关的，并且进一步与该链路的<strong>传输媒体相关</strong>（以太网关于双铜绞线、关于同轴电缆、关于光纤的协议等等）。在每种场合中，跨越这些链路移动一个比特是以不同的方式进行的。</p><h3 id="5-1-2-OSI模型"><a href="#5-1-2-OSI模型" class="headerlink" title="5.1.2 OSI模型"></a>5.1.2 OSI模型</h3><p>因特网协议栈不是唯一的协议栈。国际标准化组织（ISO）提出计算机网络应组织为大约7层，称为开放系统互连（OSI）模型[ISO 2012]。这7层分别是：应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。相比于因特网协议栈，它新增了表示层和会话层。</p><p>1 <strong>表示层</strong><br>表示层的作用是使通信的应用程序能够解释交换数据的含义。这些服务包括数据压缩和数据加密以及数据描述（使应用程序不必担心在各台计算机中表示/存储的内部格式不同的问题）。</p><p>2 <strong>会话层</strong><br>会话层提供了数据交换定界和同步功能，包括了建立检查点和恢复方案的方法。</p><p>应用开发者决定这两个层次提供的服务是否重要，如果该服务重要，应用开发者就在应用程序中构建该功能。</p><h2 id="5-2-封装"><a href="#5-2-封装" class="headerlink" title="5.2 封装"></a>5.2 封装</h2><p>数据从发送端系统的协议栈向下，向上和向下经过中间的链路层交换机和路由器的协议栈，进而向上到达接收端系统的协议栈。链路层交换机实现第一层和第二层，路由器实现了第一层到第三层。<br><a href="/img/cn1.10.png">图为主机、路由器和链路层交换机，每个包含了不同的层，反映了不同的功能</a></p><p>在发送主机端，一个<strong>应用层报文</strong>被传送给运输层。在最简单的情况下，运输层收取到报文并附上附加信息，应用层报文和运输层首部信息构成了<strong>运输层报文段</strong>。运输层由此<strong>封装</strong>（encapsulation）了应用层报文。运输层再向网络层传递该报文段，网络层增加了如源和目的地端系统地址等网络层首部信息，产生了<strong>网络层数据报</strong>。数据报接下来传递给链路层，链路层增加它自己的链路层首部信息并创建<strong>链路层帧</strong>（link-layer frame）。</p><p>由此可见，在每一层，一个分组具有两种类型的字段：首部字段和<strong>有效载荷字段</strong>（payload field）。有效载荷通常是来自上一层的分组。</p><p>封装的过程在实际中会更加复杂。例如，一个大报文可能被划分为多个运输层的报文段（可能被划分为多个网络层数据报），在接收端则必须从其连续的数据报中重构这样一个报文段。</p><h1 id="六、面对攻击的网络"><a href="#六、面对攻击的网络" class="headerlink" title="六、面对攻击的网络"></a>六、面对攻击的网络</h1><p><strong>网络安全</strong>领域主要探讨以下问题：攻击者如何攻击网络以及如何防御攻击，或者更好的设计能够事先免除这样的攻击的新型体系结构。</p><h2 id="6-1-有害程序能经过因特网放入到计算机中"><a href="#6-1-有害程序能经过因特网放入到计算机中" class="headerlink" title="6.1 有害程序能经过因特网放入到计算机中"></a>6.1 有害程序能经过因特网放入到计算机中</h2><p>一旦恶意软件感染设备，就能够窃取隐私信息，然后发送给攻击者。这些受害设备网络被称为<strong>僵尸网络</strong>（botnet），坏人能够利用僵尸网络控制并有效地对目标主机展开垃圾邮件分发或分布式拒绝服务攻击。</p><p>今天的多数恶意软件是<strong>自我复制</strong>（self-replicating）的：一旦感染了一台主机，就会从那台主机寻求进入更多的主机。恶意软件能够以<strong>病毒</strong>或<strong>蠕虫</strong>的方式进行扩散，<br>——<strong>病毒</strong>（virus）是一种需要某种形式的用户交互来感染用户设备的恶意软件。<br>——<strong>蠕虫</strong>（worm）是一种无需任何明显用户交互就能进入设备的恶意软件。</p><h2 id="6-2-攻击者能够攻击服务器和网络基础设施"><a href="#6-2-攻击者能够攻击服务器和网络基础设施" class="headerlink" title="6.2 攻击者能够攻击服务器和网络基础设施"></a>6.2 攻击者能够攻击服务器和网络基础设施</h2><p>还有一种宽泛类型的安全性威胁称为拒绝服务攻击（DoS攻击）。Dos攻击能够使得网络、主机或其他基础设施部分不能由合法用户使用。大多数因特网DoS攻击属于下列三种类型之一：</p><p>——<strong>弱点攻击</strong>。如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，或者更糟糕的是主机可能崩溃。<br>——<strong>带宽洪泛</strong>。攻击者向目标主机发送大量分组，分组数量之多使得目标的接入链路变得拥塞，使得合法的分组无法到达服务器。<br>——<strong>连接洪泛</strong>。攻击者在目标主机中创建大量的半开或全开TCP连接。该主机因这些伪造的连接而陷入困境，并停止接受合法的连接。</p><p>对于带宽洪泛攻击，如果某服务器的接入速率为R bps，则攻击者需要以大约R bps的速率来产生危害。当R非常大时，单一攻击源可能无法产生足够大的流量来伤害该服务器，而且如果从单一源发出所有流量的话，上游路由器就能够检测出该攻击并在该流量靠近服务器前就能将其阻挡下来。所以攻击者会采用<strong>分布式DoS</strong>（DDoS，控制多个源并让每个源向目标猛烈发送流量）的方式削弱或损坏服务器，所有受控源的聚合流量速率需要大约R的能力）。相比于DoS，DDoS更加难以检测和防范。</p><p><a href="/img/cn1.11.png">图为DDoS攻击</a></p><h2 id="6-3-攻击者能够嗅探分组"><a href="#6-3-攻击者能够嗅探分组" class="headerlink" title="6.3 攻击者能够嗅探分组"></a>6.3 攻击者能够嗅探分组</h2><p>在无线传输设备的附近放置一台被动的接收机，该接收机就能得到传输的每个分组的副本。记录每个流经的分组副本的被动接收机被称为<strong>分组嗅探机</strong>（packet sniffer）。</p><p>嗅探器也能够部署在有线环境中。在有线的广播环境中，如在许多以太网LAN中，分组嗅探器能够获得经该LAN发送的所有分组。此外，获得某机构与因特网连接的接入路由器或接入链路访问权的攻击者能够放置一台嗅探器以产生从该机构出入的每个分组的副本，再对嗅探到的分组进行离线分析，就能得出敏感信息。</p><p>因为分组嗅探器是被动的，所以难以检测出它们的存在。最好的防御嗅探的方法基本上都与<strong>密码学</strong>有关。</p><h2 id="6-4-攻击者能够伪装成你信任的人"><a href="#6-4-攻击者能够伪装成你信任的人" class="headerlink" title="6.4 攻击者能够伪装成你信任的人"></a>6.4 攻击者能够伪装成你信任的人</h2><p>生成具有任意源地址、分组内容和目的地址的分组，然后将这个人工制作的分组传输到互联网中极为容易，这种将具有虚假源地址的分组注入因特网的能力被称为<strong>IP哄骗</strong>（IP spoofing），而它只是一个用户能够冒充另一个用户的许多方式的一种。</p><p>应对这种问题，我们需要采用<strong>端点鉴别</strong>。即一种使我们能够确信一个报文源自我们认为它应当来自的地方的机制。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/21/hello-world/"/>
    <url>/2022/03/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
