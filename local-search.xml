<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1 Date lab详解</title>
    <link href="/2022/05/11/Csapp1/"/>
    <url>/2022/05/11/Csapp1/</url>
    
    <content type="html"><![CDATA[<h1 id="date-lab详解"><a class="markdownIt-Anchor" href="#date-lab详解"></a> Date lab详解</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>最近在读大名鼎鼎的cs:app，很懵懂，开一个专栏记录解答下本课程自带的lab。</p><h2 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h2><p>笔者使用Ubuntu22.04的虚拟机，用vscode做主要编程软件。<br />lab相关文件可以从课程页面下载，这里放置课程链接：<a href="http://csapp.cs.cmu.edu/3e/labs.html">csapp lab</a><br />再贴一个链接，里面包含有中文版的详细描述，简洁明了：<a href="https://hansimov.gitbook.io/csapp/">csapp中文版电子书及lab</a><br />关于实验环境的配置这里不再赘述。</p><h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2><p>首先贴上一张表格，里面是这个lab需要实现的13个函数</p><table><thead><tr><th>函数名</th><th>描述</th><th>难度级别</th><th>最大操作符数</th></tr></thead><tbody><tr><td>bitXor(x,y)</td><td>x 异或 y</td><td>1</td><td>14</td></tr><tr><td>tmin()</td><td>最小的整数补码</td><td>1</td><td>4</td></tr><tr><td>isTmax(x)</td><td>x 为最大的整数补码时为真</td><td>1</td><td>10</td></tr><tr><td>allOddBits(x)</td><td>x 的奇数位都为 1 时为真</td><td>2</td><td>12</td></tr><tr><td>negate(x)</td><td>使用 ~ 操作符返回 -x</td><td>2</td><td>5</td></tr><tr><td>isAsciDigit(x)</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>30</mn><mo>⩽</mo><mi>x</mi><mo>⩽</mo><mn>0</mn><mi>x</mi><mn>39</mn></mrow><annotation encoding="application/x-tex">0x30⩽x⩽0x39</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">3</span><span class="mord">9</span></span></span></span> 时为真</td><td>3</td><td>15</td></tr><tr><td>conditional</td><td>等同于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo stretchy="false">?</mo><mi>y</mi><mo>:</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x ? y : z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mclose">?</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span></td><td>3</td><td>16</td></tr><tr><td>isLessOrEqual(x, y)</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⩽</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x⩽y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 时为真，否则为假</td><td>3</td><td>24</td></tr><tr><td>logicalNeg(x))</td><td>不用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mclose">!</span></span></span></span> 运算符计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">!</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">!x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mclose">!</span><span class="mord mathdefault">x</span></span></span></span></td><td>4</td><td>12</td></tr><tr><td>howManyBits(x)</td><td>用补码表示 x 的最小位数</td><td>4</td><td>90</td></tr><tr><td>floatScale2(uf)</td><td>对于浮点参数 f，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">2 \times f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的位级等价数</td><td>4</td><td>30</td></tr><tr><td>floatFloat2Int(uf)</td><td>对于浮点参数 f，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">(int) f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的位级等价数</td><td>4</td><td>30</td></tr><tr><td>floatPower2(x)</td><td>对于整数 x，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.</mn><msup><mn>0</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2.0^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></td><td>4</td><td>30</td></tr></tbody></table><h3 id="1-bitxorint-x-int-y"><a class="markdownIt-Anchor" href="#1-bitxorint-x-int-y"></a> 1 bitXor(int x, int y)</h3><p><strong>要求:</strong> x^y using only ~ and &amp;</p><p><strong>运算符:</strong>  ~ &amp;</p><p><strong>解析:</strong><br />考察对几个位运算符的理解程度。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-tminvoid"><a class="markdownIt-Anchor" href="#2-tminvoid"></a> 2 tmin(void)</h3><p><strong>要求:</strong> return minimum two’s complement integer</p><p><strong>运算符:</strong> !  ~  &amp;  ^  |  +  &lt;&lt;  &gt;&gt;</p><p><strong>解析:</strong><br />由于int类型为4字节，其对应最小的整数补码为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><munder><munder><mrow><mn>0</mn><mo>…</mo><mn>0</mn></mrow><mo stretchy="true">⏟</mo></munder><mn>31</mn></munder></mrow><annotation encoding="application/x-tex">1\underbrace{0\ldots0}_{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.943548em;vertical-align:-1.299108em;"></span><span class="mord">1</span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6444400000000001em;"><span style="top:-1.700892em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000000000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64444em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.299108em;"><span></span></span></span></span></span></span></span></span>，直接输出了。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-istmaxint-x"><a class="markdownIt-Anchor" href="#3-istmaxint-x"></a> 3 isTmax(int x)</h3><p><strong>要求:</strong> returns 1 if x is the maximum, two’s complement number</p><p><strong>运算符:</strong> ! ~ &amp; ^ | +</p><p><strong>解析:</strong><br />当 x 为最大整数时，补码表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>01</mn><mo>…</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">01\ldots1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span></span></span></span>，即符号位为 0，其余位为 1，可得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn><mo>=</mo><mtext> </mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">x + 1 = ~x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace nobreak"> </span><span class="mord mathdefault">x</span></span></span></span>。然而当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 时，前述等式也成立，因此需要排除掉这种情况。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-keyword">return</span> ! ((~x ^ (x+<span class="hljs-number">1</span>)) | !(x+<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-alloddbitsint-x"><a class="markdownIt-Anchor" href="#4-alloddbitsint-x"></a> 4 allOddBits(int x)</h3><p><strong>要求:</strong> return 1 if all odd-numbered bits in word set to 1</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />构造出一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>s</mi><mi>k</mi><mo>=</mo><munder><munder><mrow><mn>1010</mn><mo>…</mo><mn>10</mn></mrow><mo stretchy="true">⏟</mo></munder><mn>32</mn></munder></mrow><annotation encoding="application/x-tex">mask = \underbrace{1010\ldots10}_{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.943548em;vertical-align:-1.299108em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6444400000000001em;"><span style="top:-1.700892em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.0000000000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.64444em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.299108em;"><span></span></span></span></span></span></span></span></span>，再让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>s</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">mask</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 进行 &amp; 操作，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的偶数位全部置0，再进行一次异或操作，不要忘记取反。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-type">int</span> mask = <span class="hljs-number">0xAA</span> + (<span class="hljs-number">0xAA</span> &lt;&lt; <span class="hljs-number">8</span>);<br>  mask = mask + (mask &lt;&lt; <span class="hljs-number">16</span>);<br>  <span class="hljs-keyword">return</span> !((mask &amp; x) ^ mask);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-negateint-x"><a class="markdownIt-Anchor" href="#5-negateint-x"></a> 5 negate(int x)</h3><p><strong>要求:</strong> return -x</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />用补码表示，负数比整数取值范围多1</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-keyword">return</span> ~x + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-isasciidigitint-x"><a class="markdownIt-Anchor" href="#6-isasciidigitint-x"></a> 6 isAsciiDigit(int x)</h3><p><strong>要求:</strong> return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’)</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />问题可以转化为满足下面式子时返回1，否则返回0：$$(x - 0x30 &gt;= 0) &amp;&amp; (0x39 - x) &gt;=0$$与首位为1的二进制数进行&amp;操作，可以判断出二进制数是否为负，借此方法容易解决。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-type">int</span> TMIN = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;<br>  <span class="hljs-keyword">return</span> !((x + ~<span class="hljs-number">0x30</span> + <span class="hljs-number">1</span>) &amp; TMIN) &amp; !((<span class="hljs-number">0x39</span> + ~x + <span class="hljs-number">1</span>) &amp; TMIN);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-conditionalint-x-int-y-int-z"><a class="markdownIt-Anchor" href="#7-conditionalint-x-int-y-int-z"></a> 7 conditional(int x, int y, int z)</h3><p><strong>要求:</strong> same as x ? y : z</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />! 运算将 x 映射到 [0, 1] 区间，使用函数 f(x)=!x+(−1) 取出 y，则 ∼f(x) 取出 z。<br />当 x≠0时，f(x)=−1，其位模式全为 1，因此 f(x)&amp;y=y。<br />当 x=0 时，f(x)=0，其位模式全为 0，因此 f(x)&amp;y=0。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;<br>  x = !x + ~<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> (y &amp; x) | (z &amp; ~x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-islessorequalint-x-int-y"><a class="markdownIt-Anchor" href="#8-islessorequalint-x-int-y"></a> 8 isLessOrEqual(int x, int y)</h3><p><strong>要求:</strong> if x &lt;= y  then return 1, else return 0</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />将问题转换为下列公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mi>x</mi><mo>&lt;</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y &gt;=0 \&amp;\&amp; x &lt;0) || ((x * y &gt;= 0) \&amp;\&amp; (y + (-x) &gt;= 0)) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord">∣</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>具体见代码注释。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-type">int</span> signX = (x &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 判断x是否为负</span><br>  <span class="hljs-type">int</span> signY = (y &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 判断y是否为负</span><br>  <span class="hljs-type">int</span> signXSubY = ((y + ~x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 判断y+(-x)是否为负</span><br>  <span class="hljs-keyword">return</span> (signX &amp; ~signY) | (!(signX ^ signY) &amp; !signXSubY);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-logicalnegint-x"><a class="markdownIt-Anchor" href="#9-logicalnegint-x"></a> 9 logicalNeg(int x)</h3><p><strong>要求:</strong> implement the ! operator, using all of the legal operators except !</p><p><strong>运算符:</strong> ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />当 x≠0 时，x|(−x) 的符号位必然为 1</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-keyword">return</span> ~(x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>&amp;<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-howmanybitsint-x"><a class="markdownIt-Anchor" href="#10-howmanybitsint-x"></a> 10 howManyBits(int x)</h3><p><strong>要求:</strong> return the minimum number of bits required to represent x in two’s complement</p><p><strong>运算符:</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>解析:</strong><br />当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x≥0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，位数取决于 1 的最高位数；当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，位数则取决于 0 的最高位数（根据补码表示的定义，符号位起连续的 1 可合并起来用一个位表示）。</p><p>首先考虑将负数取反，将问题统一成计算 1 的最高位，利用算术右移即可完成， 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&gt;</mo><mo>&gt;</mo><mn>31</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x=x⊕(x&gt;&gt;31)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><p>然后使用二分法计算 1 的最高位：判断高 16 位是否大于 0，若大于 0 说明高 16 位中存在 1，否则 1 在低 16 位中。使用 conditional 函数更新 x（取出高 16 位或低 16 位）。迭代判断 8 位、4 位等等。</p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-type">int</span> bit;<br>  <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>  x = x ^ (x &gt;&gt; <span class="hljs-number">31</span>); <span class="hljs-comment">// 将负数取反</span><br><br>  bit = !!(x &gt;&gt; <span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-number">4</span>;<br>  res = res + bit;<br>  x = x &gt;&gt; bit;<br><br>  bit = !!(x &gt;&gt; <span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-number">3</span>;<br>  res = res + bit;<br>  x = x &gt;&gt; bit;<br><br>  bit = !!(x &gt;&gt; <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">2</span>;<br>  res = res + bit;<br>  x = x &gt;&gt; bit;<br><br>  bit = !!(x &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">1</span>;<br>  res = res + bit;<br>  x = x &gt;&gt; bit;<br><br>  bit = !!(x &gt;&gt; <span class="hljs-number">1</span>);<br>  res = res + bit;<br>  x = x &gt;&gt; bit;<br><br>  <span class="hljs-keyword">return</span> x + res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-floatscale2unsigned-uf"><a class="markdownIt-Anchor" href="#11-floatscale2unsigned-uf"></a> 11 floatScale2(unsigned uf)</h3><p><strong>要求:</strong> Return bit-level equivalent of expression <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">2 \times f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> for floating point argument f. Both the argument and result are passed as unsigned int’s, but they are to be interpreted as the bit-level representation of single-precision floating point values. When argument is NaN, return argument.</p><p><strong>运算符:</strong> Any integer/unsigned operations incl.  ||, &amp;&amp;. also if, while</p><p><strong>解析:</strong></p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h3 id="12-floatfloat2intunsigned-uf"><a class="markdownIt-Anchor" href="#12-floatfloat2intunsigned-uf"></a> 12 floatFloat2Int(unsigned uf)</h3><p><strong>要求:</strong> Return bit-level equivalent of expression (int) f for floating point argument f.</p><p><strong>运算符:</strong> Any integer/unsigned operations incl.  ||, &amp;&amp;. also if, while</p><p><strong>解析:</strong></p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h3 id="13-floatpower2int-x"><a class="markdownIt-Anchor" href="#13-floatpower2int-x"></a> 13 floatPower2(int x)</h3><p><strong>要求:</strong> Return bit-level equivalent of the expression <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.</mn><msup><mn>0</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2.0^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span> (2.0 raised to the power x) for any 32-bit integer x.</p><p><strong>运算符:</strong> Any integer/unsigned operations incl.  ||, &amp;&amp;. also if, while</p><p><strong>解析:</strong></p><p><strong>代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
      <category>csapp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲</title>
    <link href="/2022/05/04/Suanfa2/"/>
    <url>/2022/05/04/Suanfa2/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>随缘更新</p><h2 id="1-01背包问题"><a class="markdownIt-Anchor" href="#1-01背包问题"></a> 1、01背包问题</h2><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 件物品和一个容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的背包。放入第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>件物品花费的费用是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> ，得到的价值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> ，求将哪些物品装入背包可使价值总和最大。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。<br />用子问题定义状态：即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品恰放入一个容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的背包可以获得的最大价值（这里原文中使用了“恰”，但实际并不需要正好装满，在初始化可以区分开这两种情况，下文有提及）。则其<strong>状态转移方程</strong>便是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mi mathvariant="normal">−</mi><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i][j]=max(f[i−1][j] , f[i−1][j−c[i]] + w[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">−</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>“将前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品放入容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的背包中”这个<strong>子问题</strong>，若只考虑第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品的策略（放或不放），那么就可以转化为一个只牵扯前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">i−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 件物品的问题。</p><p>如果<strong>不放</strong>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品，那么问题就转化为“ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">i−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 件物品放入容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的背包中”，最大价值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i−1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> ；如果<strong>放</strong>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品，那么问题就转化为“前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">i−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 件物品放入剩下的容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi mathvariant="normal">−</mi><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j−c[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">−</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 的背包中”，此时能获得的最大价值就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mi mathvariant="normal">−</mi><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i−1][j−c[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">−</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span> 再加上通过放入第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 件物品获得的价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>。</p><h3 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h3><p>后续再更</p><h2 id="2-完全背包问题"><a class="markdownIt-Anchor" href="#2-完全背包问题"></a> 2、完全背包问题</h2><h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3><p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 种物品和一个容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的背包，每种物品都有<strong>无限</strong>件可用。第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 种物品的费用是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>  ，价值是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>本题相比于01背包增加了每件物品有无限件这一条件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 件、取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 件、取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> 等很多种。如果仍然按照解01背包时的思路，令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 种物品恰放入一个容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span> 的背包的最大权值。仍然可以按照每种物品不同的策略写出<strong>状态转移方程</strong>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mi mathvariant="normal">−</mi><mi>k</mi><mo>×</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>×</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>∣</mo><mn>0</mn><mo>≤</mo><mi>k</mi><mo>×</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">f[i][j]=max(f[i−1][j−k \times c[i]]+k \times w[i])∣0≤k \times c[i]≤j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03：运输层</title>
    <link href="/2022/04/03/Cn3/"/>
    <url>/2022/04/03/Cn3/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="一-概述和运输层服务"><a class="markdownIt-Anchor" href="#一-概述和运输层服务"></a> 一、概述和运输层服务</h1><p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信</strong>（logic communication）功能。<br /><img src="/img/cn3.1.png" alt="逻辑通信" /><br /><img src="/img/cn3.2.png" alt="概览" /></p><h2 id="11-运输层和网络层的关系"><a class="markdownIt-Anchor" href="#11-运输层和网络层的关系"></a> 1.1 运输层和网络层的关系</h2><p>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。<br /><img src="/img/cn3.3.png" alt="运输层和网络层的逻辑通信" /></p><h2 id="12-因特网运输层概述"><a class="markdownIt-Anchor" href="#12-因特网运输层概述"></a> 1.2 因特网运输层概述</h2><p>因特网网络层协议有一个名字叫<strong>IP</strong>，即国际协议。IP尽最大努力交付报文段，但不做任何确保，因此它是<strong>不可靠服务</strong>。每台主机至少有一个IP地址。</p><p>UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务，这种服务被称为运输层的<strong>多路运输</strong>与<strong>多路分解</strong>。其次，UDP和TCP还可以通过在其报文段首部中包括差错检查字段而提供<strong>完整性检查</strong>。UDP仅能提供这两种服务，TCP还有附加服务（可靠数据传输、拥塞控制等）。</p><h1 id="二-多路复用与多路分解"><a class="markdownIt-Anchor" href="#二-多路复用与多路分解"></a> 二、多路复用与多路分解</h1><blockquote><p><strong>多路分解</strong>：将运输层报文段中的数据交付到正确的套接字。<br /><strong>多路复用</strong>：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（用于多路分解）从而生成报文段，然后将报文段传递给网络层。</p></blockquote><p>每个报文段使用<strong>源端口号字段</strong>（sourse port number field）和<strong>目的端口号字段</strong>（destination port number field）来指示该报文段所要交付到的套接字。端口号是一个16比特的数，其大小在0-65535之间。0-1023范围的端口号称为<strong>周知端口号</strong>（well-known port number），它们保留给注入HTTP和FTP之类的周知应用层协议。<br /><img src="/img/cn3.4.png" alt="运输层报文段中的源与目的端口字段" /></p><h2 id="21-无连接的多路复用与多路分解"><a class="markdownIt-Anchor" href="#21-无连接的多路复用与多路分解"></a> 2.1 无连接的多路复用与多路分解</h2><p>在运输层，无连接的网络传输是通过UDP来实现的。<strong>UDP报文中只有源端口号和目的端口号</strong>，一个UDP套接字是由一个含有目的IP地址和目的端口号的<strong>二元组</strong>来全面标识的。</p><p>例如主机A产生了一个UDP报文段，报文段中就会包括源端口号（11111）、目的端口号（22222）、程序数据（还有两个其他的值，在这里我们不关心）。然后，运输层将生成的报文段交给网络层。网络层将其放到一个IP数据报中，并提供尽力而为的交付，将其发送到主机B中。如果该报文到达主机B，主机B运输层就会检查该报文的端口号，并将该报文段传递给套接字的端口号为接收到的报文段的目的端口号（22222）的套接字。从而实现了进程间的网络通信。而源端口号的作用是为了让主机B能向主机A发送信息的，也就是说，当主机B在接收到主机A的数据后，要向主机A发送一个回应时，主机B发送的报文段的目的端口号就是11111.</p><h2 id="22-面向连接的多路复用与多路分解"><a class="markdownIt-Anchor" href="#22-面向连接的多路复用与多路分解"></a> 2.2 面向连接的多路复用与多路分解</h2><p>在运输层中面向连接的网络传输多使用TCP，而TCP套接字和UDP套接字之间有一个细微的差别，就是，TCP套接字是由一个<strong>四元组</strong>（源IP地址、源端口号，目的IP地址，目的端口号）来标识的。这样，当一个TCP报文段从网络到达一台主机时，主机会使用全部4个值来将报文段定向，即多路分解到相应的套接字。</p><p>与UDP不同的是，两个具有不同源IP或源端口号的到达的TCP报文段将被重定向到两个不同的套接字。</p><p>尽管如此，而TCP的多路利用和多路分解的工作原理与无连接的UDP的多路复用和多路分解的原理还是大致一样的。</p><h2 id="23-web服务器与tcp"><a class="markdownIt-Anchor" href="#23-web服务器与tcp"></a> 2.3 Web服务器与TCP</h2><ul><li>连接套接字与进程之间并非总是有着一一对应的关系 。</li><li>当今的高性能 Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。（线程可被看作是一个轻量级的子进程。）</li><li>如果客户与服务器使用持续 HTTP ，则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换 HTTP 报文 。然而，如果客户与服务器使用非持续连接，则对每一对请求/响应都创建一个新的 TCP连接并在随后关闭，因此对每一对请求/响应创建一个新的套接字并在随后关闭 。 这种套接字的频繁创建与关闭会严重地影响一个繁忙的Web服务器的性能(虽然有许多操作系统技巧可用来减轻这个问题的影响) 。</li></ul><h1 id="三-无连接运输udp"><a class="markdownIt-Anchor" href="#三-无连接运输udp"></a> 三、无连接运输：UDP</h1><p>UDP只提供复用和分解，它有如下优点：</p><ul><li><strong>关于何时、发送什么数据的应用层控制更为精细</strong>：这是因为一旦应用程序将数据交给UDP，UDP就会打包将其发送给网络层，不会受到传输层的调节，这在一些实时应用中比较实用；当然，应用程序还可以通过UDP+自主开发一些功能的模式来扩展UDP。</li><li><strong>无需建立连接</strong>：所以就不会引入额外的时延。这也可能是DNS使用UDP而不是TCP的主要原因，如果使用TCP的话，DNS服务将会慢很多；HTTP使用TCP的主要原因是对TCP的可靠性的依赖超过对速度的要求；</li><li><strong>无需维护连接状态</strong>：TCP为了实现可靠数据传输和拥塞控制需要在端系统中维护一些参数，这些参数包括：接收和发送的缓存、拥塞控制参数、确认号和序号；这些参数信息都是必须的；而UDP因为不建立连接，所以自然也就不需要维护这些状态，这就减少了时空开销；</li><li><strong>分组首部更小</strong>：TCP有20字节的首部开销，而UDP只有8字节；</li></ul><h2 id="31-udp报文段结构"><a class="markdownIt-Anchor" href="#31-udp报文段结构"></a> 3.1 UDP报文段结构</h2><p><img src="/img/cn3.5.png" alt="UDP报文段结构" /></p><h2 id="32-udp检验和"><a class="markdownIt-Anchor" href="#32-udp检验和"></a> 3.2 UDP检验和</h2><p>UDP检验和的需要计算UDP头部（计算的时候校验和部分的16位需要置0）加数据部分，还需要加上UDP伪头部。计算步骤如下：</p><ol><li>将UDP伪头部、UDP头部和数据部分全部用16进制数表示。</li><li>将第一个16进制数与第二个16进制数相加，得到一个32位的数，如果32位数的高16位大于0，需要将高16位与低16位再相加，得到一个32位的数，直到高16位为0，得到这一次相加的结果。</li><li>将上一步得到的16位数与第三个数16进制的数相加，重复第二步，直到累加完所有的16进制数，并且得到的结果为16进制数。</li><li>将累加最后得到的16进制数取反，得到校验和。</li></ol><h1 id="四-可靠数据传输原理"><a class="markdownIt-Anchor" href="#四-可靠数据传输原理"></a> 四、可靠数据传输原理</h1><p><img src="/img/cn3.6.png" alt="提供的服务" /><br /><img src="/img/cn3.7.png" alt="服务实现" /></p><h2 id="41-构造可靠数据传输协议"><a class="markdownIt-Anchor" href="#41-构造可靠数据传输协议"></a> 4.1 构造可靠数据传输协议</h2><h3 id="411-rdt-10"><a class="markdownIt-Anchor" href="#411-rdt-10"></a> 4.1.1 rdt 1.0</h3><p>rdt1.0是基于<strong>理想情况</strong>下的协议，假设所有信道都是可靠的，没有比特位的翻转，没有数据包的丢失与超时，所以rdt1.0的传输功能就是发送方发送数据，接收方接受数据。<br /><img src="/img/cn3.8.png" alt="用于完全可靠信道的协议" /></p><h3 id="412-rdt-20"><a class="markdownIt-Anchor" href="#412-rdt-20"></a> 4.1.2 rdt 2.0</h3><p>rdt2.0在rdt1.0的基础上解决了比特位差错的问题，这里的比特位差错发生在运输层下面的不可信信道中数据包中的1可能会变0，0可能会变成1。</p><p>rdt2.0增加了3种新机制：</p><ul><li>差错检测</li><li>接收者反馈接受信息（ACK,NAK）</li><li>重传</li></ul><p>在运输层对应用层的数据进行打包处理时，新增checksum（校验和），从而接收端可以对其数据包进行检验，如果正确，返回ACK，发送者继续发送下一个数据包；如果不正确，返回NAK，发送者重传数据。</p><p><img src="/img/cn3.9.png" alt="" /><br /><img src="/img/cn3.10.png" alt="" /></p><p>但是rdt2.0有着一个致命的缺点，只考虑了发送方到接收方的数据传输，如果反馈信息ACK、NAK传输时发生比特位翻转会出现什么情况？如果ACK发生翻转，那么发送方会再次重复的发送相同的数据包；如果NAK发生翻转，那么发送方会认为数据传输情况很好，但是接收方却已经收到了一个错误的数据包。</p><h3 id="413-rdt-21"><a class="markdownIt-Anchor" href="#413-rdt-21"></a> 4.1.3 rdt 2.1</h3><p>在rdt2.0的基础之上，发送方在打包数据包时添加了0或者1编号，同样ACK,NAK字段上也添加了0、1字段，表示0、1号字段的确认或者否定。发送方就有了2种状态发送0号数据包，1号数据包，接收方也有了2种状态等待0号数据包和等待1号数据包。</p><blockquote><p>现在假设情景发送方向接收方发送0号数据包，如果接收方接收到0号数据包，返回ACK，但是ACK出现翻转，接收方处于等待1号数据状态，发送方重复发送0号数据，接收方会拒绝0号数据，避免重复。如果接收方接收到0号数据包出现错误，返回NAK，但是NAK出现翻转，接收方处于等待0号数据状态，发送方继续发送1号数据，接收方会拒绝1号数据，避免错序。</p></blockquote><h3 id="414-rdt-22"><a class="markdownIt-Anchor" href="#414-rdt-22"></a> 4.1.4 rdt 2.2</h3><p>dt2.2是在rdt2.1上的基础之上做了小小的改善，摒弃了NAK，只需采用ACK。我们在ACK的信息上加上了期望的顺序号。</p><blockquote><p>现在假设情景发送方向接收方发送0号数据包，如果接收方接收到0号数据包，返回（ACK，1），发送方接着发送1号数据包。如果接收方接收到0号数据包出现错误，返回（ACK，0），发送方重传0号数据包。</p></blockquote><p>rdt2.2之前的版本都重在处理数据包的<strong>比特位翻转</strong>情况，却没有考虑到数据包在传输过程中出现的<strong>数据包丢失</strong>问题，这样数据包丢失会使得网络处于拥塞状态。</p><h3 id="415-rdt-30"><a class="markdownIt-Anchor" href="#415-rdt-30"></a> 4.1.5 rdt 3.0</h3><p>rdt3.0在rdt2.2的基础之上处理了<strong>数据包丢失</strong>的情况，增加了<strong>计时器</strong>的机制，如果在RTT时间段内，发送方没有接收到反馈信息，那么发送方默认数据包已经丢失了，会自动重传。<br /><img src="/img/cn3.11.png" alt="" /><br /><img src="/img/cn3.12.png" alt="" /></p><h2 id="42-流水线可靠数据传输协议"><a class="markdownIt-Anchor" href="#42-流水线可靠数据传输协议"></a> 4.2 流水线可靠数据传输协议</h2><p>rdt 3.0性能不够，它的利用率很低：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mrow><mi>s</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>r</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">U_{sender}=\frac{L/R}{RTT+L/R} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>流水线可靠数据传输协议</strong> ：不使用停等方式，允许发送方发送多个分组而无需确认等待，这样会大大提升发送方信道的利用率。</p><p><img src="/img/cn3.13.png" alt="流水线可靠数据传输协议" /></p><ul><li><strong>必须增加序号范围</strong>，每个分组（不包含重传的）必须有唯一的序号<br />我们知道<strong>一个分组的序号存储在分组首部的固定长度字段</strong>中，序号字段长度为kbit,则该序号范围是[0,2^k-1].</li><li>发送方和接收方也需要能够<strong>缓存多个分组</strong><br />发送方：至少能够缓存那些已被发送但未被确认的分组</li><li>所需序号范围和缓存大小取决于协议是<strong>如何处理丢失、损坏及时延过大的分组</strong>，这里这类分组有两种方法：<strong>回退N步</strong>协议和<strong>选择重传</strong>协议</li></ul><h2 id="43-回退n步gbn或滑动窗口"><a class="markdownIt-Anchor" href="#43-回退n步gbn或滑动窗口"></a> 4.3 回退N步（GBN或滑动窗口）</h2><p>在GBN协议中，允许发送方发送多个分组而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p><p><img src="/img/cn3.14.png" alt="GBN中发送方看到的序号" /></p><p>通过基于ACK、无NAK的GBN协议的FSM图来了解GBN的原理：</p><p><img src="/img/cn3.15.png" alt="GBN发送方的扩展FSM描述" /><br /><img src="/img/cn3.16.png" alt="GBN接收方的扩展FSM描述" /></p><h2 id="44-选择重传sr协议"><a class="markdownIt-Anchor" href="#44-选择重传sr协议"></a> 4.4 选择重传（SR协议）</h2><p>GBN协议虽然实现了<strong>流水线式传输</strong>数据，提高了发送方信道的利用率,但是GBN有一个很大的缺陷就是一旦超时，会有许多<strong>不必要重传的分组</strong>被重新传送。尤其是当窗口长度N很大时，随着差错率的提升，信道中会充斥着不必要重传的分组。</p><p>SR协议原理：</p><ul><li><strong>发送方</strong>：<br />为每一个分组设置一个定时器，这样可以在某一个分组超时时对其单独进行重传。</li><li><strong>接收方</strong>：<br />SR接收方将确认一个正确接收的分组而不管其是否按序。在未出现分组丢失之前，正确接收到的分组都会被交付给上层。一旦出现分组丢失，失序的分组将被接收方<strong>缓存</strong>起来，直到所有丢失分组（即序号更小的分组）皆被接收为止，这时将缓存中的分组一起交付给上层。</li></ul><h1 id="五-面向连接的运输tcp"><a class="markdownIt-Anchor" href="#五-面向连接的运输tcp"></a> 五、面向连接的运输：TCP</h1><h2 id="51-tcp连接"><a class="markdownIt-Anchor" href="#51-tcp连接"></a> 5.1 TCP连接</h2><h3 id="511-tcp连接的特点"><a class="markdownIt-Anchor" href="#511-tcp连接的特点"></a> 5.1.1 TCP连接的特点</h3><ul><li><strong>面向连接</strong>：在一个应用进程可以开始向另一个应用进程发送数据之前，两个进程必须相互“握手”。</li><li><strong>全双工服务</strong>：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可在进程B流向进程A的同时，也从进程A流向进程B。</li><li><strong>点对点</strong>：在单个发送方与单个接收方之间的连接。</li></ul><h3 id="512-三次握手"><a class="markdownIt-Anchor" href="#512-三次握手"></a> 5.1.2 三次握手</h3><p>TCP是面向连接的，所以每次传输数据之前，必须要建立TCP连接，在TCP建立连接时主要解决三个层面问题：</p><ul><li>使连接的每一方都能确认对方的存在</li><li>协商连接中参数，比如各方窗口值，时间戳等</li><li>各方对运输资源如缓存大小、连接表等进行分配</li></ul><p><a href="/img/cn3.17.png">三次握手</a><br />默认情况下客户端client和服务端sever的TCP进程都处于<strong>CLOSED（关闭）状态</strong>。<br />服务端TCP服务进程先建立传输控制块TCB，然后服务端进入<strong>LISTEN状态</strong>，等待客户端连接请求。</p><ul><li><strong>第一次握手</strong>：客户端TCP进程也先建立传输控制块TCB，然后向服务端发送连接请求报文段，此时SYN=1,随机选定一个初始序号seq=x,，此报文不能携带数据，但是要消耗掉一个序号，发送完毕后，客户端进入SYN-SENT（同步已发送）状态</li><li><strong>第二次握手</strong>：服务端收到客户端请求连接报文段后，若同意建立连接，则发送确认报文，确认报文中SYN=1、ACK=1,确认号ack=x+1,同时随机选定一个自己序号seq=y,确认报文段同样不能携带数据，但是也要消耗掉一个序号，发送完毕后服务端进入SYN-RCVD（同步收到）状态</li><li><strong>第三次握手</strong>：客户端收到确认报文后，检查ACK=1，ack=x+1是否正确，若正确，则向服务端发送确认报文，确认报文中ACK=1,ack=y+1,seq=x+1,发送后进入ESTAB-LISHED状态，服务端收到确认报文后，也进入ESTAB-LISHED状态，此时双方TCP连接正式建立。</li></ul><p>上面的连接建立过程就是<strong>TCP三次握手</strong>。</p><h2 id="52-tcp报文段结构"><a class="markdownIt-Anchor" href="#52-tcp报文段结构"></a> 5.2 TCP报文段结构</h2>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用算法模板</title>
    <link href="/2022/03/31/Suanfa1/"/>
    <url>/2022/03/31/Suanfa1/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">DFS:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该DFS 框架以2D 坐标范围为例，来体现DFS 算法的实现思想。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100</span>;<br><span class="hljs-type">bool</span> vst[maxn][maxn]; <span class="hljs-comment">// 访问标记</span><br><span class="hljs-type">int</span> map[maxn][maxn]; <span class="hljs-comment">// 坐标范围</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 方向向量，(x,y)周围的四个方向</span><br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> <span class="hljs-comment">// 边界条件和约束条件的判断</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(!vst[x][y] &amp;&amp; ...) <span class="hljs-comment">// 满足条件</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">// 与约束条件冲突</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>vst[x][y]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 标记该节点被访问过</span><br><span class="hljs-keyword">if</span>(map[x][y]==G) <span class="hljs-comment">// 出现目标态G</span><br>&#123;<br>...... <span class="hljs-comment">// 做相应处理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">CheckEdge</span>(x+dir[i][<span class="hljs-number">0</span>],y+dir[i][<span class="hljs-number">1</span>])) <span class="hljs-comment">// 按照规则生成下一个节点</span><br><span class="hljs-built_in">dfs</span>(x+dir[i][<span class="hljs-number">0</span>],y+dir[i][<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有下层搜索节点，回溯</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>......<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100</span>;<br><span class="hljs-type">bool</span> vst[maxn][maxn]; <span class="hljs-comment">// 访问标记</span><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 方向向量</span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">State</span> <span class="hljs-comment">// BFS 队列中的状态数据结构</span><br>&#123;<br><span class="hljs-type">int</span> x,y; <span class="hljs-comment">// 坐标位置</span><br><span class="hljs-type">int</span> Step_Counter; <span class="hljs-comment">// 搜索步数统计器</span><br>&#125;;<br> <br>State a[maxn];<br> <br><span class="hljs-built_in">boolCheckState</span>(State s) <span class="hljs-comment">// 约束条件检验</span><br>&#123;<br><span class="hljs-keyword">if</span>(!vst[s.x][s.y] &amp;&amp; ...) <span class="hljs-comment">// 满足条件</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">// 约束条件冲突</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(State st)</span></span><br><span class="hljs-function"></span>&#123;<br>queue &lt;State&gt; q; <span class="hljs-comment">// BFS 队列</span><br>State now,next; <span class="hljs-comment">// 定义2 个状态，当前和下一个</span><br>st.Step_Counter=<span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器清零</span><br>q.<span class="hljs-built_in">push</span>(st); <span class="hljs-comment">// 入队</span><br>vst[st.x][st.y]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 访问标记</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>now=q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取队首元素进行扩展</span><br><span class="hljs-keyword">if</span>(now==G) <span class="hljs-comment">// 出现目标态，此时为Step_Counter 的最小值，可以退出即可</span><br>&#123;<br>...... <span class="hljs-comment">// 做相关处理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br>next.x=now.x+dir[i][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 按照规则生成下一个状态</span><br>next.y=now.y+dir[i][<span class="hljs-number">1</span>];<br>next.Step_Counter=now.Step_Counter+<span class="hljs-number">1</span>; <span class="hljs-comment">// 计数器加1</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">CheckState</span>(next)) <span class="hljs-comment">// 如果状态满足约束条件则入队</span><br>&#123;<br>q.<span class="hljs-built_in">push</span>(next);<br>vst[next.x][next.y]=<span class="hljs-number">1</span>; <span class="hljs-comment">//访问标记</span><br>&#125;<br>&#125;<br>q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 队首元素出队</span><br>&#125;<br> <span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>......<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02：应用层</title>
    <link href="/2022/03/28/Cn2/"/>
    <url>/2022/03/28/Cn2/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><blockquote><p><em><strong>纸上得来终觉浅，绝知此事要躬行。</strong></em></p></blockquote><h1 id="一-应用层协议原理"><a class="markdownIt-Anchor" href="#一-应用层协议原理"></a> 一、应用层协议原理</h1><p>研发网络应用程序的<strong>核心</strong>是写出能够运行在不同的端系统和通过网络彼此通信的程序。因此研发新应用时需要编写将在<strong>多台端系统</strong>上运行的软件。</p><h2 id="11-网络应用程序体系结构"><a class="markdownIt-Anchor" href="#11-网络应用程序体系结构"></a> 1.1 网络应用程序体系结构</h2><p><strong>应用程序体系结构</strong>（application architecture）明显不同于网络体系结构。网络体系结构是固定的，而应用程序体系结构由应用程序研发者设计。<br />应用程序体系结构目前有两种主流体系结构：<strong>客户-服务器体系结构</strong>或<strong>对等（P2P）体系结构</strong>。</p><h3 id="111-客户-服务器体系结构"><a class="markdownIt-Anchor" href="#111-客户-服务器体系结构"></a> 1.1.1 客户-服务器体系结构</h3><p>在客户-服务器体系结构中，有一个总是打开的主机称为<strong>服务器</strong>，它服务于来自许多其他称为<strong>客户</strong>的主机的请求。客户相互之间<strong>不直接通信</strong>。另一方面，该服务器具有固定的、周知的地址，该地址称为<strong>IP地址</strong>。</p><p><img src="/img/cn2.1.png" alt="客户-服务器体系结构" /></p><p>在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。为此，配备大量主机的<strong>数据中心</strong>常被用于创建强大的虚拟服务器。如谷歌在全球拥有30~50个数据中心。一个数据中心能够有数十万台服务器，它们必须要供电和维护。</p><h3 id="112-p2p体系结构"><a class="markdownIt-Anchor" href="#112-p2p体系结构"></a> 1.1.2 P2P体系结构</h3><p>在一个P2P体系结构中，对位于数据中心的专用服务器有最小的（或者没有）依赖。应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为<strong>对等方</strong>。因为这些对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的。<br /><img src="/img/cn2.2.png" alt="P2P体系结构" /></p><p>P2P最引人入胜的特性之一时自扩展性（self-scalability）。例如，在一个P2P共享文件中，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加服务能力。P2P体系结构也是成本有效的，因为它们通常不需要庞大的服务器基础设施和服务器带宽。</p><p>未来P2P应用面临三个主要挑战：<br />1 ISP友好。<br />2 安全性。<br />3 激励。</p><p>需要提及的是，某些应用具有<strong>混合</strong>的体系结构，它结合了客户-服务器和P2P的元素。例如，对于许多即时通信应用而言，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间（无需通过中间服务器）直接发送。</p><h2 id="12-进程通信"><a class="markdownIt-Anchor" href="#12-进程通信"></a> 1.2 进程通信</h2><p>在构建网络应用程序前，还需要对运行在多个端系统上的程序是如何互相通信有所了解。进行通信的实际上是<strong>进程</strong>（process）而不是程序。一个进程可以被认为是运行在端系统中的一个程序。</p><p>当进程运行在<strong>相同</strong>的端系统上时，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定。</p><p>在两个<strong>不同</strong>端系统上的进程，通过跨越计算机网络交换<strong>报文</strong>（message）而相互通信。<strong>发送进程</strong>生成并向网络中发送报文；<strong>接收进程</strong>接收这些报文并可能通过将报文发送回去进行响应。</p><h3 id="121-客户和服务器进程"><a class="markdownIt-Anchor" href="#121-客户和服务器进程"></a> 1.2.1 客户和服务器进程</h3><p>网络应用程序由成对的进程组成，这些进程通过网络相互发送报文。对每对通信进程，我i们通常将这两个进程之一标识为客户（client），而另一个进程标识为服务器（server）。</p><blockquote><p>在给定的一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程被标识为<strong>客户</strong>，在绘画开始时等待联系的进程是<strong>服务器</strong>。</p></blockquote><h3 id="122-进程与计算机网络之间的接口"><a class="markdownIt-Anchor" href="#122-进程与计算机网络之间的接口"></a> 1.2.2 进程与计算机网络之间的接口</h3><p>从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为<strong>套接字</strong>（socket）的软件接口向网络发送报文和从网络接收报文。</p><p>类比说明，进程类比为房子，套接字类比为门。一个进程向另一个房子发送报文就要将报文从门送出去，到另一个房子时再从门进去。</p><p><strong>套接字</strong>是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的<strong>应用程序编程接口</strong>（API）。应用程序开发者可以控制套接字在应用端的一切，但是对套接字在运输层端几乎没有控制权（仅限于①选择运输层协议；②也许能设定几个参数，如最大缓存和最大报文长度等）。<br /><img src="/img/cn2.3.png" alt="应用程序、套接字和下面的运输层协议" /></p><h3 id="123-进程寻址"><a class="markdownIt-Anchor" href="#123-进程寻址"></a> 1.2.3 进程寻址</h3><p>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个<strong>地址</strong>。为了标识该接收进程，需要定义两种信息：<br />——主机的地址；<br />——定义在目的主机中的接收进程的标识符。</p><p>在因特网中，主机由其IP地址标识。除此之外，发送进程还必须指定运行在接收主机上的接收进程（接收套接字）。目的地<strong>端口号</strong>（port number）用于这里，已经给流行的应用分配了特定的端口号。</p><h2 id="13-可供应用程序使用的运输服务"><a class="markdownIt-Anchor" href="#13-可供应用程序使用的运输服务"></a> 1.3 可供应用程序使用的运输服务</h2><p>在发送端的应用程序将报文推进给该套接字，在该套接字的另一侧，<strong>运输层协议</strong>负责使该报文进入接收进程的套接字。</p><p>包括因特网在内的很多网络提供了<strong>不止一种</strong>运输层协议。当开发一个应用时，必须要<strong>选择一种</strong>最能为你的应用需求提供恰当服务的协议。一个运输层协议能够为应用程序提供的服务可大体由四个方面进行分类：<strong>可靠数据传输</strong>、<strong>吞吐量</strong>、<strong>定时</strong>和<strong>安全性</strong>。</p><h3 id="131-可靠数据传输"><a class="markdownIt-Anchor" href="#131-可靠数据传输"></a> 1.3.1 可靠数据传输</h3><p>如果一个协议提供了确保数据交付的服务，就认为提供了<strong>可靠数据传输</strong>（reliable data transfer）。当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据能无差错地到达接收进程。</p><p>当一个运输层协议不提供可靠数据传输时，由发送进程发送地某些数据可能不能够到达接收进程。这可能被<strong>容忍丢失的应用</strong>（loss-tolerant application）所接受，如一些多媒体应用。</p><h3 id="132-吞吐量"><a class="markdownIt-Anchor" href="#132-吞吐量"></a> 1.3.2 吞吐量</h3><p>在沿着一条网络路径上的两个进程之间的通信会话场景中，<strong>可用吞吐量</strong>就是发送进程能够向接收进程交付比特的速率。因为其他会话将共享沿着该网络路径的带宽，并且因为这些会话将会到达和离开，该可用吞吐量将随时间波动。由此衍生出一种服务，即运输层协议能够以某种特定的速率提供<strong>确保</strong>的可用吞吐量。使用这种服务，应用程序能够请求r比特/秒的确保吞吐量，并且该运输协议能够确保可用吞吐量总是为至少r比特/秒。</p><p>具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong>（bandwidth-sensitive application），例如许多多媒体应用。<strong>弹性应用</strong>（elastic application）能够根据情况或多或少地利用可供使用的吞吐量，例如电子邮件、文件传输等。</p><h3 id="133-定时"><a class="markdownIt-Anchor" href="#133-定时"></a> 1.3.3 定时</h3><p>运输层协议也能够提供<strong>定时保证</strong>。如同具有吞吐量保证那样，定时保证能够以多种形式实现，咯如，发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。</p><p>这种服务对<strong>交互式实时应用程序</strong>有很大吸引力。对于非实时的应用，较低的时延总比较高的时延好，但对端到端的时延没有严格的约束。</p><h3 id="134-安全性"><a class="markdownIt-Anchor" href="#134-安全性"></a> 1.3.4 安全性</h3><p>运输层协议能够为应用程序提供一种或多种<strong>安全性服务</strong>。这种服务将在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。<br />例如，在<strong>发送主机</strong>中，运输协议能够<strong>加密</strong>由发送进程传输的所有数据；<br />在<strong>接受主机</strong>中，运输层协议能够在将数据交付给接收进程之前<strong>解密</strong>这些数据。</p><p>此外，运输协议还能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别。</p><h2 id="14-因特网提供的运输服务"><a class="markdownIt-Anchor" href="#14-因特网提供的运输服务"></a> 1.4 因特网提供的运输服务</h2><p>因特网（更一般的是TCP/IP网络）为应用程序提供两个运输层协议，即<strong>UDP</strong>和<strong>TCP</strong>。软件开发者为因特网创建新的应用时，首先要选择<strong>UDP</strong>或者<strong>TCP</strong>。每个协议为调用它们的应用程序提供了不同的服务集合。</p><h3 id="141-tcp服务"><a class="markdownIt-Anchor" href="#141-tcp服务"></a> 1.4.1 TCP服务</h3><p>TCP服务模型包括面向连接服务和可靠数据传输服务。</p><p>1 <strong>面向连接的服务</strong><br />在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的<strong>握手</strong>过程提示客户和服务器，使它们为大量分组的到来做好准备。</p><p>在握手阶段后。一个<strong>TCP连接</strong>（TCP connection）就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。</p><p>当应用程序结束报文发送时，必须拆除该连接。</p><p>2 <strong>可靠的数据传送服务</strong><br />通信进程能够依靠TCP，<strong>无差错、按适当顺序</strong>交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而<strong>没有字节的冗余和丢失</strong>。</p><p>除此之外，TCP协议还具有<strong>拥塞控制机制</strong>。当发送方和接收方之间的网络出现拥塞时，它会抑制发送进程（客户或服务器）。这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。TCP拥塞控制也试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。</p><h3 id="142-udp服务"><a class="markdownIt-Anchor" href="#142-udp服务"></a> 1.4.2 UDP服务</h3><p>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无线连接的，因此在两个进程通信前没有握手过程。UDP服务提供一种不可靠数据传送服务，并且没有拥塞控制机制。</p><h3 id="143-因特网运输协议所不提供的服务"><a class="markdownIt-Anchor" href="#143-因特网运输协议所不提供的服务"></a> 1.4.3 因特网运输协议所不提供的服务</h3><p>TCP提供了可靠的端到端数据传送，在应用层也可以很容易地用SSL来加强以提供安全服务。今天的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证。</p><h2 id="15-应用层协议"><a class="markdownIt-Anchor" href="#15-应用层协议"></a> 1.5 应用层协议</h2><p><strong>应用层协议</strong>（application-layer protrol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p><blockquote><p>特别是应用层协议定义了：<br />1 交换的报文<strong>类型</strong>，例如请求报文和响应报文<br />2 各种报文类型的<strong>语法</strong>，如报文中的各个字段及这些字段是如何描述的。<br />3 字段的<strong>语义</strong>，即这些字段中包含的信息的含义。<br />4 一个进程何时以及如何发送报文，对报文进行相应的<strong>规则</strong>。</p></blockquote><p>有些应用层协议是由RFC文档定义的，因此它们位于<strong>公共域</strong>中，例如HTTP。还有很多应用层协议是<strong>专用</strong>的，有意不为公共域使用。</p><p>应用层协议是网络应用的<strong>一部分</strong>。</p><h1 id="二-web和http"><a class="markdownIt-Anchor" href="#二-web和http"></a> 二、Web和HTTP</h1><p>在20世纪90年代初期，一个主要的新型应用即<strong>万维网</strong>（World Wide Web）登上舞台，它极大地改变了人们与工作环境内外交流的方式。对大多数用户而言，Web最具吸引力的是它的<strong>按需操作</strong>，即用户能看到想看的内容。</p><h2 id="21-http概况"><a class="markdownIt-Anchor" href="#21-http概况"></a> 2.1 HTTP概况</h2><p>Web的应用层协议是<strong>超文本运输协议</strong>（HTTP),它是Web的核心。HTTP由两个程序实现：一个客户和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p><p><strong>Web页面</strong>（也叫文档）是由<strong>对象</strong>组成的。一个<strong>对象</strong>（object）只是一个文件，诸如一个HTML文件、一个JPEG图形、一个Java小程序或一个视频片段这样的文件，且它们可通过一个URL地址寻址。每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名。</p><blockquote><p>例如，URL地址http://www.someSchool.edu/someDepartment/picture.gif中www.someSchool.edu就是主机名，/someDepartment/picture.gif就是路径名。</p></blockquote><p>Web<strong>浏览器</strong>实现了HTTP的客户端，所以被称为浏览器或客户；<br />Web<strong>服务器</strong>实现了HTTP的服务器端，它用于存储Web对象，每个对象由URL寻址。</p><p>HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。当用户请求一个Web页面时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。<br /><img src="/img/cn2.4.png" alt="HTTP的请求-响应行为" /></p><p>HTTP使用<strong>TCP</strong>作为它的支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制。</p><p>HTTP是一个<strong>无状态协议</strong>（stateless protrol），即不保存关于客户的任何信息。Web是一个<strong>客户-服务器体系结构</strong>。</p><h2 id="22-非持续连接和持续连接"><a class="markdownIt-Anchor" href="#22-非持续连接和持续连接"></a> 2.2 非持续连接和持续连接</h2><p>在许多因特网应用程序中，客户发出一系列请求并且服务器对每个请求进行响应。<strong>非持续连接</strong>是指每个请求/响应经一个单独的TCP发送，<strong>持续连接</strong>指所有的请求/响应经相同的TCP发送。</p><p>以<strong>HTTP</strong>举例研究持续连接和非持续连接的<strong>优缺点</strong>。</p><h3 id="221-采用非持续连接的http"><a class="markdownIt-Anchor" href="#221-采用非持续连接的http"></a> 2.2.1 采用非持续连接的HTTP</h3><p>在<strong>非持续连接</strong>的情况下，从服务器向客户传送一个Web页面的<strong>步骤</strong>，假设该页面含有一个HTML基本页面和10个JPEG图形，并且这11个对象位于同一台服务器上。该HTML文件的URL为：</p><blockquote><p><a href="http://www.someSchool.edu/someDepartment/home.index">http://www.someSchool.edu/someDepartment/home.index</a></p></blockquote><ol><li>HTTP<strong>客户进程</strong>在端口号80发起一个到服务器www.someSchool.edu的TCP连接，该端口号是HTTP的默认端口。</li><li>HTTP<strong>客户</strong>经它的<strong>套接字</strong>向该服务器发送一个HTTP请求报文。请求报文中包含了<strong>路径名</strong>/someDepartment/home.index</li><li>HTTP<strong>服务器进程</strong>经它的<strong>套接字</strong>向该服务器发送一个HTTP请求报文。从其<strong>存储器</strong>（RAM或磁盘）<a href="http://xn--www-u68dv7oy4rf8uyi1byx2a.someSchool.edu/someDepartment/home.index%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AAHTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E4%B8%AD">中检索出对象www.someSchool.edu/someDepartment/home.index，在一个HTTP响应报文中</a><strong>封装</strong>对象，并通过其套接字向客户发送<strong>响应</strong>报文。</li><li>HTTP<strong>服务器进程</strong>通知TCP断开该TCP连接。</li><li>HTTP<strong>客户</strong>接收响应报文，TCP连接关闭。该报文指出封装的对象是一个HTML文件，客户从响应报文中提取出该文件，检查该HTML文件，得到对10个JPEG图形的<strong>引用</strong>。</li><li>对每个引用的JPEG图形对象<strong>重复</strong>前4个步骤。</li></ol><p>其中每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。每个TCP连接只传输一个请求报文和一个响应报文，因此在本例中要产生11个TCP连接。</p><p>其中这10个JPEG图形对象是使用10个串行的TCP连接，还是某些JPEG对象使用了一些并行的TCP连接，这可以由用户通过配置浏览器进行控制。</p><p><strong>往返时间</strong>（RTT）是指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p><p>当浏览器和Web服务器之间发起一个TCP连接时，会涉及一次”<strong>三次握手</strong>“过程：</p><ol><li>客户向服务器发送一个小TCP报文段</li><li>服务器用一个小TCP报文段做出确认和响应</li><li>客户向服务器返回确认</li></ol><p>三次握手中前两个部分占用了一个RTT。完成前两个部分后，客户结合三次握手的第三部分向该TCP连接发送一个HTTP请求报文，一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。该HTTP请求/响应占用了一个RTT。因此，总的响应时间就是<strong>两个RTT加上服务器传输HTML文件的时间</strong>。<br /><img src="/img/cn2.5.png" alt="三次握手过程" /></p><h3 id="222-采用持续连接的http"><a class="markdownIt-Anchor" href="#222-采用持续连接的http"></a> 2.2.2 采用持续连接的HTTP</h3><p>非持续连接有两个缺点：</p><ol><li><p>必须为每一个请求的对象建立和维护一个全新的TCP连接。对于每个连接，客户和服务器都要分配TCP的缓冲区和保持TCP变量。</p></li><li><p>每一个对象要经受两倍RTT的交付时延。</p><p>在采用持续连接时，服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。一般来说，如果一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，HTTP服务器就关闭该连接。</p></li></ol><h2 id="23-http报文格式"><a class="markdownIt-Anchor" href="#23-http报文格式"></a> 2.3 HTTP报文格式</h2><p>HTTP规范包含了对HTTP报文格式的定义。HTTP报文有两种：请求报文和响应报文。</p><h3 id="231-http请求报文"><a class="markdownIt-Anchor" href="#231-http请求报文"></a> 2.3.1 HTTP请求报文</h3><blockquote><p>下面提供一个<strong>典型</strong>的HTTP请求报文：<br />GET /somedir/page.html HTTP/1.1<br />Host: <a href="http://www.someschool.edu">www.someschool.edu</a><br />Connection: close<br />User-agent: Mozilla/5.0<br />Accept-language: fr</p></blockquote><p>HTTP请求报文的第一行叫做<strong>请求行</strong>（request line），其后继的行叫做<strong>首部行</strong>（header line）。</p><p>1 <strong>请求行</strong><br />有3个字段：<strong>方法字段</strong>、<strong>URL字段</strong>和<strong>HTTP版本字段</strong>。方法字段可以取几种不同的值，包括GET、POST、HEAD、PUT和DELETE，绝大部分采用GET方法。</p><p>2 <strong>首部行</strong><br /><strong>Host: <a href="http://www.someschool.edu">www.someschool.edu</a></strong>，指明了对象所在的主机。<br /><strong>Connection: close</strong>，浏览器告诉服务器不使用持续连接。<br /><strong>User-agent</strong>，用来指明用户代理，即向服务器发送请求的浏览器的类型。<br /><strong>Accept-language</strong>，表示用户想得到该对象的法语版本（如果服务器中有），否则发送默认版本。</p><p>在首部行后有一个“<strong>实体体</strong>”（entire body）。使用GET方法时实体体为空，在使用<strong>POST方法</strong>时使用。例如当用户在搜索引擎搜索关键词时，实体体包含的就是用户在表单字段的输入值。</p><p><img src="/img/cn2.6.png" alt="一个HTTP请求报文的通用格式" /></p><p>用表单生成的请求报文不是必须使用<strong>POST方法</strong>，HTML表单经常使用GET方法，并在所请求的URL中包括输入的数据。<a href="http://xn--www-uc0ep96b.somesite.com/animalsearch?monkeys&amp;bananas%E3%80%82">例如www.somesite.com/animalsearch?monkeys&amp;bananas。</a></p><p><strong>HEAD方法</strong>类似于GET方法，当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但不返回对象。应用程序开发者经常使用HEAD方法进行调试跟踪。</p><p><strong>PUT方法</strong>常与Web发行工具联合使用，它允许用户上传对象到指定的Web服务器上指定的路径（目录）。同时，它也被那些需要向Web服务器上传对象的应用程序使用。</p><p><strong>DELETE方法</strong>允许用户或者应用程序删除Web服务器上的对象。</p><h3 id="232-http响应报文"><a class="markdownIt-Anchor" href="#232-http响应报文"></a> 2.3.2 HTTP响应报文</h3><blockquote><p>下面提供一条典型的HTTP响应报文，它是对上面请求报文的响应<br />HTTP:/1.1 200 OK<br />Connection: close<br />Data: Tue, 09 Aug 2011 15:44:04 GMT<br />Server: Apache/2.2.3 (CentOS)<br />Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT<br />Content-Length: 6821<br />Content-Type: text/html<br />(空行）<br />(data data data data…)</p></blockquote><p>1 <strong>状态行</strong>（第1行）<br />状态行有3个字段：<strong>协议版本字段</strong>、<strong>状态码</strong>和<strong>相应状态信息</strong>。这里指示服务器正在使用HTTP/1.1，并且一切正常。</p><p>2 <strong>首部行</strong>（2~7行）<br /><strong>Connection: close</strong> 告诉客户发送完报文后将关闭该TCP连接；<br /><strong>Date</strong> 指示服务器产生并发送该响应报文的日期和时间；<br /><strong>Server</strong> 指示该报文是由一台Apache Web服务器产生的，类似于请求报文中的User-agent；<br /><strong>Last-Modified</strong> 指示了对象创建或者最后修改的日期和时间，它对对象缓存（既可能在本地客户也可能在网络缓存服务器上）非常重要；<br /><strong>Content-Length</strong> 指示了被发送对象中的字节数；<br /><strong>Content-Type</strong> 指示了实体体中的对象是HTML文本。</p><p>3 <strong>实体体</strong>：报文的主要部分（data data data…）。</p><p><img src="/img/cn2.7.png" alt="一个HTTP响应报文的通用格式" /></p><h2 id="24-用户与服务器的交互cookie"><a class="markdownIt-Anchor" href="#24-用户与服务器的交互cookie"></a> 2.4 用户与服务器的交互：cookie</h2><p>cookie在[RFC 6265]中定义，它允许站点对用户进行跟踪。</p><p>cookie技术有4个组件：</p><ol><li>在HTTP响应报文中的一个cookie首部行；</li><li>在HTTP请求报文中的一个cookie首部行；</li><li>在用户端系统中保留有一个cookie文件，由用户的浏览器进行管理；</li><li>位于Web站点的一个后端数据库。</li></ol><p><img src="/img/cn2.8.png" alt="cookie跟踪用户状态" /></p><p>cookie可以用于<strong>标识</strong>一个用户。用户首次访问一个站点时，可能需要提供一个用户标识。在后继会话中，浏览器向服务器传递一个cookie首部，从而向该服务器标识了用户。因此cookie可以在无状态的HTTP之上建立一个用户<strong>会话层</strong>。</p><h2 id="25-web缓存"><a class="markdownIt-Anchor" href="#25-web缓存"></a> 2.5 Web缓存</h2><p><strong>Web缓存器</strong>（Web cache）也叫<strong>代理服务器</strong>（proxy server），它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘<strong>存储空间</strong>，并在存储空间中保存最近请求过的对象的<strong>副本</strong>。</p><p>假设浏览器正在请求一个对象，将会发生如下情况：</p><ol><li>浏览器<strong>建立</strong>一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。</li><li>Web缓存器进行<strong>检查</strong>，看看本地是否存储了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象。</li><li>如果Web缓存器中没有该对象，它就打开一个与该对象的<strong>初始服务器</strong>的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应。</li><li>当Web缓存器接收到该对象时，它在本地存储空间存储一份<strong>副本</strong>，并向客户的浏览器用HTTP<strong>响应报文</strong>发送该副本（通过已有的TCP连接）。</li></ol><p>所以Web缓存器是<strong>服务器</strong>同时又是<strong>客户</strong>。它通常由<strong>ISP</strong>购买并安装。</p><p>部署Web缓存器的<strong>原因</strong>：</p><ul><li>它可以大大减少对客户请求的响应时间。</li><li>它能够大大减少一个机构的接入链路到因特网的通信量。</li><li>它从整体上大大减低因特网上的Web流量，从而改善了所有应用的性能。</li></ul><p>通过使用<strong>内容分发网络</strong>（CDN），Web缓存器正在因特网中发挥着越来越重要的作用。CDN公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。</p><h2 id="26-条件get方法"><a class="markdownIt-Anchor" href="#26-条件get方法"></a> 2.6 条件GET方法</h2><p>为了解决存放在缓存器中的对象副本可能已经<strong>陈旧</strong>的问题，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。它就是<strong>条件GET方法</strong>。</p><p>如果</p><ul><li>请求报文使用GET方法</li><li>请求报文中包含一个&quot;if-Modified-Since:&quot;首部行</li></ul><p>那么，这个HTTP请求报文就是一个条件GET请求报文。</p><h1 id="三-文件传输协议ftp"><a class="markdownIt-Anchor" href="#三-文件传输协议ftp"></a> 三、文件传输协议：FTP</h1><h2 id="31-ftp传输的过程"><a class="markdownIt-Anchor" href="#31-ftp传输的过程"></a> 3.1 FTP传输的过程</h2><p>在一个典型的FTP会话中，用户坐在一台主机前面，向一台远程主机传输文件。为使用户能访问它的远程账户，用户必须提供一个<strong>用户标识和口令</strong>。用户通过一个<strong>FTP用户代理</strong>与<strong>FTP</strong>交互。</p><p>具体步骤如下：</p><ol><li>用户首先提供远程主机的<strong>主机名</strong>，使本地主机的FTP客户进程建立一个到远程主机FTP服务器进程的<strong>TCP连接</strong>。</li><li>用户接着提供<strong>用户标识和口令</strong>，作为FTP命令的一部分在该TCP连接上传送。</li><li>一旦该服务器向该用户<strong>授权</strong>，用户可以将存放在本地文件系统中的一个或多个文件复制到远程文件系统（反之亦然）。</li></ol><h2 id="32-http和ftp的对比"><a class="markdownIt-Anchor" href="#32-http和ftp的对比"></a> 3.2 HTTP和FTP的对比</h2><h3 id="321-共同点"><a class="markdownIt-Anchor" href="#321-共同点"></a> 3.2.1 共同点</h3><ul><li>都是文件传输协议</li><li>都运行在TCP上</li></ul><h3 id="322-不同点"><a class="markdownIt-Anchor" href="#322-不同点"></a> 3.2.2 不同点</h3><ul><li>FTP使用了两个并行的TCP连接来传输文件，一个是<strong>控制连接</strong>（control connection），一个是<strong>数据连接</strong>（data connection）。<strong>控制连接</strong>用于在主机之间传输控制信息，如用户标识、口令、文件命令等。<strong>数据连接</strong>用于实际发送一个文件。我们称FTP是<strong>带外连接</strong>（独立的控制连接）的。HTTP是在传输文件的同一个TCP连接中发送请求和响应首部行的。因此，HTTP是<strong>带内连接</strong>的。</li><li>FTP服务器必须在整个会话期间保留用户的<strong>状态</strong>（state）。服务器必须把特定的用户账户与控制连接联系起来，大大限制了FTP同时维持的会话总数。HTTP是<strong>无状态</strong>的，它不必对任何用户状态进行跟踪。</li></ul><p>对FTP而言，<strong>控制连接</strong>贯穿了整个用户会话期间，但是对会话中的每一次文件传输都需要建立一个新的<strong>数据连接</strong>（即数据连接是非持续的）。</p><h2 id="33-ftp命令和回答"><a class="markdownIt-Anchor" href="#33-ftp命令和回答"></a> 3.3 FTP命令和回答</h2><p>详见 RFC959</p><h1 id="四-因特网中的电子邮件"><a class="markdownIt-Anchor" href="#四-因特网中的电子邮件"></a> 四、因特网中的电子邮件</h1><h2 id="41-因特网电子邮件系统和它的关键组件"><a class="markdownIt-Anchor" href="#41-因特网电子邮件系统和它的关键组件"></a> 4.1 因特网电子邮件系统和它的关键组件</h2><p>因特网电子邮件系统有3个主要组成部分：<strong>用户代理</strong>（user agent）、<strong>邮件服务器</strong>（mail server）和<strong>简单邮件传输协议</strong>（SMTP）。</p><p>1 <strong>用户代理</strong>允许用户阅读、回复、转发、保存和撰写报文。当发送方完成邮件撰写时，<strong>邮件代理</strong>向其<strong>邮件服务器</strong>发送邮件，此时邮件放在<strong>邮件服务器</strong>的外出报文队列中。</p><p>2 <strong>邮件服务器</strong>形成了电子邮件体系结构的核心。每个接收方在其中的某个<strong>邮件服务器</strong>上有一个<strong>邮箱</strong>（mailbox），<strong>邮箱</strong>管理和维护着发送给用户的报文。当用户要在他的<strong>邮箱</strong>中读取该报文时，包含他邮箱的<strong>邮件服务器</strong>要鉴别用户。</p><p>如果发送方的服务器不能将邮件交付给接收方的服务器，发送方的邮件服务器在一个<strong>报文队列</strong>（message queue）中保持该报文并在以后尝试再次发送。通常每30分钟进行一次尝试，如果几天后仍不能成功，服务器就删除该报文并以电子邮件的形式通知发送方。</p><p>3 <strong>SMTP</strong>是因特网电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。SMTF也有两个部分：运行在发送方邮件服务器的<strong>客户端</strong>和接收方邮件服务器的<strong>服务器端</strong>。</p><h2 id="42-smtp"><a class="markdownIt-Anchor" href="#42-smtp"></a> 4.2 SMTP</h2><p>SMTP是因特网电子邮件应用的核心，用于从发送方的邮件服务器发送报文到接收方的邮件服务器。</p><p>假设Alice想给Bob发送一封简单的ASCII报文：</p><ol><li>Alice调用她的<strong>邮件代理</strong>程序并提供Bob的邮件地址，撰写报文，然后指示<strong>用户代理</strong>发送该报文。</li><li>Alice的<strong>用户代理</strong>把报文发给他的<strong>邮件服务器</strong>，在那里该报文被放在<strong>报文队列</strong>中。</li><li>运行在Alice的<strong>邮件服务器</strong>上的<strong>SMTP客户端</strong>发现了<strong>报文队列</strong>中的这个报文，它就创建一个到运行在Bob的邮件服务器上的<strong>SMTP服务器</strong>的<strong>TCP连接</strong>。</li><li>在经过一些初始SMTF握手后，SMTP客户通过该<strong>TCP连接</strong>发送Alice的报文。</li><li>在Bob的<strong>邮件服务器</strong>上，SMTP的服务器端接收该报文。Bob的<strong>邮件服务器</strong>将该报文放入Bob的<strong>邮箱</strong>中。</li><li>在Bob方便的时候，他调用<strong>用户代理</strong>阅读该报文。</li></ol><p>SMTP一般不使用中间服务器发送邮件。而且它用的是持续连接，通过同一个TCP连接发送所有报文。</p><h2 id="43-http和smtp的对比"><a class="markdownIt-Anchor" href="#43-http和smtp的对比"></a> 4.3 HTTP和SMTP的对比</h2><h3 id="431-共同点"><a class="markdownIt-Anchor" href="#431-共同点"></a> 4.3.1 共同点</h3><ul><li>都用于从一台主机向另一台主机传送文件。</li><li>进行文件发送时，二者都使用<strong>持续连接</strong>。</li></ul><h3 id="432-不同点"><a class="markdownIt-Anchor" href="#432-不同点"></a> 4.3.2 不同点</h3><p><strong>一、</strong></p><ul><li>HTTP主要是一个<strong>拉协议</strong>（pull protocol），即在方便的时候，用户使用HTTP从服务器拉取这些信息。TCP由想接收文件的机器发起的。</li><li>SMTP基本是一个<strong>推协议</strong>（push protocol），即发送邮件服务器把文件推向接收邮件服务器。TCP由要发送该文件的机器发起。</li></ul><p><strong>二、</strong></p><ul><li>SMTP要求每个报文使用<strong>7比特ASCII码</strong>格式。如果文件包含非7比特ASCII字符，则必须要按照7比特ASCII码进行编码。</li><li>HTTP没有格式限制。</li></ul><p><strong>三、</strong></p><ul><li>在处理一个既包含文本又包含图形（或其他）的文档时，HTTP把每个对象<strong>封装</strong>到响应报文中。</li><li>SMTP把所有报文对象放在一个报文之中。</li></ul><h2 id="44-邮件报文格式和mime"><a class="markdownIt-Anchor" href="#44-邮件报文格式和mime"></a> 4.4 邮件报文格式和MIME</h2><p>当发送电子邮件时，一个包含<strong>环境信息</strong>的首部位于报文体前面。这些<strong>环境信息</strong>包括在一系列<strong>首部行</strong>中，这些行由RFC 5322定义。注意这里的首部行不同于SMTP命令，SMTP命令是握手协议的一部分。</p><blockquote><p>一个典型的报文首部如下：<br />From: <a href="mailto:alice@crepes.fr">alice@crepes.fr</a><br />To: <a href="mailto:bob@hamburger.edu">bob@hamburger.edu</a><br />Subject: Searching for the meaning of life</p></blockquote><h2 id="45-邮件访问协议"><a class="markdownIt-Anchor" href="#45-邮件访问协议"></a> 4.5 邮件访问协议</h2><p>目前用户是通过在用户端系统上运行的客户程序来阅读电子邮件。用户通常在本地PC上运行一个<strong>用户代理程序</strong>，它访问存储在总是保持开机的<strong>共享邮件服务器</strong>（由用户的ISP维护）上的邮箱。</p><p>为了接收方能够通过<strong>用户代理</strong>获得<strong>某ISP</strong>上的<strong>邮件服务器</strong>上的邮件，目前有一些流行的邮件访问协议，包括<strong>第三版的邮局协议</strong>（POP3）、<strong>因特网邮件访问协议</strong>（IMAP）和<strong>HTTP</strong>。</p><p><img src="/img/cn2.9.png" alt="电子邮件协议及其通信实体" /></p><h3 id="451-pop3"><a class="markdownIt-Anchor" href="#451-pop3"></a> 4.5.1 POP3</h3><p>POP3是一个<strong>极为简单、功能相当有限</strong>的邮件访问协议，由RFC1939定义。随着建立TCP连接，POP3按照三个阶段进行工作：</p><ol><li><strong>特许</strong>（authorization）<br />用户代理发送（以明文形式）用户名和口令以鉴别用户。</li><li><strong>事务处理</strong><br />用户代理取回报文，还能对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。</li><li><strong>更新</strong><br />出现在客户发出quit命令之后，结束该POP3会话。同时，该邮件服务器删除哪些被标记为删除的报文。</li></ol><h3 id="452-imap"><a class="markdownIt-Anchor" href="#452-imap"></a> 4.5.2 IMAP</h3><p>略</p><h3 id="453基于web的电子邮件"><a class="markdownIt-Anchor" href="#453基于web的电子邮件"></a> 4.5.3基于Web的电子邮件</h3><p>略</p><h1 id="五-dns因特网的目录服务"><a class="markdownIt-Anchor" href="#五-dns因特网的目录服务"></a> 五、DNS：因特网的目录服务</h1><p>因特网上的主机可以使用多种方式进行标识，其中的一种标识方法是<strong>主机名</strong>（hostname）。然而，主机名几乎没有提供关于主机在因特网中位置的信息，而且以不定长的字母数字组成，路由器难以处理。由于这些原因，主机也使用<strong>IP地址</strong>（IP address）进行标识。</p><blockquote><p>一个IP地址由四个字节组成，并有着严格的层次结构，如121.7.106.83，其中的每个字节都被句点分隔开，表示了0~255的十进制数字。当从左至右扫描它时，会得到越来越具体的关于主机位于因特网何处的信息。</p></blockquote><h2 id="51-dns提供的服务"><a class="markdownIt-Anchor" href="#51-dns提供的服务"></a> 5.1 DNS提供的服务</h2><p><strong>域名系统</strong>（DNS）的主要任务是进行主机名到IP地址转换的<strong>目录服务</strong>。</p><blockquote><p>DNS是：<br />①一个由分层的DNS服务器（DNS server）实现的分布式数据库<br />②一个使得主机能够查询分布式数据库的应用层协议。</p></blockquote><p>DNS通常是由其他应用层协议所使用的（不直接面向用户），包括HTTP、SMTP和FTP，将用户提供的主机名解析为IP地址。例如，当用户要将一个HTTP请求报文发送到Web服务器时，必须要获得该网页的IP地址：</p><ul><li>同一台用户主机上运行着DNS应用的客户端。</li><li>浏览器从URL抽取出主机名，并将主机名传给DNS应用的客户端。</li><li>DNS客户向DNS服务器发送一个包含主机名的请求。</li><li>DNS客户最终会收到一份回答报文，其中含有对应于该主机名的IP地址。</li><li>一旦浏览器接收到该IP地址，它能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接。</li></ul><p>DNS将会为因特网应用带来大量<strong>时延</strong>。目前想获得的IP地址通常就<strong>缓存</strong>在“附近的”DNS服务器中，这有助于减少DNS的网络流量和平均时延。</p><p>除了上述的主机名到IP地址的转换，DNS还提供了一些重要的服务：</p><ul><li>主机别名</li><li>邮件服务器别名</li><li>负债分配</li><li>……</li></ul><p>DNS由RFC定义，它是一个复杂的系统，这里不再详述。</p><h2 id="52-dns工作机理概述"><a class="markdownIt-Anchor" href="#52-dns工作机理概述"></a> 5.2 DNS工作机理概述</h2><p>从用户之际上调用应用程序的角度看，DNS是一个提供简单、直接的转换服务的黑盒子，事实上它的构造非常复杂。<strong>DNS由分布于全球的大量DNS服务器以及定义了DNS服务器与查询主机通信方式的应用层协议组成</strong>。</p><p>采用单一DNS服务器（集中式设计）会有如下问题：</p><ul><li><strong>单点故障</strong>（a single point of failure）</li><li><strong>通信容量</strong>（traffic volume）</li><li><strong>远距离的集中式数据库</strong>（distant centralized database）</li><li><strong>维护</strong>（maintenance）</li></ul><p>因此，DNS采用了分布式的设计方案。</p><h3 id="521-分布式-层次数据库"><a class="markdownIt-Anchor" href="#521-分布式-层次数据库"></a> 5.2.1 分布式、层次数据库</h3><p>DNS使用了大量DNS服务器，它们以<strong>层次</strong>方式组织，并且分布在全世界范围内。<strong>没有一台DNS服务器拥有因特网上所有主机的映射，该映射分布在所有的DNS服务器上</strong>。</p><p>大致说来，有三种类型的DNS服务器：</p><ul><li><strong>根DNS服务器</strong><br />在因特网上有<strong>13</strong>个根DNS服务器（标号从A到M），大部分位于北美洲。为了提高安全性和可靠性，每台“服务器”实际上是一个<strong>服务器网络</strong>。</li><li><strong>顶级域（TLD）DNS服务器</strong><br />这些服务器负责<strong>顶级域名</strong>，如com、org、net、edu等以及所有<strong>国家的顶级域名</strong>。</li><li><strong>权威DNS服务器</strong><br />在因特网上具有<strong>公共可访问主机</strong>（如Web服务器和邮件服务器）的组织（机构）必须提供公共可访问的<strong>DNS记录</strong>，这些记录将这些主机的名字映射为IP地址。这个组织（机构）能够选择实现<strong>自己的</strong>权威DNS服务器收藏这些DNS记录，也可以选择将这些记录存储在<strong>第三方的</strong>权威DNS服务器中。</li></ul><p><img src="/img/cn2.10.png" alt="DNS服务器的部分层次结构" /></p><p>除了在层次结构中的三种DNS服务器，还有一类，叫做<strong>本地DNS服务器</strong>，它起到一个<strong>代理</strong>的作用。对于某居民区ISP，本地DNS服务器通常与主机相隔很近。</p><p><img src="/img/cn2.11.png" alt="各种DNS服务器的交互" /></p><p>主机、服务器之间的查询有两种形式：</p><ul><li><strong>递归查询</strong>。在该模式下DNS 服务器接收到客户机请求，必须使用一个<strong>准确的查询结果</strong>回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。客户机和服务器之间的查询是递归查询。<br /><strong>递归查询告诉客户机IP地址</strong></li><li><strong>迭代查询</strong>。DNS 服务器会向客户机提供其他能够解析查询请求的<strong>DNS 服务器地址</strong>，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果为止。<br /><strong>服务器之间的查询是迭代查询</strong></li></ul><h3 id="522-dns缓存"><a class="markdownIt-Anchor" href="#522-dns缓存"></a> 5.2.2 DNS缓存</h3><p>为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了<strong>缓存</strong>技术。在一个请求链中，当某DNS服务器接收一个DNS回答时，它能将该回答中的信息缓存在本地存储器中。由于主机和和主机名与IP地址的映射不是永久的，DNS服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。</p><h2 id="53-dns记录和报文"><a class="markdownIt-Anchor" href="#53-dns记录和报文"></a> 5.3 DNS记录和报文</h2><p>共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录</strong>（RR），RR提供了主机名到IP地址的映射。每个DNS回答报文包含了<strong>一条或多条</strong>RR。</p><p>RR是一个包含了下列字段的4元组：<br />（Name，Value，Type，TTL）</p><p>关于RR的详细内容以后再补。</p><h3 id="531-dns报文"><a class="markdownIt-Anchor" href="#531-dns报文"></a> 5.3.1 DNS报文</h3><p>DNS报文中各字段的语义如下：</p><p><img src="/img/cn2.12.png" alt="DNS报文格式" /></p><ul><li>前12个字节是<strong>首部区域</strong>。<br /><strong>1</strong> <strong>标识符</strong>是一个<em>16比特的数</em>。用于标识该查询，它会被复制到回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。<br /><strong>2</strong> <strong>标志字段</strong>中含有<em>若干标志</em>。<br />1比特的“<em>查询/回答</em>”标志位指出报文是查询报文（0）还是回答报文（1）；<br />当某DNS服务器是所请求名字的权威DNS服务器时，1比特的“<em>权威的</em>”标志位被置入；<br />如果客户在该DNS服务器没有某记录时希望它执行递归查询，将设置1比特的“<em>希望递归</em>”标志位；<br />如果该DNS服务器支持递归查询，在它的回答报文中会显示1比特的“递归可用”标志位。<br /><strong>3</strong> 除此之外，首部区域还有4个<strong>有关数量的字段</strong>，它们分别指出了4类数据区域出现的数量。<ul><li><strong>问题区域</strong>包含着正在进行的查询信息。该区域包括：<br /><strong>1 名字字段</strong>，指出正在被查询的主机名字。<br /><strong>2 类型字段</strong>，指出有关该名字的正被询问的问题类型。</li><li><strong>回答区域</strong>包含了对最初请求的名字的<strong>资源记录</strong>。</li><li><strong>权威区域</strong>包含了其他权威服务器的记录。</li><li><strong>附加区域</strong>包含了其他有帮助的记录。</li></ul></li></ul><h3 id="532-在dns数据库中插入记录"><a class="markdownIt-Anchor" href="#532-在dns数据库中插入记录"></a> 5.3.2 在DNS数据库中插入记录</h3><p>如果你想注册域名，需要向注册登记机构（register）提供基本和辅助权威DNS服务器的名字和IP地址。对这两个权威DNS服务器，该注册登记机构确保将一个类型NS和一个类型A的记录输入TLD com服务器。</p><blockquote><p>例如，输入如下信息：<br />(<a href="http://networkutopia.com">networkutopia.com</a>, <a href="http://dnsl.networkutopia.com">dnsl.networkutopia.com</a>, NS)<br />(<a href="http://dnsl.networkutopia.com">dnsl.networkutopia.com</a>,  212.212.212.1, A)</p></blockquote><p>除此之外，你还需要确保用于Web服务器的类型A资源记录和用于邮件服务器的类型MX资源记录被输入到你的权威DNS服务器中。</p><h1 id="六-p2p应用"><a class="markdownIt-Anchor" href="#六-p2p应用"></a> 六、P2P应用</h1><p>P2P体系结构不同于客户-服务器体系结构，成对间歇地主机（称为对等方）彼此直接通信。有两种特别适合于P2P设计的应用。</p><ul><li>文件分发，其中应用程序从单个源向大量的对等方分发一个文件。</li><li>分布在大型对等方社区中的数据库。</li></ul><h2 id="61-p2p文件分发"><a class="markdownIt-Anchor" href="#61-p2p文件分发"></a> 6.1 P2P文件分发</h2><h3 id="611-p2p体系结构的扩展"><a class="markdownIt-Anchor" href="#611-p2p体系结构的扩展"></a> 6.1.1 P2P体系结构的扩展</h3><blockquote><p>假设，<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold-italic">u</mi><mi mathvariant="bold-italic">s</mi></msub></mrow><annotation encoding="application/x-tex">\bm{u_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.59444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.161108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span>表示服务器接入链路的上载速率；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold-italic">u</mi><mi mathvariant="bold-italic">i</mi></msub></mrow><annotation encoding="application/x-tex">\bm{u_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.59444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33528199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span>表示第i个对等方接入链路的上载速率；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold-italic">d</mi><mi mathvariant="bold-italic">i</mi></msub></mrow><annotation encoding="application/x-tex">\bm{d_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33528199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span>表示第i个对等方接入链路的上载速率；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">F</mi></mrow><annotation encoding="application/x-tex">\bm{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.15972em;">F</span></span></span></span></span></span>表示被分发的文件长度（以比特计）；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">N</mi></mrow><annotation encoding="application/x-tex">\bm{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.11424em;">N</span></span></span></span></span></span>表示要获得的该文件副本的对等方的数量；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold-italic">D</mi></mrow><annotation encoding="application/x-tex">\bm{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03194em;">D</span></span></span></span></span></span>是所有N个对等方得到该文件的副本所需要的时间。</p></blockquote><p>对于客户-服务器体系结构，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>≥</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mfrac><mrow><mi>N</mi><mi>F</mi></mrow><msub><mi>u</mi><mi>s</mi></msub></mfrac><mo separator="true">,</mo><mfrac><mi>F</mi><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mfrac><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D \ge max \{  \frac {NF}{u_s},  \frac {F}{d_{min}}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">}</span></span></span></span></span></p><p>对于P2P体系结构，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>≥</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mfrac><mi>F</mi><msub><mi>u</mi><mi>s</mi></msub></mfrac><mo separator="true">,</mo><mfrac><mi>F</mi><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mfrac><mo separator="true">,</mo><mfrac><mrow><mi>N</mi><mi>F</mi></mrow><mrow><msub><mi>u</mi><mi>s</mi></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>u</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D \ge max \{  \frac {F}{u_s}, \frac {F}{d_{min}}, \frac {NF}{u_s+\sum_{i=1}^N u_i}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5312710000000003em;vertical-align:-1.170941em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.128769em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.170941em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">}</span></span></span></span></span></p><p>二者分发时间对比如下图，</p><p><img src="/img/cn2.13.png" alt="P2P和客户-服务器体系结构的分发时间" /></p><h3 id="612-bittorrent"><a class="markdownIt-Anchor" href="#612-bittorrent"></a> 6.1.2 BitTorrent</h3><p>BitTorrent是一种用于文件分发的流行<strong>P2P协议</strong>。在BitTorrent中，参与一个特定文件分发的所有对等方的集合被称为一个<strong>洪流</strong>（torrent）。在一个洪流中的对等方彼此下载等长度的<strong>文件块</strong>（chunk），一般块长度为256KB。当一个对等方首次加入一个洪流时，它没有块。随着时间流逝，它累积了越来越多的块，当它<strong>下载</strong>块时，也为其他对等方<strong>上载</strong>了多个块。<strong>任何对等方可能在任何时候仅具有块的子集就离开洪流，并可以重新加入洪流。</strong></p><p>每个洪流有一个基础设施结点，称为<strong>追踪器</strong>（tracker）。当一个对等方加入该洪流中时，它向追踪器注册自己，并周期性地通知追踪器它仍然在该洪流中。以这种方式，追踪器跟踪正参与在洪流中的对等方。</p><p>当一个新的对等方A加入该洪流时，追踪器随机地从参与对等方的集合中选择对等方的一个子集，并将这些对等方的IP地址发给A。A会尝试与它们<strong>创建并行的TCP连接</strong>，所有成功与A创建连接的对等方称为**“邻近对等方**”。随着时间流逝，它们中有些可能离开，而其余的对等方可能加入，因此，<strong>一个对等方的邻近对等方将随时间波动。</strong><br /><img src="/img/cn2.14.png" alt="BitTorrent分发文件" /></p><p>在任何给定的时间，每个对等方将具有来自该文件的块子集，并且不同对等方具有不同的子集。A周期性地询问  每个邻近对等方具有的块列表，之后A可以对它还没有的块发出请求（TCP）。</p><p>A将做出两个重要决定：-请求哪些块？-为哪些邻近对等方发送块？</p><ul><li>在决定请求哪些块的过程中，A会使用一种称为最<strong>稀缺优先</strong>的技术。思路是，针对它没有的块在它的邻居中决定最稀缺的块，并首先请求最稀缺的块。这样，最稀缺的块得到更为迅速地分发，其目标是均衡每个块在洪流中地副本数量。</li><li>为了决定响应哪个请求，A根据当前能够以最高速率向它提供数据的邻居给出优先权。</li></ul><h2 id="62-分布式散列表"><a class="markdownIt-Anchor" href="#62-分布式散列表"></a> 6.2 分布式散列表</h2><p>在P2P系统中，每个P2P对等方将保持（键，值）对仅占总体的一个小子集，并且允许任何一个对等方用一个特别的键来查询该分布式数据库。分布式数据库则将定位拥有该相应（键，值）对的对等方，然后向查询的对等方返回该（键，值）对。任何对等方也将允许在数据库中插入新键-值对。这样一种分布式数据库被称为<strong>分布式散列表</strong>（DHT）。</p><p>详细内容以后需要再补</p><h1 id="七-tcp套接字编程"><a class="markdownIt-Anchor" href="#七-tcp套接字编程"></a> 七、TCP套接字编程</h1><h2 id="71-udp套接字编程"><a class="markdownIt-Anchor" href="#71-udp套接字编程"></a> 7.1 UDP套接字编程</h2><p><img src="/img/cn2.15.png" alt="UDP 客户 / 服务器程序使用的套接字函数" /></p><p>以下代码演示客户如何使用UDP套接字向服务器发送消息：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## UDPClient.py</span><br><span class="hljs-comment"># socket模块形成了在Python中所有网络通信的基础</span><br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># 提供服务器的IP地址或主机名</span><br>serverName = <span class="hljs-string">&#x27;hostname&#x27;</span><br><span class="hljs-comment"># 置入端口号</span><br>serverPort = <span class="hljs-number">12000</span><br><span class="hljs-comment"># 创建客户的套接字，第一个参数指示了地址簇，第二个参数指示它是一个UDP套接字</span><br>clientSocket = socket(AF_INET, SOCK_DGRAM)<br><span class="hljs-comment"># 提示用户输入报文</span><br>message = raw_input(<span class="hljs-string">&#x27;Input lowercase sentence:&#x27;</span>)<br><span class="hljs-comment"># 经一个UDP套接字发送报文</span><br>clientSocket.sendto(message,(serverName, serverPort))<br><span class="hljs-comment"># 将服务器传回的报文置入到变量中</span><br>modifiedMessage, serverAddress = clientSocket, recvfrom(<span class="hljs-number">2048</span>)<br><span class="hljs-comment"># 打印输出报文</span><br><span class="hljs-built_in">print</span> modifiedMessage<br><span class="hljs-comment"># 关闭套接字，关闭进程</span><br>clientSocket.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## UDPServer.py</span><br><span class="hljs-comment"># socket模块形成了在Python中所有网络通信的基础</span><br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># 置入端口号</span><br>serverPort = <span class="hljs-number">12000</span><br><span class="hljs-comment"># 创建服务器的套接字，第一个参数指示了地址簇，第二个参数指示它是一个UDP套接字</span><br>serverSocket = socket(AF_INET, SOCK_DGRAM)<br><span class="hljs-comment"># 将端口号与套接字绑定在一起</span><br>serverSocket.bind((<span class="hljs-string">&quot;, serverPort))</span><br><span class="hljs-string">print &quot;</span>The server <span class="hljs-keyword">is</span> ready to receive<span class="hljs-string">&quot;</span><br><span class="hljs-string"># 该循环允许UDPServer无限期地接收并处理来自客户的分组</span><br><span class="hljs-string">while true:</span><br><span class="hljs-string"># 将分组数据和客户地址置入</span><br><span class="hljs-string">message, clientAddress = serverSocket.recvfrom(2048)</span><br><span class="hljs-string"># 将数据小写转换为大写</span><br><span class="hljs-string">modifiedMessage = message.upper()</span><br><span class="hljs-string"># 将所得分组发送给服务器的套接字</span><br><span class="hljs-string">serverSocket.sendto(modifiedMessage, clientAddress)</span><br></code></pre></td></tr></table></figure><h2 id="72-tcp套接字编程"><a class="markdownIt-Anchor" href="#72-tcp套接字编程"></a> 7.2 TCP套接字编程</h2><p>TCP是一个面向连接的协议。在客户和服务器能够开始互相发送数据之前，它们先要握手和创建一个TCP连接（客户套接字和服务器套接字）。</p><p><img src="/img/cn2.16.png" alt="TCP 客户 / 服务器程序使用的套接字函数" /></p><p>以下代码演示客户如何使用TCP套接字向服务器发送消息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>serverName = <span class="hljs-string">&#x27;servername&#x27;</span><br>serverPort = <span class="hljs-number">12000</span><br><span class="hljs-comment"># 创建客户的套接字，第一个参数指示了地址簇，第二个参数指示它是一个TCP套接字</span><br>clientSocket = socket(AF_INET, SOCK_STREAM)<br><span class="hljs-comment"># 执行三次握手，并创建起一条TCP连接</span><br>clientSocket.connect((serverName, serverPort))<br><span class="hljs-comment"># 提示用户输入报文</span><br>sentence = raw_input(<span class="hljs-string">&#x27;Input lowercase sentence&#x27;</span>)<br><span class="hljs-comment"># 通过套接字进入TCP连接发送报文</span><br>clientSocket.send(sentence)<br><span class="hljs-comment"># 将服务器传回的报文置入到变量中</span><br>modifiedSentence = clientSocket.recv(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;From Server:&#x27;</span>, modifiedSentence<br>clientSocket.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## TCPServer.py</span><br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br>serverPort = <span class="hljs-number">12000</span><br><span class="hljs-comment"># 创建服务器的套接字，第一个参数指示了地址簇，第二个参数指示它是一个UDP套接字</span><br>serverSocket = socket(AF_INET, SOCK_DGRAM)<br><span class="hljs-comment"># 将端口号与套接字绑定在一起</span><br>serverSocket.bind((<span class="hljs-string">&quot;, serverPort))</span><br><span class="hljs-string"># 等待并聆听某个客户敲门，参数定义了请求连接的最大数（至少为1）</span><br><span class="hljs-string">serverSocket.listen(1)</span><br><span class="hljs-string">print &quot;</span>The server <span class="hljs-keyword">is</span> ready to receive<span class="hljs-string">&quot;</span><br><span class="hljs-string"># 该循环允许TCPServer无限期地接收并处理来自客户的分组</span><br><span class="hljs-string">while true:</span><br><span class="hljs-string"># 创建一个新套接字，由这个特定用户专用</span><br><span class="hljs-string">connectionSocket, addr = serverSocket.accept()</span><br><span class="hljs-string"># 将分组数据和客户地址置入</span><br><span class="hljs-string">sentence = connectionSocket.recv(1024)</span><br><span class="hljs-string"># 将数据小写转换为大写</span><br><span class="hljs-string">capitalizedSentence = sentence.upper()</span><br><span class="hljs-string"># 将所得分组发送给服务器的套接字</span><br><span class="hljs-string">connectionSocket.send(capitalizedSentence)</span><br><span class="hljs-string">connectionSocket.close()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++基础语法</title>
    <link href="/2022/03/23/Cpp2/"/>
    <url>/2022/03/23/Cpp2/</url>
    
    <content type="html"><![CDATA[<h1 id="c基础语法"><a class="markdownIt-Anchor" href="#c基础语法"></a> C++基础语法</h1><h2 id="1-输入输出"><a class="markdownIt-Anchor" href="#1-输入输出"></a> 1、输入输出</h2><h3 id="11-使用cout进行输出"><a class="markdownIt-Anchor" href="#11-使用cout进行输出"></a> 1.1 使用cout进行输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;Come up and C++ me some time.&quot;</span>；<br></code></pre></td></tr></table></figure><p>双括号引起的部分是要打印的字符串，&lt;&lt;符号表示该语句把整个字符串发送给cout，它将一个字符串插入到了输出流中。<br />cout在头文件iostream中定义。</p><h3 id="12-控制符endl"><a class="markdownIt-Anchor" href="#12-控制符endl"></a> 1.2 控制符endl</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>endl表示重起一行，在输出流中插入endl将导致光标移到下一行开头。<br />endl在头文件iostream中定义。</p><h3 id="13-换行符"><a class="markdownIt-Anchor" href="#13-换行符"></a> 1.3 换行符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;Pluto is a dwarf planet.\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Pluto is a dwarf planet.&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>endl确保程序继续运行前刷新输出（将其立即显示在屏幕上），使用\n在某些系统中可能在输入信息后才能出现提示。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python的一些常用函数</title>
    <link href="/2022/03/23/python1/"/>
    <url>/2022/03/23/python1/</url>
    
    <content type="html"><![CDATA[<h1 id="python的一些常用函数"><a class="markdownIt-Anchor" href="#python的一些常用函数"></a> python的一些常用函数</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>因为最近在准备蓝桥杯python组的比赛，特罗列总结出python的一些常用函数。后续随着使用也会陆续整理。</p><h2 id="内置函数"><a class="markdownIt-Anchor" href="#内置函数"></a> 内置函数</h2><h3 id="1-数学函数"><a class="markdownIt-Anchor" href="#1-数学函数"></a> 1 数学函数</h3><p>1.1 abs()：取绝对值</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>(-<span class="hljs-number">10</span>))  <span class="hljs-comment">##10</span><br></code></pre></td></tr></table></figure><p>1.2 divmod()：同时取商和余数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">divmod</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment">##(3, 1)</span><br></code></pre></td></tr></table></figure><p>1.3 sum()：求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment">##6</span><br></code></pre></td></tr></table></figure><p>1.4 round()：四舍五入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">5.1</span>))  <span class="hljs-comment">##5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">5.5</span>))  <span class="hljs-comment">##6</span><br></code></pre></td></tr></table></figure><p>1.5 pow(m, n)：计算m的n次方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment">##8</span><br></code></pre></td></tr></table></figure><p>1.6 min()/max()：最小(大)值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">min</span>(<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment">##2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment">##9</span><br></code></pre></td></tr></table></figure><h3 id="2-数据转换函数"><a class="markdownIt-Anchor" href="#2-数据转换函数"></a> 2 数据转换函数</h3><p>2.1 hex()：十进制转换成十六进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-number">100</span>))  <span class="hljs-comment">##0x64</span><br></code></pre></td></tr></table></figure><p>2.2 oct()：十进制转换成八进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">oct</span>(<span class="hljs-number">100</span>))  <span class="hljs-comment">##0o144</span><br></code></pre></td></tr></table></figure><p>2.3 bin()：十进制转换成二进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-number">100</span>))  <span class="hljs-comment">##0b1100100</span><br></code></pre></td></tr></table></figure><p>2.4 bool()：将指定参数类型转换成布尔类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>))  <span class="hljs-comment">##True</span><br></code></pre></td></tr></table></figure><p>2.5 ord()：获取单个字符的ASCII数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;A&quot;</span>))  <span class="hljs-comment">##65</span><br></code></pre></td></tr></table></figure><p>2.6 float()：转换成浮点数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(<span class="hljs-number">10</span>))  <span class="hljs-comment">##10.0</span><br></code></pre></td></tr></table></figure><p>2.7 chr() ：转换一个整数并返回所对应的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(<span class="hljs-number">65</span>))  <span class="hljs-comment">##A</span><br></code></pre></td></tr></table></figure><p>2.8 list()： 将可迭代对象转换为列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)))  <span class="hljs-comment">##[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><p>2.9 upper()/lower()：大小写转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hELLO world!&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>.upper())<br>HELLO WORLD!<br></code></pre></td></tr></table></figure><h3 id="3-对象创建函数"><a class="markdownIt-Anchor" href="#3-对象创建函数"></a> 3 对象创建函数</h3><h3 id="4-迭代器操作函数"><a class="markdownIt-Anchor" href="#4-迭代器操作函数"></a> 4 迭代器操作函数</h3><h2 id="基本常用函数"><a class="markdownIt-Anchor" href="#基本常用函数"></a> 基本常用函数</h2><h2 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h2><h3 id="1-最基本的文件操作"><a class="markdownIt-Anchor" href="#1-最基本的文件操作"></a> 1 最基本的文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;E:\hello.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>res = []<br>s = fp.readlines()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>    res.append(i.strip(<span class="hljs-string">&#x27;\n&#x27;</span>)) <span class="hljs-comment">#使用strip()去掉换行符，如果不去的话会把‘\n’也读进来</span><br>fp.close() <span class="hljs-comment">#记得要关闭连接，养成良好习惯</span><br><br><span class="hljs-built_in">print</span>(res[:])<br></code></pre></td></tr></table></figure><h3 id="2-字符串操作"><a class="markdownIt-Anchor" href="#2-字符串操作"></a> 2 字符串操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">fp =  <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;E:\hello.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>res = [s.strip(<span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> fp.readlines()]<br>fp.close()<br><span class="hljs-built_in">print</span>(res[:])<br></code></pre></td></tr></table></figure><h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2><h3 id="1-datetime模块"><a class="markdownIt-Anchor" href="#1-datetime模块"></a> 1 datetime模块</h3><p>1.1 日期对象——date类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetimee<br><br>d = datetime.date(<span class="hljs-number">2019</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)<span class="hljs-comment"># 年，月，日</span><br><span class="hljs-built_in">print</span>(d)  <span class="hljs-comment">## 2019-01-11</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br>a1 = datetime.date(<span class="hljs-number">2019</span>,<span class="hljs-number">8</span>,<span class="hljs-number">26</span>)<br><span class="hljs-built_in">print</span>(a1.isocalendar())<br><span class="hljs-built_in">print</span>(a1.isoformat())<br><span class="hljs-built_in">print</span>(a1.isoweekday())<br><span class="hljs-built_in">print</span>(a1.weekday())<br><span class="hljs-built_in">print</span>(a1.replace(<span class="hljs-number">2018</span>,<span class="hljs-number">4</span>,<span class="hljs-number">30</span>))<br><span class="hljs-comment">#(2019, 35, 1)</span><br><span class="hljs-comment">#2019-08-26</span><br><span class="hljs-comment">#1</span><br><span class="hljs-comment">#0</span><br><span class="hljs-comment">#2018-04-30</span><br></code></pre></td></tr></table></figure><p>1.2 时间对象——time类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br>t = datetime.time(<span class="hljs-number">20</span>, <span class="hljs-number">36</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1</span>)<span class="hljs-comment"># 时，分，秒，毫秒</span><br><span class="hljs-built_in">print</span>(t)  <span class="hljs-comment">## 20：36：15.000001</span><br></code></pre></td></tr></table></figure><p>1.3 日期时间对象——datetime类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>now = datetime.now()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前日期时间是：&#x27;</span>,now)  <span class="hljs-comment">## 2022-03-27 13:45:53.536404</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前日期是：&#x27;</span>,now.date())  <span class="hljs-comment">## 2022-03-27</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前时间是：&#x27;</span>,now.time())  <span class="hljs-comment">## 13:45:53.536404</span><br>```e<br>日期时间转化为时间戳<br>```python<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-built_in">print</span>(datetime.now().timestamp())  <span class="hljs-comment">##1627700208.446621</span><br></code></pre></td></tr></table></figure><p>时间戳转化为日期时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-built_in">print</span>(datetime.fromtimestamp(<span class="hljs-number">1627700208.446621</span>))  <span class="hljs-comment">## 2022-03-27 13:45:53.536404</span><br></code></pre></td></tr></table></figure><p>日期时间对象转字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-built_in">print</span>(datetime.now().strftime(<span class="hljs-string">&quot;%Y+%m+%d&quot;</span>))  <span class="hljs-comment">## 2022+03+27</span><br></code></pre></td></tr></table></figure><p>字符串转日期时间对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>a = datetime.strptime(<span class="hljs-string">&#x27;2022-5-22  15:23:38&#x27;</span>, <span class="hljs-string">&#x27;%Y-%m-%d  %H:%M:%S&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))  <span class="hljs-comment">## &lt;class &#x27;datatime.datatime&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment">## 2022-5-22  15:23:38</span><br></code></pre></td></tr></table></figure><p>1.4 时间间隔对象——timedelta类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br>now = datetime.datetime.now()<br>a = datetime.timedelta(hours=<span class="hljs-number">8</span>,minutes=<span class="hljs-number">20</span>,seconds=<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))  <span class="hljs-comment">## &lt;class &#x27;datatime.timedelta&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(now - a)  <span class="hljs-comment">## 2021-07-31 02:58:29.424161</span><br><span class="hljs-built_in">print</span>(now + a)  <span class="hljs-comment">## 2021-07-31 19:38:49.424161</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++的一些特点</title>
    <link href="/2022/03/22/Cpp1/"/>
    <url>/2022/03/22/Cpp1/</url>
    
    <content type="html"><![CDATA[<h1 id="c的一些特点"><a class="markdownIt-Anchor" href="#c的一些特点"></a> C++的一些特点</h1><h2 id="1-main函数"><a class="markdownIt-Anchor" href="#1-main函数"></a> 1 main()函数</h2><p><strong>1.1</strong> 主函数必须是int main()或int main(void)<br /><em>原因</em>：运行cpp程序时，通常从main()函数开始执行。因此，如果没有main()，程序将不完整，编译器将指出未定义main()函数。</p><p><strong>1.2</strong> main()最后可以不返回0<br /><em>原因</em>：ANSI/ISO C++标准为，如果编译器到达main()函数末尾时没有遇到返回语句，则认为main()函数以return 0结尾。</p><h2 id="2-注释"><a class="markdownIt-Anchor" href="#2-注释"></a> 2 注释</h2><p><strong>2.1</strong> 注释以“//”打头，到行尾结束<br /><strong>2.2</strong> 注释可以位于单独一行，也可和代码位于同一行</p><h2 id="3-预处理器和头文件名"><a class="markdownIt-Anchor" href="#3-预处理器和头文件名"></a> 3 预处理器和头文件名</h2><p><strong>3.1</strong> 如果程序要使用某些工具，要在前几行标明#include…<br /><em>原因</em>：C++和C一样，使用一个预处理器，在主编译之前对源文件进行处理，例如在源代码被编译之前，替换或添加文本。</p><p><strong>3.2</strong> 头文件名没有扩展名</p><h2 id="4-名称空间"><a class="markdownIt-Anchor" href="#4-名称空间"></a> 4 名称空间</h2><p><strong>4.1</strong> using namespace std;<br />原因：有助于组织程序，在调用同名函数时可以指定哪个名称空间的函数,如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">Microflop::<span class="hljs-built_in">wanda</span>(<span class="hljs-string">&quot;go dancing?&quot;</span>);<br>Piscine::<span class="hljs-built_in">wanda</span>(<span class="hljs-string">&quot;a fish named Desire&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果省略了这条语句，那么就要使用如下语句编码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;Come up and C++ me some time.&quot;</span>;<br>std::cout &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>更好的办法是，只是通过using声明使所需名称可用，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::cin;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01：计算机网络和因特网</title>
    <link href="/2022/03/21/Cn1/"/>
    <url>/2022/03/21/Cn1/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><blockquote><p><em><strong>纸上得来终觉浅，绝知此事要躬行。</strong></em></p></blockquote><div class="code-wrapper"><pre><code class="hljs">在本专栏中，我们将使用*公共因特网*（一种特定的计算机网络）作为讨论计算机网络机器协议的主要载体。</code></pre></div><h1 id="一-因特网网络的网络"><a class="markdownIt-Anchor" href="#一-因特网网络的网络"></a> 一、因特网：网络的网络</h1><blockquote><p>何为因特网？可以有两种解释：<br />——构成因特网的基本硬件和软件组件<br />——为分布式应用提供服务的联网基础设施</p></blockquote><p>下面我们分别以这两方面作为切入点，剖析因特网</p><h2 id="11-具体构成描述"><a class="markdownIt-Anchor" href="#11-具体构成描述"></a> 1.1 具体构成描述</h2><h3 id="111-端系统-通信链路-分组交换机-分组简介"><a class="markdownIt-Anchor" href="#111-端系统-通信链路-分组交换机-分组简介"></a> 1.1.1 端系统、通信链路、分组交换机、分组简介</h3><p>用因特网术语来说，所有与它相联系的设备统称为<strong>主机</strong>（host）或<strong>端系统</strong>（end system）。</p><blockquote><p>端系统通过<strong>通信链路</strong>（communication link）和<strong>分组交换机</strong>（packet switch）连接到一起。</p></blockquote><p><em>通信链路</em>。它们由不同类型的物理媒体（同轴电缆、铜线、光纤和无线电频谱）组成。不同的链路有不同的传输速率（以bit/s或bps度量）。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包我们将其称为<strong>分组</strong>（packet）。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。</p><p><em>分组交换机</em>。分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。在当今的因特网中，两种最著名的类型是<strong>路由器</strong>（router）和<strong>链路层交换机</strong>（link-layer switch）。</p><blockquote><p><strong>路由器</strong>通常用于网络核心中<br /><strong>链路层交换机</strong>通常用于接入网中</p></blockquote><p>从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径</strong>（route或path）。</p><p>用于传送分组的分组交换网络在许多方面类似于承载运输车辆的运输网络，该网络包括了高速公路、公路和立交桥。当工厂需要将大量货物搬运至远方的仓库时，工厂就要将货物分开装上卡车车队，通过高速公路、公路和立交桥将货物搬运至仓库。在这一过程中，各个环节扮演的角色如下表所示：</p><table><thead><tr><th>角色</th><th>环节</th></tr></thead><tbody><tr><td>分组</td><td>卡车</td></tr><tr><td>通信链路</td><td>高速公路、公路</td></tr><tr><td>分组交换机</td><td>立交桥</td></tr><tr><td>端系统</td><td>工厂、仓库</td></tr></tbody></table><h3 id="112-isp简介"><a class="markdownIt-Anchor" href="#112-isp简介"></a> 1.1.2 ISP简介</h3><p>端系统通过<strong>因特网服务提供商</strong>（ISP）接入因特网。每个ISP是一个由多个分组交换机和多段通信链路组成的网络。各ISP为端系统提供各种不同类型的网络接入（线缆调制解调器或如DSL的住宅宽带接入、高速局域网接入、无线接入和56kbps拨号调制解调器接入）。</p><p>因特网将端系统彼此互联，因此ISP也必须互联。</p><blockquote><p><strong>低层ISP</strong>通过国家、国际的高层ISP（Level 3 Communications、AT&amp;T、Sprint和NTT）互联；<br /><strong>高层ISP</strong>是由通过高速光纤链路互联的高速路由器组成的</p></blockquote><h3 id="113-协议简介"><a class="markdownIt-Anchor" href="#113-协议简介"></a> 1.1.3 协议简介</h3><p>端系统、分组交换机和其他因特网部件都要运行一系列协议（protocol），这些协议控制因特网中信息的接收和发送。<strong>传输控制协议</strong>（TCP）和<strong>网络协议</strong>（IP）是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为TCP/IP。</p><p>鉴于因特网协议的重要性，每个人就各个协议及其作用取得一致认识很重要，这样人们就能创造协同工作的系统和产品。自然而然，我们引入了因特网<strong>标准</strong>（Internet standard），它由因特网工程任务组（IETF）研发。IETF的标准文档称为<strong>请求评论</strong>（RFC），它们定义了TCP、IP、HTTP（用于Web）和SMTP（用于电子邮件）等协议。当然，其他组织也在制定用于网络组件的标准。</p><h2 id="12-服务描述"><a class="markdownIt-Anchor" href="#12-服务描述"></a> 1.2 服务描述</h2><blockquote><p>何为因特网？可以有两种解释：<br />——构成因特网的基本硬件和软件组件<br />——为分布式应用提供服务的联网基础设施</p></blockquote><p>上文以前者作为切入点，现在我们从<em>应用程序提供服务的基础设施</em>的角度来描述因特网。</p><p>我们平时接触到的大部分应用程序，例如电子邮件、Web冲浪、即时讯息等等，它们称为<strong>分布式应用程序</strong>（distributed application），因为它们涉及多台相互交换数据的端系统。</p><p>与因特网相连的端系统提供了一个<strong>应用程序编程接口</strong>（API）。API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。</p><p>举个例子，Alice要向Bob寄一封信，Alice不能写完信后就将信丢出窗外，邮政服务要求Alice将信放入 信封并贴上邮票，还要投进邮箱中。对应到因特网中，就有如下类比：</p><table><thead><tr><th>角色</th><th>环节</th></tr></thead><tbody><tr><td>软件A</td><td>Alice</td></tr><tr><td>软件B</td><td>Bob</td></tr><tr><td>API</td><td>邮政服务规定</td></tr></tbody></table><h2 id="13-什么是协议"><a class="markdownIt-Anchor" href="#13-什么是协议"></a> 1.3 什么是协议</h2><h3 id="131-人类活动类比"><a class="markdownIt-Anchor" href="#131-人类活动类比"></a> 1.3.1 人类活动类比</h3><blockquote><p>我们用一张图生动形象的表达协议的含义</p></blockquote><p><a href="https://img-blog.csdnimg.cn/86635908c0e14a5aa3909b7848af7ccb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTI3NTUwNTk=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center">图为人类协议和计算机网络协议</a></p><p>如果人们使用不同的协议（例如，一个人讲礼貌而另一个人不讲礼貌），该协议就不能互动，因而不能完成有用的工作。在网络中这个道理同样成立。即为了完成一项工作，要求两个（或多个）通信实体运行相同协议。</p><h3 id="132-网络协议"><a class="markdownIt-Anchor" href="#132-网络协议"></a> 1.3.2 网络协议</h3><blockquote><p>在因特网中，凡是涉及两个或多个远程通信实体的所有活动都受<strong>协议</strong>的制约。</p></blockquote><p>例如，在两台物理上连接的计算机中，硬件实现的协议控制了在两块网络接口卡间的“线上”的比特流；在端系统中，拥塞控制协议控制了在发送方和接收方之间传输的分组发送的速率。</p><p>从上述的人类活动和网络的例子中可见，报文的交换以及发送和接收这些报文时所采取的动作是定义一个协议的关键元素：</p><blockquote><p>一个<strong>协议</strong>定义了在两个或多个通信实体之间交换的<strong>报文格式和次序</strong>，以及报文发送和（或）接收一条报文或其他事件所采取的<strong>动作</strong>。</p></blockquote><h1 id="二-网络边缘"><a class="markdownIt-Anchor" href="#二-网络边缘"></a> 二、网络边缘</h1><p>我们通常把与因特网相连的计算机和其他设备称为端系统，因为它们位于<strong>互联网的边缘</strong>，故而被称为端系统。端系统也称为<strong>主机</strong>，因为它们容纳（即运行）应用程序，如Web浏览器程序、Web服务器程序、电子邮件阅读程序或电子邮件服务器程序等。端系统有时又被进一步划分为两类：<strong>客户</strong>（client）和<strong>服务器</strong>（server）。</p><blockquote><p><strong>客户</strong>相当于是桌面PC、移动PC和智能手机等，<br /><strong>服务器</strong>相当于是更为强大的机器，用于存储和发布Web页面、流视频、中继电子邮件等。</p></blockquote><h2 id="21-接入网"><a class="markdownIt-Anchor" href="#21-接入网"></a> 2.1 接入网</h2><blockquote><p><strong>接入网</strong>是指将端系统连接到其<strong>边缘路由器</strong>的<strong>物理链路</strong></p></blockquote><p>边缘路由器是端系统到任何其他远程端系统的路径上的<strong>第一台路由器</strong>。</p><p><a href="https://img-blog.csdnimg.cn/0adfe3517b9f4caaad181ea94136954e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTI3NTUwNTk=,size_20,color_FFFFFF,t_70,g_se,x_16">图为端系统交互的大致组成部分</a></p><h3 id="211-家庭接入dsl-电缆-ftth-拨号和卫星"><a class="markdownIt-Anchor" href="#211-家庭接入dsl-电缆-ftth-拨号和卫星"></a> 2.1.1 家庭接入：DSL、电缆、FTTH、拨号和卫星</h3><p>以前，宽带住宅接入有两种类型：<strong>数字用户线</strong>（DSL）和<strong>电缆</strong>。</p><p><a href="https://img-blog.csdnimg.cn/c9e80d89bf684f809beca1e20b49e770.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTI3NTUwNTk=,size_20,color_FFFFFF,t_70,g_se,x_16">图为DSL因特网接入</a></p><p>除了DSL电话接入，还有利用有线电视公司现有有线电视基础设施的电缆因特网接入，这里不再赘述，读者可自行查阅。目前主流的上网方式是<strong>光纤到户</strong>（FTTH），即从本地中心局直接到家庭提供一条光纤路径。</p><p><a href="/img/cn1.4.png">图为FTTH因特网接入</a></p><h3 id="212-企业和家庭接入以太网和wifi"><a class="markdownIt-Anchor" href="#212-企业和家庭接入以太网和wifi"></a> 2.1.2 企业（和家庭）接入：以太网和WIFI</h3><p>在公司和大学校园以及在越来越多的家庭环境中，通常是用局域网（LAN）将端用户连接到边缘路由器，以太网是目前最为流行的接入技术。使用以太网接入，用户通常以100Mbps速率接入以太网交换机，而服务器可能具有1Gbps甚至10Gbps的接入速率。</p><p><a href="/img/cn1.5.png">图为以太网因特网接入</a></p><p>在无线LAN环境中，无线用户从/到一个接入点发送/接收分组，该接入点与企业网连接，该企业网再与有线因特网相连。基于IEEE 802.11的技术的无线LAN称为WiFi。</p><h2 id="22-物理媒体"><a class="markdownIt-Anchor" href="#22-物理媒体"></a> 2.2 物理媒体</h2><p>物理媒体划分为两类：<strong>导引型媒体</strong>（guided media）和<strong>非导引型媒体</strong>（unguided meidia）。</p><blockquote><p>导引型媒体，电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。<br />非导引型媒体，电波在空气或外层空间中传播，如无线局域网或数字卫星频道。</p></blockquote><p>具体物理媒体介绍暂且不更，有兴趣者可自行查阅。</p><h1 id="三-网络核心"><a class="markdownIt-Anchor" href="#三-网络核心"></a> 三、网络核心</h1><p><strong>网络核心</strong>指互联因特网端系统的分组交换机和链路构成的网状网络。</p><h2 id="31-分组交换"><a class="markdownIt-Anchor" href="#31-分组交换"></a> 3.1 分组交换</h2><p>源端系统向目的端系统发送报文，源将长报文划分为一个个<strong>分组</strong>，每个分组都通过<strong>通信链路</strong>和<strong>分组交换机</strong>传送，分组以等于该链路<strong>最大传输速率</strong>的速度传输通过通信链路。因此，如果某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R比特/秒，则传输该分组的时间为L/R秒。</p><h3 id="311-存储转发运输"><a class="markdownIt-Anchor" href="#311-存储转发运输"></a> 3.1.1 存储转发运输</h3><blockquote><p><strong>存储转发运输</strong>，是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p></blockquote><p>多数分组交换机在链路的输入端使用<strong>存储转发运输</strong>（store-and-forward transmission）机制。</p><p>为了深刻理解存储转发运输，特举例说明（这里忽略传播时延），</p><blockquote><p>发送一个分组：<br />源在时刻0开始传输；<br />在时刻L/R，路由器接收到整个分组；<br />在时刻2L/R，路由器传输了整个分组，并已被目的地接收。<br />总时延为2L/R。</p></blockquote><blockquote><p>发送三个分组：<br />源在时刻0开始传输；<br />在时刻L/R，路由器开始转发第一个分组，源开始发送第二个分组；<br />在时刻2L/R，目的地收到第一个分组，路由器收到第二个分组；<br />在时刻3L/R，目的地收到前两个分组，路由器收到第三个分组；<br />在时刻4L/R，目的地接收全部分组。<br />总时延为4L/R。</p></blockquote><p>综上所诉，我们可以考虑N条速率均为R的链路组成的路径（所以，源和目的地之间有N-1台路由器），d（端时延）=N*L/R</p><h3 id="312-排队时延和分组丢失"><a class="markdownIt-Anchor" href="#312-排队时延和分组丢失"></a> 3.1.2 排队时延和分组丢失</h3><p>每个分组交换机有多条链路与之相连，对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>（output buffer）（也称为<strong>输出队列</strong>output queue），它用于存储路由器准备发往那条链路的分组。</p><p>如果到达的分组需要传输到的那条链路正在传输其他分组，到达的分组就要在输出缓存中等待，由此引起的时延叫做<strong>排队时延</strong>（queue delay）。这些时延是变化的，变化的程度取决于网络中的拥塞程度，如果分组到达时缓存空间已经满了，就会发生**分组丢失（丢包）（packet lost）**的情况，到达的分组或在排队的分组将被丢弃。</p><h3 id="313-转发表和路由选择协议"><a class="markdownIt-Anchor" href="#313-转发表和路由选择协议"></a> 3.1.3 转发表和路由选择协议</h3><p>在因特网中，每个端系统具有一个称为<strong>IP地址</strong>的地址。当源主机向目的端系统发送一个分组时，源在该分组的首部包含了目的地的IP地址。当一个分组到达路由器时，路由器检查该分组的目的地IP地址的<strong>一部分</strong>，再朝着目的地方向发送分组到达相邻的路由器，循环往复。每台路由器具有一个<strong>转发表</strong>（forwarding table），用于将目的地的一部分映射成为输出链路。</p><p>因特网具有一些特殊的<strong>路由选择协议</strong>（routing protocol），用于自动设置转发表。例如，一个路由选择协议可以决定每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器中的转发表。</p><h2 id="32-电路交换"><a class="markdownIt-Anchor" href="#32-电路交换"></a> 3.2 电路交换</h2><blockquote><p>通过网络链路和交换机移动数据有两种基本方法：<strong>分组交换</strong>（packet switching）和<strong>电路交换</strong>（circuit switching）。</p></blockquote><p><strong>电路交换</strong>网络，预留了端系统间通信沿路径所需的资源（缓存，链路传输速率）；  例如需要顾客预定的餐馆。<br /><strong>分组交换</strong>网络，不预留。例如不需要预定但是要等号的餐馆。</p><p>举例说明电路交换网络。在一个网络中，用4条链路互联了4台电路交换机。每条链路有4条电路，因此每条链路能够支持4条并行连接。当两台主机要通信时，该网络在两台主机之间创建一条专用的端到端连接（end-to-end connection），该连接在连接期间获得该链路带宽的1/4部分。</p><h3 id="321-电路交换网中的复用"><a class="markdownIt-Anchor" href="#321-电路交换网中的复用"></a> 3.2.1 电路交换网中的复用</h3><blockquote><p>链路中的电路是通过<strong>频分复用</strong>（FDM）或<strong>时分复用</strong>（TDM）来实现的。</p></blockquote><p>对于FDM，链路的频谱由跨越链路创建的所有连接所共享，在连接期间链路为每条连接专用一个频段。在电话网络中，这个频段通常具有4kHZ的宽度，该频段的宽度叫做<strong>带宽</strong>（bandwidth）。</p><p>对于TDM，时间被划分为固定区间的<strong>帧</strong>，每帧被划分为固定数量的<strong>时隙</strong>。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，一个时隙（在每个帧内）可用于传输该连接的数据。一条电路的传输速率等于帧速率乘以一个时隙中的比特数量。</p><p>电路交换因为在<strong>静默期</strong>（silent period）专用电路空间而效率较低。</p><h3 id="322-分组交换与电路交换的对比"><a class="markdownIt-Anchor" href="#322-分组交换与电路交换的对比"></a> 3.2.2 分组交换与电路交换的对比</h3><p><strong>电路交换</strong>不考虑需求，而预先分配了传输链路的使用，这使得已分配而并不需要的链路时间未被利用。</p><p><strong>分组交换</strong>按需分配链路使用。链路传输能力将在所有用户之间逐分组地被共享，这些用户有分组需要在链路上传输。</p><p>分组交换是趋势。</p><h2 id="33-网络的网络"><a class="markdownIt-Anchor" href="#33-网络的网络"></a> 3.3 网络的网络</h2><p>端系统通过ISP与因特网相连，而ISP自身也必须互联，通过创建网络的网络解决这一问题。</p><p><a href="/img/cn1.6.png">图为ISP互联的等级结构</a></p><p>存在点（PoP）存在于等级结构的所有层次，但底层（接入ISP）除外。一个PoP只是提供商网络中的一台或多台路由器（在相同位置）群组，其中客户ISP能够与提供商ISP连接，客户网络能够从第三方通信提供商租用高速链路直接将路由器之一连接到位于该PoP的一台路由器。</p><p>任何ISP（除了第一层ISP）可以选择为多宿（multi-home），即可以与两个或更多提供商ISP连接。当一个ISP多宿时，即使它的提供商之一出现故障，它仍然能够继续发送和接收分组。</p><p>为了减少客户ISP支付给提供商ISP的费用，位于相同等级结构层次的邻近一对ISP能够对等（peer），使它们之间的所有流量经直接连接而不是通过上游的中间ISP传输。沿着这些相同路线，第三方公司创建一个因特网交换点（IXP），IXP是一个汇合点，多个ISP能够在这里共同对等。</p><p>内容提供商（如谷歌）通过创建自己的网络，不仅减少了向顶层ISP支付的费用，而且对其服务最终如何交付给端用户有了更多的控制。</p><h1 id="四-分组交换中的时延-丢包和吞吐量"><a class="markdownIt-Anchor" href="#四-分组交换中的时延-丢包和吞吐量"></a> 四、分组交换中的时延、丢包和吞吐量</h1><h2 id="41-分组交换网中的时延概述"><a class="markdownIt-Anchor" href="#41-分组交换网中的时延概述"></a> 4.1 分组交换网中的时延概述</h2><p>当分组从一个结点（端系统或路由器）沿着这条路径到后继结点，该分组在沿途的每个结点经受了几种不同类型的时延。其中最为重要的是<strong>结点处理时延</strong>（nodel processing delay）、<strong>排队时延</strong>（queueing delay）、<strong>传输时延</strong>（transmission delay）和<strong>传播时延</strong>（propagation delay），这些时延总体累加起来是<strong>结点总时延</strong>（total nodal delay）。</p><p><strong>时延的类型</strong></p><p>1 <strong>处理时延</strong><br />检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。它还包括其他因素，如检查比特级别差错所需要的时间。<br />通常是<em>微秒或更低</em>量级。</p><p>2 <strong>排队时延</strong><br />在队列中当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。<br />通常是<em>毫秒到微秒</em>量级。</p><p>3 <strong>传输时延</strong><br />用L（比特）表示该分组的长度，用R（bps）表示从路由器A到B的链路传输速率，则传输时延为L/R。注意是路由器A将分组推向链路所需要的时间。<br />通常是<em>毫秒到微秒</em>量级。</p><p>4 <strong>传播时延</strong><br />当一个比特被推向链路，送往目标路由器时，从该链路的起点到目标路由器传播所需要的时间是传播时延。该传播速率取决于该链路的物理媒体（光纤、双绞铜线等），速率范围略小于光速。该传播时延等于两台路由器之间的距离除以传播速率，即d/s。<br />广域网中，通常是<em>毫秒</em>量级。</p><p>5 <strong>传输时延</strong>和<strong>传播时延</strong>的<strong>比较</strong><br />传输时延是分组长度和链路传输速率的函数；<br />传播时延是两台路由器之间距离的函数。</p><blockquote><p><strong>总时延</strong>由上述四种时延相加，在实际生活中每种时延可能变化很大。</p></blockquote><h2 id="42-排队时延和丢包"><a class="markdownIt-Anchor" href="#42-排队时延和丢包"></a> 4.2 排队时延和丢包</h2><p>令a表示分组到达队列的平均速率（a的单位是分组/秒，即pkt/s），R是传输速率，假定所有分组都是由L比特组成的，则比特到达分组的平均速率是La（bps）。比率La/R被称为<strong>流量强度</strong>。如果La/R&gt;1，则该队列将趋于无限增大。因此，<em>设计系统时流量强度不能大于1</em>。</p><p>如果<strong>流量强度</strong>接近于0，则几乎没有分组到达并且到达间隔很大，随着流量强度接近1，平均排队长度将变得越来越长。随着流量强度接近1，平均排队时延迅速增加。该强度的少量增加将导致时延大得多的增加。<br /><a href="/img/cn1.7.png">图为平均排队时延与流量强度的关系</a></p><p>在实际使用中，一条链路前的队列是有限的，其容量受限于路由器设计和使用成本，当分组到达满的队列时，路由器将丢弃这个分组，即<strong>丢包</strong>。丢包的份额随着流量强度的增加而增加，一个结点的性能不仅根据时延度量，还与丢包的概率度量。丢失的分组可能基于端到端的原则重传，以确保所有的数据最终传到目的地。</p><h2 id="43-端到端时延"><a class="markdownIt-Anchor" href="#43-端到端时延"></a> 4.3 端到端时延</h2><p>上一节研究了结点间的时延，还需要研究端到端的时延，这里不再赘述。除了上文介绍的几种时延，端系统中还存在着其他一些重要时延，例如，作为它的协议的一部分，希望向共享媒体传输分组的端系统可以有意地延迟它的传输以与其他端系统共享媒体。另一个重要的时延是<strong>媒体分组化时延</strong>。</p><h2 id="44-计算机网络中的吞吐量"><a class="markdownIt-Anchor" href="#44-计算机网络中的吞吐量"></a> 4.4 计算机网络中的吞吐量</h2><p>除了时延和丢包，计算机网络中另一个必不可少的性能测度是<strong>端到端吞吐量</strong>。在任何时间瞬间的<strong>瞬时吞吐量</strong>是端系统B接收到该文件的速率。在下载期间，如果文件由F比特组成，端系统B接收到所有文件用时T秒，则<strong>平均吞吐量</strong>是F/T（bps）。</p><p>对于简单的两链路的网络，其吞吐量是min|R1, R2|，这叫做瓶颈链路（bottleneck link）的传输速率。n条链路同理。<br /><a href="/img/cn1.8.png">图为两链路网络</a></p><p>吞吐量取决于数据流过的链路的传输速率，当没有其他干扰流量时，其吞吐量能够近似为沿着源和目的地之间路径的<strong>最小传输速率</strong>。</p><h1 id="五-协议层次及其服务模型"><a class="markdownIt-Anchor" href="#五-协议层次及其服务模型"></a> 五、协议层次及其服务模型</h1><h2 id="51-分层的体系结构"><a class="markdownIt-Anchor" href="#51-分层的体系结构"></a> 5.1 分层的体系结构</h2><h3 id="511-协议分层"><a class="markdownIt-Anchor" href="#511-协议分层"></a> 5.1.1 协议分层</h3><p>为了给网络协议的设计提供一个结构，网络设计者以<strong>分层</strong>（layer）的方式组织协议以及实现这些协议的网络硬件。每个协议属于这些层次之一，就像航线体系结构中的每种功能属于某一层一样。<br /><a href="/img/cn1.9.png">图为航线功能的水平分层</a></p><p>每层通过在该层中执行某些动作或使用直接下层的服务来提供<strong>服务</strong>（service），即<strong>服务模型</strong>（service model）。例如，由第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送，这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送服务，加上第n层的检测和重传丢失报文的功能来实现的。</p><p>一个协议层能够用软件、硬件或两者的结合来实现。一个第n层协议也<strong>分布</strong>在构成该网络的端系统、分组交换机和其他组件中，第n层协议的不同部分常常位于这些网络组件的各部分中。</p><blockquote><p>协议分层<br />优点：<strong>概念化</strong>和<strong>结构化</strong>。<br />潜在的缺点：<br />1 一层可能冗余较低层的功能<br />2 某层的功能可能需要仅在其他某层才出现的信息，违反了层次分离的目标。</p></blockquote><p>各层的所有协议称为协议栈（protocol stack），因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。</p><p>1 <strong>应用层</strong><br />应用层是网络应用程序及它们的应用层协议存留的地方。因特网的应用层包含许多协议，例如HTTP（Web文档的请求和传送）、SMTP（电子邮件报文的传输）和FTP（两个端系统之间的文件传送）。应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，这种位于应用层的信息分组称为<strong>报文</strong>（message）。</p><p>2 <strong>运输层</strong><br />因特网的运输层在应用程序端点之间传送应用层报文。在因特网中，运输层包含TCP和UDP两个运输协议，利用其中任一个都能运输应用层报文。我们把运输层报文称作<strong>报文段</strong>（segment）。<br />——<strong>TCP</strong>提供连接服务，包括了应用层报文向目的地的确保传递和流量控制（即发送方/接收方速率匹配）。<br />——<strong>UDP</strong>提供无连接服务，它不提供不必要服务的服务（没有可靠性、流量控制、拥塞控制等）。</p><p>3 <strong>网络层</strong><br />因特网的网络层负责将称为<strong>数据报</strong>（datagram）的网络层分组从一台主机移动到另一台主机。在一台源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址。</p><p>因特网的网络层包括内容如下：<br />1、著名的<strong>IP协议</strong>，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。IP协议是唯一的，所有具有网络层的因特网组件必须运行IP协议。<br />2、决定路由的<strong>路由选择协议</strong>，它使得数据报根据该路由从源传输到目的地。路由选择协议不唯一。</p><p>网络层包含了IP协议和一些路由选择协议，通常把它称为<strong>IP层</strong>。</p><p>4 <strong>链路层</strong><br />在每个结点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层。由链路层提供的服务取决于应用于该链路的特定链路层协议。网络层将受到来自每个不同的链路层协议的不同服务。我们把链路层分组称为帧（frame）。</p><p>5 <strong>物理层</strong><br />链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的<em>一个一个比特</em>从一个结点移动到下一个结点。在这一层的协议仍然是链路相关的，并且进一步与该链路的<strong>传输媒体相关</strong>（以太网关于双铜绞线、关于同轴电缆、关于光纤的协议等等）。在每种场合中，跨越这些链路移动一个比特是以不同的方式进行的。</p><h3 id="512-osi模型"><a class="markdownIt-Anchor" href="#512-osi模型"></a> 5.1.2 OSI模型</h3><p>因特网协议栈不是唯一的协议栈。国际标准化组织（ISO）提出计算机网络应组织为大约7层，称为开放系统互连（OSI）模型[ISO 2012]。这7层分别是：应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。相比于因特网协议栈，它新增了表示层和会话层。</p><p>1 <strong>表示层</strong><br />表示层的作用是使通信的应用程序能够解释交换数据的含义。这些服务包括数据压缩和数据加密以及数据描述（使应用程序不必担心在各台计算机中表示/存储的内部格式不同的问题）。</p><p>2 <strong>会话层</strong><br />会话层提供了数据交换定界和同步功能，包括了建立检查点和恢复方案的方法。</p><p>应用开发者决定这两个层次提供的服务是否重要，如果该服务重要，应用开发者就在应用程序中构建该功能。</p><h2 id="52-封装"><a class="markdownIt-Anchor" href="#52-封装"></a> 5.2 封装</h2><p>数据从发送端系统的协议栈向下，向上和向下经过中间的链路层交换机和路由器的协议栈，进而向上到达接收端系统的协议栈。链路层交换机实现第一层和第二层，路由器实现了第一层到第三层。<br /><a href="/img/cn1.10.png">图为主机、路由器和链路层交换机，每个包含了不同的层，反映了不同的功能</a></p><p>在发送主机端，一个<strong>应用层报文</strong>被传送给运输层。在最简单的情况下，运输层收取到报文并附上附加信息，应用层报文和运输层首部信息构成了<strong>运输层报文段</strong>。运输层由此<strong>封装</strong>（encapsulation）了应用层报文。运输层再向网络层传递该报文段，网络层增加了如源和目的地端系统地址等网络层首部信息，产生了<strong>网络层数据报</strong>。数据报接下来传递给链路层，链路层增加它自己的链路层首部信息并创建<strong>链路层帧</strong>（link-layer frame）。</p><p>由此可见，在每一层，一个分组具有两种类型的字段：首部字段和<strong>有效载荷字段</strong>（payload field）。有效载荷通常是来自上一层的分组。</p><p>封装的过程在实际中会更加复杂。例如，一个大报文可能被划分为多个运输层的报文段（可能被划分为多个网络层数据报），在接收端则必须从其连续的数据报中重构这样一个报文段。</p><h1 id="六-面对攻击的网络"><a class="markdownIt-Anchor" href="#六-面对攻击的网络"></a> 六、面对攻击的网络</h1><p><strong>网络安全</strong>领域主要探讨以下问题：攻击者如何攻击网络以及如何防御攻击，或者更好的设计能够事先免除这样的攻击的新型体系结构。</p><h2 id="61-有害程序能经过因特网放入到计算机中"><a class="markdownIt-Anchor" href="#61-有害程序能经过因特网放入到计算机中"></a> 6.1 有害程序能经过因特网放入到计算机中</h2><p>一旦恶意软件感染设备，就能够窃取隐私信息，然后发送给攻击者。这些受害设备网络被称为<strong>僵尸网络</strong>（botnet），坏人能够利用僵尸网络控制并有效地对目标主机展开垃圾邮件分发或分布式拒绝服务攻击。</p><p>今天的多数恶意软件是<strong>自我复制</strong>（self-replicating）的：一旦感染了一台主机，就会从那台主机寻求进入更多的主机。恶意软件能够以<strong>病毒</strong>或<strong>蠕虫</strong>的方式进行扩散，<br />——<strong>病毒</strong>（virus）是一种需要某种形式的用户交互来感染用户设备的恶意软件。<br />——<strong>蠕虫</strong>（worm）是一种无需任何明显用户交互就能进入设备的恶意软件。</p><h2 id="62-攻击者能够攻击服务器和网络基础设施"><a class="markdownIt-Anchor" href="#62-攻击者能够攻击服务器和网络基础设施"></a> 6.2 攻击者能够攻击服务器和网络基础设施</h2><p>还有一种宽泛类型的安全性威胁称为拒绝服务攻击（DoS攻击）。Dos攻击能够使得网络、主机或其他基础设施部分不能由合法用户使用。大多数因特网DoS攻击属于下列三种类型之一：</p><p>——<strong>弱点攻击</strong>。如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，或者更糟糕的是主机可能崩溃。<br />——<strong>带宽洪泛</strong>。攻击者向目标主机发送大量分组，分组数量之多使得目标的接入链路变得拥塞，使得合法的分组无法到达服务器。<br />——<strong>连接洪泛</strong>。攻击者在目标主机中创建大量的半开或全开TCP连接。该主机因这些伪造的连接而陷入困境，并停止接受合法的连接。</p><p>对于带宽洪泛攻击，如果某服务器的接入速率为R bps，则攻击者需要以大约R bps的速率来产生危害。当R非常大时，单一攻击源可能无法产生足够大的流量来伤害该服务器，而且如果从单一源发出所有流量的话，上游路由器就能够检测出该攻击并在该流量靠近服务器前就能将其阻挡下来。所以攻击者会采用<strong>分布式DoS</strong>（DDoS，控制多个源并让每个源向目标猛烈发送流量）的方式削弱或损坏服务器，所有受控源的聚合流量速率需要大约R的能力）。相比于DoS，DDoS更加难以检测和防范。</p><p><a href="/img/cn1.11.png">图为DDoS攻击</a></p><h2 id="63-攻击者能够嗅探分组"><a class="markdownIt-Anchor" href="#63-攻击者能够嗅探分组"></a> 6.3 攻击者能够嗅探分组</h2><p>在无线传输设备的附近放置一台被动的接收机，该接收机就能得到传输的每个分组的副本。记录每个流经的分组副本的被动接收机被称为<strong>分组嗅探机</strong>（packet sniffer）。</p><p>嗅探器也能够部署在有线环境中。在有线的广播环境中，如在许多以太网LAN中，分组嗅探器能够获得经该LAN发送的所有分组。此外，获得某机构与因特网连接的接入路由器或接入链路访问权的攻击者能够放置一台嗅探器以产生从该机构出入的每个分组的副本，再对嗅探到的分组进行离线分析，就能得出敏感信息。</p><p>因为分组嗅探器是被动的，所以难以检测出它们的存在。最好的防御嗅探的方法基本上都与<strong>密码学</strong>有关。</p><h2 id="64-攻击者能够伪装成你信任的人"><a class="markdownIt-Anchor" href="#64-攻击者能够伪装成你信任的人"></a> 6.4 攻击者能够伪装成你信任的人</h2><p>生成具有任意源地址、分组内容和目的地址的分组，然后将这个人工制作的分组传输到互联网中极为容易，这种将具有虚假源地址的分组注入因特网的能力被称为<strong>IP哄骗</strong>（IP spoofing），而它只是一个用户能够冒充另一个用户的许多方式的一种。</p><p>应对这种问题，我们需要采用<strong>端点鉴别</strong>。即一种使我们能够确信一个报文源自我们认为它应当来自的地方的机制。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>自顶向下方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/21/hello-world/"/>
    <url>/2022/03/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
